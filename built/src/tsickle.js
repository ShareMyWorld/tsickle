/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/tsickle", ["require", "exports", "path", "source-map", "tsickle/src/class_decorator_downlevel_transformer", "tsickle/src/decorator-annotator", "tsickle/src/decorators", "tsickle/src/es5processor", "tsickle/src/fileoverview_comment_transformer", "tsickle/src/jsdoc", "tsickle/src/modules_manifest", "tsickle/src/rewriter", "tsickle/src/source_map_utils", "tsickle/src/transformer_sourcemap", "tsickle/src/transformer_util", "tsickle/src/type-translator", "tsickle/src/typescript", "tsickle/src/util", "tsickle/src/modules_manifest"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var source_map_1 = require("source-map");
    var class_decorator_downlevel_transformer_1 = require("tsickle/src/class_decorator_downlevel_transformer");
    var decorator = require("tsickle/src/decorator-annotator");
    var decorators_1 = require("tsickle/src/decorators");
    var es5processor = require("tsickle/src/es5processor");
    var fileoverview_comment_transformer_1 = require("tsickle/src/fileoverview_comment_transformer");
    var jsdoc = require("tsickle/src/jsdoc");
    var modules_manifest_1 = require("tsickle/src/modules_manifest");
    var rewriter_1 = require("tsickle/src/rewriter");
    var source_map_utils_1 = require("tsickle/src/source_map_utils");
    var transformer_sourcemap_1 = require("tsickle/src/transformer_sourcemap");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    var typeTranslator = require("tsickle/src/type-translator");
    var ts = require("tsickle/src/typescript");
    var util_1 = require("tsickle/src/util");
    var modules_manifest_2 = require("tsickle/src/modules_manifest");
    exports.ModulesManifest = modules_manifest_2.ModulesManifest;
    /**
     * The header to be used in generated externs.  This is not included in the
     * output of annotate() because annotate() works one file at a time, and
     * typically you create one externs file from the entire compilation unit.
     */
    exports.EXTERNS_HEADER = "/**\n * @externs\n * @suppress {duplicate,checkTypes}\n */\n// NOTE: generated by tsickle, do not edit.\n";
    /**
     * Symbols that are already declared as externs in Closure, that should
     * be avoided by tsickle's "declare ..." => externs.js conversion.
     */
    exports.closureExternsBlacklist = [
        'exports',
        'global',
        'module',
        // ErrorConstructor is the interface of the Error object itself.
        // tsickle detects that this is part of the TypeScript standard library
        // and assumes it's part of the Closure standard library, but this
        // assumption is wrong for ErrorConstructor.  To properly handle this
        // we'd somehow need to map methods defined on the ErrorConstructor
        // interface into properties on Closure's Error object, but for now it's
        // simpler to just blacklist it.
        'ErrorConstructor',
        'Symbol',
        'WorkerGlobalScope',
    ];
    function formatDiagnostics(diags) {
        return diags
            .map(function (d) {
            var res = ts.DiagnosticCategory[d.category];
            if (d.file) {
                res += ' at ' + d.file.fileName + ':';
                if (d.start) {
                    var _a = d.file.getLineAndCharacterOfPosition(d.start), line = _a.line, character = _a.character;
                    res += (line + 1) + ':' + (character + 1) + ':';
                }
            }
            res += ' ' + ts.flattenDiagnosticMessageText(d.messageText, '\n');
            return res;
        })
            .join('\n');
    }
    exports.formatDiagnostics = formatDiagnostics;
    /** @return true if node has the specified modifier flag set. */
    function isAmbient(node) {
        var current = node;
        while (current) {
            if (util_1.hasModifierFlag(current, ts.ModifierFlags.Ambient))
                return true;
            current = current.parent;
        }
        return false;
    }
    /**
     * TypeScript allows you to write identifiers quoted, like:
     *   interface Foo {
     *     'bar': string;
     *     'complex name': string;
     *   }
     *   Foo.bar;  // ok
     *   Foo['bar']  // ok
     *   Foo['complex name']  // ok
     *
     * In Closure-land, we want identify that the legal name 'bar' can become an
     * ordinary field, but we need to skip strings like 'complex name'.
     */
    function isValidClosurePropertyName(name) {
        // In local experimentation, it appears that reserved words like 'var' and
        // 'if' are legal JS and still accepted by Closure.
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }
    /** Returns the Closure name of a function parameter, special-casing destructuring. */
    function getParameterName(param, index) {
        switch (param.name.kind) {
            case ts.SyntaxKind.Identifier:
                var name_1 = rewriter_1.getIdentifierText(param.name);
                // TypeScript allows parameters named "arguments", but Closure
                // disallows this, even in externs.
                if (name_1 === 'arguments')
                    name_1 = 'tsickle_arguments';
                return name_1;
            case ts.SyntaxKind.ArrayBindingPattern:
            case ts.SyntaxKind.ObjectBindingPattern:
                // Closure crashes if you put a binding pattern in the externs.
                // Avoid this by just generating an unused name; the name is
                // ignored anyway.
                return "__" + index;
            default:
                // The above list of kinds is exhaustive.  param.name is 'never' at this point.
                var paramName = param.name;
                throw new Error("unhandled function parameter kind: " + ts.SyntaxKind[paramName.kind]);
        }
    }
    /** Flags that declare a field of the same name if set on a ctor parameter. */
    var FIELD_DECLARATION_MODIFIERS = ts.ModifierFlags.Private |
        ts.ModifierFlags.Protected | ts.ModifierFlags.Public | ts.ModifierFlags.Readonly;
    /**
     * A Rewriter subclass that adds Tsickle-specific (Closure translation) functionality.
     *
     * One Rewriter subclass manages .ts => .ts+Closure translation.
     * Another Rewriter subclass manages .ts => externs translation.
     */
    var ClosureRewriter = /** @class */ (function (_super) {
        __extends(ClosureRewriter, _super);
        function ClosureRewriter(typeChecker, file, host, sourceMapper) {
            var _this = _super.call(this, file, sourceMapper) || this;
            _this.typeChecker = typeChecker;
            _this.host = host;
            /**
             * A mapping of aliases for symbols in the current file, used when emitting types.
             * TypeScript emits imported symbols with unpredictable prefixes. To generate correct type
             * annotations, tsickle creates its own aliases for types, and registers them in this map (see
             * `emitImportDeclaration` and `forwardDeclare()` below). The aliases are then used when emitting
             * types.
             */
            _this.symbolsToAliasedNames = new Map();
            return _this;
        }
        /**
         * Get the ts.Symbol at a location or throw.
         * The TypeScript API can return undefined when fetching a symbol, but
         * in many contexts we know it won't (e.g. our input is already type-checked).
         */
        ClosureRewriter.prototype.mustGetSymbolAtLocation = function (node) {
            var sym = this.typeChecker.getSymbolAtLocation(node);
            if (!sym)
                throw new Error('no symbol');
            return sym;
        };
        /**
         * Handles emittng the jsdoc for methods, including overloads.
         * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.
         * - Total number of parameters will be the maximum count found across all variants.
         * - Different names at the same parameter index will be joined with "_or_"
         * - Variable args (...type[] in TypeScript) will be output as "...type",
         *    except if found at the same index as another argument.
         * @param  fnDecls Pass > 1 declaration for overloads of same name
         * @return The list of parameter names that should be used to emit the actual
         *    function statement; for overloads, name will have been merged.
         */
        ClosureRewriter.prototype.emitFunctionType = function (fnDecls, extraTags) {
            if (extraTags === void 0) { extraTags = []; }
            var typeChecker = this.typeChecker;
            var newDoc = extraTags;
            var lens = fnDecls.map(function (fnDecl) { return fnDecl.parameters.length; });
            var minArgsCount = Math.min.apply(Math, __spread(lens));
            var maxArgsCount = Math.max.apply(Math, __spread(lens));
            var isConstructor = fnDecls.find(function (d) { return d.kind === ts.SyntaxKind.Constructor; }) !== undefined;
            // For each parameter index i, paramTags[i] is an array of parameters
            // that can be found at index i.  E.g.
            //    function foo(x: string)
            //    function foo(y: number, z: string)
            // then paramTags[0] = [info about x, info about y].
            var paramTags = [];
            var returnTags = [];
            var typeParameterNames = new Set();
            try {
                for (var fnDecls_1 = __values(fnDecls), fnDecls_1_1 = fnDecls_1.next(); !fnDecls_1_1.done; fnDecls_1_1 = fnDecls_1.next()) {
                    var fnDecl = fnDecls_1_1.value;
                    // Construct the JSDoc comment by reading the existing JSDoc, if
                    // any, and merging it with the known types of the function
                    // parameters and return type.
                    var docTags = this.getJSDoc(fnDecl) || [];
                    try {
                        // Copy all the tags other than @param/@return into the new
                        // JSDoc without any change; @param/@return are handled specially.
                        // TODO: there may be problems if an annotation doesn't apply to all overloads;
                        // is it worth checking for this and erroring?
                        for (var docTags_1 = __values(docTags), docTags_1_1 = docTags_1.next(); !docTags_1_1.done; docTags_1_1 = docTags_1.next()) {
                            var tag = docTags_1_1.value;
                            if (tag.tagName === 'param' || tag.tagName === 'return')
                                continue;
                            newDoc.push(tag);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (docTags_1_1 && !docTags_1_1.done && (_a = docTags_1.return)) _a.call(docTags_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    // Add @abstract on "abstract" declarations.
                    if (util_1.hasModifierFlag(fnDecl, ts.ModifierFlags.Abstract)) {
                        newDoc.push({ tagName: 'abstract' });
                    }
                    // Add any @template tags.
                    // Multiple declarations with the same template variable names should work:
                    // the declarations get turned into union types, and Closure Compiler will need
                    // to find a union where all type arguments are satisfied.
                    if (fnDecl.typeParameters) {
                        try {
                            for (var _b = __values(fnDecl.typeParameters), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var tp = _c.value;
                                typeParameterNames.add(rewriter_1.getIdentifierText(tp.name));
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    // Merge the parameters into a single list of merged names and list of types
                    var sig = typeChecker.getSignatureFromDeclaration(fnDecl);
                    if (!sig)
                        throw new Error("invalid signature " + fnDecl.name);
                    for (var i = 0; i < sig.declaration.parameters.length; i++) {
                        var paramNode = sig.declaration.parameters[i];
                        var name_2 = getParameterName(paramNode, i);
                        var isThisParam = name_2 === 'this';
                        var newTag = {
                            tagName: isThisParam ? 'this' : 'param',
                            optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                            parameterName: isThisParam ? undefined : name_2,
                        };
                        var type = typeChecker.getTypeAtLocation(paramNode);
                        if (paramNode.dotDotDotToken !== undefined) {
                            newTag.restParam = true;
                            // In TypeScript you write "...x: number[]", but in Closure
                            // you don't write the array: "@param {...number} x".  Unwrap
                            // the Array<> wrapper.
                            var typeRef = type;
                            if (!typeRef.typeArguments)
                                throw new Error('invalid rest param');
                            type = typeRef.typeArguments[0];
                        }
                        newTag.type = this.typeToClosure(fnDecl, type);
                        try {
                            for (var docTags_2 = __values(docTags), docTags_2_1 = docTags_2.next(); !docTags_2_1.done; docTags_2_1 = docTags_2.next()) {
                                var _e = docTags_2_1.value, tagName = _e.tagName, parameterName = _e.parameterName, text = _e.text;
                                if (tagName === 'param' && parameterName === newTag.parameterName) {
                                    newTag.text = text;
                                    break;
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (docTags_2_1 && !docTags_2_1.done && (_f = docTags_2.return)) _f.call(docTags_2);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        if (!paramTags[i])
                            paramTags.push([]);
                        paramTags[i].push(newTag);
                    }
                    // Return type.
                    if (!isConstructor) {
                        var retType = typeChecker.getReturnTypeOfSignature(sig);
                        var retTypeString = this.typeToClosure(fnDecl, retType);
                        var returnDoc = void 0;
                        try {
                            for (var docTags_3 = __values(docTags), docTags_3_1 = docTags_3.next(); !docTags_3_1.done; docTags_3_1 = docTags_3.next()) {
                                var _g = docTags_3_1.value, tagName = _g.tagName, text = _g.text;
                                if (tagName === 'return') {
                                    returnDoc = text;
                                    break;
                                }
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (docTags_3_1 && !docTags_3_1.done && (_h = docTags_3.return)) _h.call(docTags_3);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        returnTags.push({
                            tagName: 'return',
                            type: retTypeString,
                            text: returnDoc,
                        });
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (fnDecls_1_1 && !fnDecls_1_1.done && (_j = fnDecls_1.return)) _j.call(fnDecls_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            if (typeParameterNames.size > 0) {
                newDoc.push({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });
            }
            // Merge the JSDoc tags for each overloaded parameter.
            // Ensure each parameter has a unique name; the merging process can otherwise
            // accidentally generate the same parameter name twice.
            var paramNames = new Set();
            var foundOptional = false;
            for (var i = 0; i < maxArgsCount; i++) {
                var paramTag = jsdoc.merge(paramTags[i]);
                if (paramNames.has(paramTag.parameterName)) {
                    paramTag.parameterName += i.toString();
                }
                paramNames.add(paramTag.parameterName);
                // If the tag is optional, mark parameters following optional as optional,
                // even if they are not, since Closure restricts this, see
                // https://github.com/google/closure-compiler/issues/2314
                if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {
                    foundOptional = true;
                    paramTag.optional = true;
                }
                newDoc.push(paramTag);
                if (paramTag.restParam) {
                    // Cannot have any parameters after a rest param.
                    // Just dump the remaining parameters.
                    break;
                }
            }
            // Merge the JSDoc tags for each overloaded return.
            if (!isConstructor) {
                newDoc.push(jsdoc.merge(returnTags));
            }
            this.emit('\n' + jsdoc.toString(newDoc));
            return newDoc.filter(function (t) { return t.tagName === 'param'; }).map(function (t) { return t.parameterName; });
            var e_5, _j, e_1, _a, e_2, _d, e_3, _f, e_4, _h;
        };
        /**
         * Returns null if there is no existing comment.
         */
        ClosureRewriter.prototype.getJSDoc = function (node) {
            var text = node.getFullText();
            var comments = ts.getLeadingCommentRanges(text, 0);
            if (!comments || comments.length === 0)
                return null;
            // We need to search backwards for the first JSDoc comment to avoid ignoring such when another
            // code-level comment is between that comment and the function declaration (see
            // testfiles/doc_params for an example).
            var docRelativePos = 0;
            var parsed = null;
            for (var i = comments.length - 1; i >= 0; i--) {
                var _a = comments[i], pos = _a.pos, end = _a.end;
                // end is relative within node.getFullText(), add getFullStart to obtain coordinates that are
                // comparable to node positions.
                var docRelativeEnd = end + node.getFullStart();
                if (docRelativeEnd <= this.file.getStart() &&
                    this.file.text.substring(docRelativeEnd).startsWith('\n\n')) {
                    // This comment is at the very beginning of the file and there's an empty line between the
                    // comment and this node, it's a "detached comment". That means we should treat it as a
                    // file-level comment, not attached to this code node.
                    return null;
                }
                var comment = text.substring(pos, end);
                parsed = jsdoc.parse(comment);
                if (parsed) {
                    docRelativePos = node.getFullStart() + pos;
                    break;
                }
            }
            if (!parsed)
                return null;
            if (parsed.warnings) {
                var start = docRelativePos;
                this.diagnostics.push({
                    file: this.file,
                    start: start,
                    length: node.getStart() - start,
                    messageText: parsed.warnings.join('\n'),
                    category: ts.DiagnosticCategory.Warning,
                    code: 0,
                });
            }
            return parsed.tags;
        };
        ClosureRewriter.prototype.maybeAddTemplateClause = function (docTags, decl) {
            var _this = this;
            if (!decl.typeParameters)
                return;
            // Closure does not support template constraints (T extends X).
            docTags.push({
                tagName: 'template',
                text: decl.typeParameters
                    .map(function (tp) {
                    if (tp.constraint) {
                        _this.emit('\n// unsupported: template constraints.');
                    }
                    return rewriter_1.getIdentifierText(tp.name);
                })
                    .join(', ')
            });
        };
        ClosureRewriter.prototype.maybeAddHeritageClauses = function (docTags, decl) {
            if (!decl.heritageClauses)
                return;
            try {
                for (var _a = __values(decl.heritageClauses), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var heritage = _b.value;
                    if (!heritage.types)
                        continue;
                    var isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;
                    if (isClass && heritage.token !== ts.SyntaxKind.ImplementsKeyword && !isAmbient(decl)) {
                        // If a class has "extends Foo", that is preserved in the ES6 output
                        // and we don't need to do anything.  But if it has "implements Foo",
                        // that is a TS-specific thing and we need to translate it to the
                        // the Closure "@implements {Foo}".
                        // However for ambient declarations, we only emit externs, and in those we do need to
                        // add "@extends {Foo}" as they use ES5 syntax.
                        continue;
                    }
                    try {
                        for (var _c = __values(heritage.types), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var impl = _d.value;
                            var tagName = decl.kind === ts.SyntaxKind.InterfaceDeclaration ? 'extends' : 'implements';
                            // We can only @implements an interface, not a class.
                            // But it's fine to translate TS "implements Class" into Closure
                            // "@extends {Class}" because this is just a type hint.
                            var typeChecker = this.typeChecker;
                            var sym = this.mustGetSymbolAtLocation(impl.expression);
                            var alias = sym;
                            if (sym.flags & ts.SymbolFlags.TypeAlias) {
                                // It's implementing a type alias.  Follow the type alias back
                                // to the original symbol to check whether it's a type or a value.
                                var type = this.typeChecker.getDeclaredTypeOfSymbol(sym);
                                if (!type.symbol) {
                                    // It's not clear when this can happen, but if it does all we
                                    // do is fail to emit the @implements, which isn't so harmful.
                                    continue;
                                }
                                alias = type.symbol;
                            }
                            if (alias.flags & ts.SymbolFlags.Alias) {
                                alias = typeChecker.getAliasedSymbol(alias);
                            }
                            var typeTranslator_1 = this.newTypeTranslator(impl.expression);
                            if (typeTranslator_1.isBlackListed(alias)) {
                                continue;
                            }
                            if (alias.flags & ts.SymbolFlags.Class) {
                                if (!isClass) {
                                    // Only classes can extend classes in TS. Ignoring the heritage clause should be safe,
                                    // as interfaces are @record anyway, so should prevent property disambiguation.
                                    // Problem: validate that methods are there?
                                    continue;
                                }
                                tagName = 'extends';
                            }
                            else if (alias.flags & ts.SymbolFlags.Value) {
                                // If the symbol was already in the value namespace, then it will
                                // not be a type in the Closure output (because Closure collapses
                                // the type and value namespaces).  Just ignore the implements.
                                continue;
                            }
                            // typeToClosure includes nullability modifiers, so call symbolToString directly here.
                            docTags.push({ tagName: tagName, type: typeTranslator_1.symbolToString(sym, true) });
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                }
                finally { if (e_7) throw e_7.error; }
            }
            var e_7, _f, e_6, _e;
        };
        /** Emits a type annotation in JSDoc, or {?} if the type is unavailable. */
        ClosureRewriter.prototype.emitJSDocType = function (node, additionalDocTag, type) {
            this.emit(' /**');
            if (additionalDocTag) {
                this.emit(' ' + additionalDocTag);
            }
            this.emit(" @type {" + this.typeToClosure(node, type) + "} */");
        };
        /**
         * Convert a TypeScript ts.Type into the equivalent Closure type.
         *
         * @param context The ts.Node containing the type reference; used for resolving symbols
         *     in context.
         * @param type The type to translate; if not provided, the Node's type will be used.
         * @param resolveAlias If true, do not emit aliases as their symbol, but rather as the resolved
         *     type underlying the alias. This should be true only when emitting the typedef itself.
         */
        ClosureRewriter.prototype.typeToClosure = function (context, type, resolveAlias) {
            if (this.host.untyped) {
                return '?';
            }
            var typeChecker = this.typeChecker;
            if (!type) {
                type = typeChecker.getTypeAtLocation(context);
            }
            return this.newTypeTranslator(context).translate(type, resolveAlias);
        };
        ClosureRewriter.prototype.newTypeTranslator = function (context) {
            var _this = this;
            var translator = new typeTranslator.TypeTranslator(this.typeChecker, context, this.host.typeBlackListPaths, this.symbolsToAliasedNames);
            translator.warn = function (msg) { return _this.debugWarn(context, msg); };
            return translator;
        };
        /**
         * debug logs a debug warning.  These should only be used for cases
         * where tsickle is making a questionable judgement about what to do.
         * By default, tsickle does not report any warnings to the caller,
         * and warnings are hidden behind a debug flag, as warnings are only
         * for tsickle to debug itself.
         */
        ClosureRewriter.prototype.debugWarn = function (node, messageText) {
            if (!this.host.logWarning)
                return;
            // Use a ts.Diagnosic so that the warning includes context and file offets.
            var diagnostic = {
                file: this.file,
                start: node.getStart(),
                length: node.getEnd() - node.getStart(),
                messageText: messageText,
                category: ts.DiagnosticCategory.Warning,
                code: 0,
            };
            this.host.logWarning(diagnostic);
        };
        return ClosureRewriter;
    }(rewriter_1.Rewriter));
    // Matches common extensions of TypeScript input filenames
    var extension = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    var FILEOVERVIEW_COMMENTS = new Set(['fileoverview', 'externs', 'modName', 'mods', 'pintomodule']);
    /** Annotator translates a .ts to a .ts with Closure annotations. */
    var Annotator = /** @class */ (function (_super) {
        __extends(Annotator, _super);
        function Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {
            var _this = _super.call(this, typeChecker, file, host, sourceMapper) || this;
            _this.tsHost = tsHost;
            _this.tsOpts = tsOpts;
            /** Exported symbol names that have been generated by expanding an "export * from ...". */
            _this.generatedExports = new Set();
            /** Collection of Identifiers used in an `import {foo}` declaration with their Symbol */
            _this.importedNames = [];
            _this.templateSpanStackCount = 0;
            _this.polymerBehaviorStackCount = 0;
            _this.forwardDeclareCounter = 0;
            return _this;
        }
        Annotator.prototype.annotate = function () {
            this.visit(this.file);
            return this.getOutput();
        };
        Annotator.prototype.getExportDeclarationNames = function (node) {
            var _this = this;
            switch (node.kind) {
                case ts.SyntaxKind.VariableStatement:
                    var varDecl = node;
                    return varDecl.declarationList.declarations.map(function (d) { return _this.getExportDeclarationNames(d)[0]; });
                case ts.SyntaxKind.VariableDeclaration:
                case ts.SyntaxKind.FunctionDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.ModuleDeclaration:
                    var decl = node;
                    if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {
                        break;
                    }
                    return [decl.name];
                case ts.SyntaxKind.TypeAliasDeclaration:
                    var typeAlias = node;
                    return [typeAlias.name];
                default:
                    break;
            }
            this.error(node, "unsupported export declaration " + ts.SyntaxKind[node.kind] + ": " + node.getText());
            return [];
        };
        /**
         * Emits an ES6 export for the ambient declaration behind node, if it is indeed exported.
         */
        Annotator.prototype.maybeEmitAmbientDeclarationExport = function (node) {
            // In TypeScript, `export declare` simply generates no code in the exporting module, but does
            // generate a regular import in the importing module.
            // For Closure Compiler, such declarations must still be exported, so that importing code in
            // other modules can reference them. Because tsickle generates global symbols for such types,
            // the appropriate semantics are referencing the global name.
            if (this.host.untyped || !util_1.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                return;
            }
            var declNames = this.getExportDeclarationNames(node);
            try {
                for (var declNames_1 = __values(declNames), declNames_1_1 = declNames_1.next(); !declNames_1_1.done; declNames_1_1 = declNames_1.next()) {
                    var decl = declNames_1_1.value;
                    var sym = this.mustGetSymbolAtLocation(decl);
                    var isValue = sym.flags & ts.SymbolFlags.Value;
                    var declName = rewriter_1.getIdentifierText(decl);
                    if (node.kind === ts.SyntaxKind.VariableStatement) {
                        // For variables, TypeScript rewrites every reference to the variable name as an
                        // "exports." access, to maintain mutable ES6 exports semantics. Indirecting through the
                        // window object means we reference the correct global symbol. Closure Compiler does
                        // understand that "var foo" in externs corresponds to "window.foo".
                        this.emit("\nexports." + declName + " = window." + declName + ";\n");
                    }
                    else if (!isValue) {
                        // Do not emit re-exports for ModuleDeclarations.
                        // Ambient ModuleDeclarations are always referenced as global symbols, so they don't need to
                        // be exported.
                        if (node.kind === ts.SyntaxKind.ModuleDeclaration)
                            continue;
                        // Non-value objects do not exist at runtime, so we cannot access the symbol (it only
                        // exists in externs). Export them as a typedef, which forwards to the type in externs.
                        this.emit("\n/** @typedef {" + declName + "} */\nexports." + declName + ";\n");
                    }
                    else {
                        this.emit("\nexports." + declName + " = " + declName + ";\n");
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (declNames_1_1 && !declNames_1_1.done && (_a = declNames_1.return)) _a.call(declNames_1);
                }
                finally { if (e_8) throw e_8.error; }
            }
            var e_8, _a;
        };
        /**
         * Examines a ts.Node and decides whether to do special processing of it for output.
         *
         * @return True if the ts.Node has been handled, false if we should
         *     emit it as is and visit its children.
         */
        Annotator.prototype.maybeProcess = function (node) {
            var _this = this;
            if (util_1.hasModifierFlag(node, ts.ModifierFlags.Ambient) || util_1.isDtsFileName(this.file.fileName)) {
                // An ambient declaration declares types for TypeScript's benefit, so we want to skip Tsickle
                // conversion of its contents.
                this.writeRange(node, node.getFullStart(), node.getEnd());
                // ... but it might need to be exported for downstream importing code.
                this.maybeEmitAmbientDeclarationExport(node);
                return true;
            }
            if (this.currentDecoratorConverter) {
                this.currentDecoratorConverter.beforeProcessNode(node);
            }
            switch (node.kind) {
                case ts.SyntaxKind.SourceFile:
                    this.handleSourceFile(node);
                    return true;
                case ts.SyntaxKind.ImportDeclaration:
                    (_a = this.importedNames).push.apply(_a, __spread(decorator.collectImportedNames(this.typeChecker, node)));
                    return this.emitImportDeclaration(node);
                case ts.SyntaxKind.ExportDeclaration:
                    var exportDecl = node;
                    this.writeLeadingTrivia(node);
                    this.emit('export');
                    var exportedSymbols = [];
                    if (!exportDecl.exportClause && exportDecl.moduleSpecifier) {
                        // It's an "export * from ..." statement.
                        // Rewrite it to re-export each exported symbol directly.
                        exportedSymbols = this.expandSymbolsFromExportStar(exportDecl);
                        var exportSymbolsToEmit = exportedSymbols.filter(function (s) { return _this.shouldEmitExportSymbol(s.sym); });
                        this.emit(" {" + exportSymbolsToEmit.map(function (e) { return rewriter_1.unescapeName(e.name); }).join(',') + "}");
                    }
                    else {
                        if (exportDecl.exportClause) {
                            exportedSymbols = this.getNamedSymbols(exportDecl.exportClause.elements);
                            this.visit(exportDecl.exportClause);
                        }
                    }
                    if (exportDecl.moduleSpecifier) {
                        this.emit(" from '" + this.resolveModuleSpecifier(exportDecl.moduleSpecifier) + "';");
                    }
                    else {
                        // export {...};
                        this.emit(';');
                    }
                    this.addSourceMapping(node);
                    if (exportDecl.moduleSpecifier) {
                        this.forwardDeclare(exportDecl.moduleSpecifier, exportedSymbols);
                    }
                    if (exportedSymbols.length) {
                        this.emitTypeDefExports(exportedSymbols);
                    }
                    return true;
                case ts.SyntaxKind.InterfaceDeclaration:
                    this.emitInterface(node);
                    // Emit the TS interface verbatim, with no tsickle processing of properties.
                    this.writeRange(node, node.getFullStart(), node.getEnd());
                    return true;
                case ts.SyntaxKind.VariableDeclaration:
                    var varDecl = node;
                    // Only emit a type annotation when it's a plain variable and
                    // not a binding pattern, as Closure doesn't(?) have a syntax
                    // for annotating binding patterns.  See issue #128.
                    // Don't emit type annotation when the variable statement is a @polymerBehavior,
                    // as otherwise the polymer closure checker will fail.
                    // See b/64389806
                    if (this.polymerBehaviorStackCount === 0 &&
                        varDecl.name.kind === ts.SyntaxKind.Identifier) {
                        this.emitJSDocType(varDecl);
                    }
                    return false;
                case ts.SyntaxKind.ClassDeclaration:
                    var classNode = node;
                    this.visitClassDeclaration(classNode);
                    return true;
                case ts.SyntaxKind.PublicKeyword:
                case ts.SyntaxKind.PrivateKeyword:
                    // The "public"/"private" keywords are encountered in two places:
                    // 1) In class fields (which don't appear in the transformed output).
                    // 2) In "parameter properties", e.g.
                    //      constructor(/** @export */ public foo: string).
                    // In case 2 it's important to not emit that JSDoc in the generated
                    // constructor, as this is illegal for Closure.  It's safe to just
                    // always skip comments preceding the 'public' keyword.
                    // See test_files/parameter_properties.ts.
                    this.writeNode(node, /* skipComments */ true);
                    return true;
                case ts.SyntaxKind.Constructor:
                    var ctor = node;
                    this.emitFunctionType([ctor]);
                    // Write the "constructor(...) {" bit, but iterate through any
                    // parameters if given so that we can examine them more closely.
                    this.writeNodeFrom(ctor, ctor.getStart());
                    return true;
                case ts.SyntaxKind.ArrowFunction:
                    // It's difficult to annotate arrow functions due to a bug in
                    // TypeScript (see tsickle issue 57).  For now, just pass them
                    // through unannotated.
                    return false;
                case ts.SyntaxKind.FunctionDeclaration:
                case ts.SyntaxKind.MethodDeclaration:
                case ts.SyntaxKind.GetAccessor:
                case ts.SyntaxKind.SetAccessor:
                    var fnDecl = node;
                    var tags = decorators_1.hasExportingDecorator(node, this.typeChecker) ? [{ tagName: 'export' }] : [];
                    if (!fnDecl.body) {
                        // Two cases: abstract methods and overloaded methods/functions.
                        // Abstract methods are handled in emitTypeAnnotationsHandler.
                        // Overloads are union-ized into the shared type in emitFunctionType.
                        return false;
                    }
                    this.emitFunctionType([fnDecl], tags);
                    this.newTypeTranslator(fnDecl).blacklistTypeParameters(this.symbolsToAliasedNames, fnDecl.typeParameters);
                    this.writeNodeFrom(fnDecl, fnDecl.getStart());
                    return true;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    this.writeNode(node);
                    this.visitTypeAlias(node);
                    return true;
                case ts.SyntaxKind.EnumDeclaration:
                    this.processEnum(node);
                    return true;
                case ts.SyntaxKind.TemplateSpan:
                    this.templateSpanStackCount++;
                    this.writeNode(node);
                    this.templateSpanStackCount--;
                    return true;
                case ts.SyntaxKind.TypeAssertionExpression:
                case ts.SyntaxKind.AsExpression:
                    // Both of these cases are AssertionExpressions.
                    var typeAssertion = node;
                    if (this.polymerBehaviorStackCount > 0) {
                        // Don't emit type casts for Polymer behaviors that are declared
                        // by calling the Polymer function
                        // as the Polymer closure plugin does not work when emitting them.
                        // See b/64389806.
                        // Note: This only matters in the transformer version of tsickle,
                        // as the non transformer version never emitted type casts due to
                        // https://github.com/Microsoft/TypeScript/issues/9873 (see below).
                        return false;
                    }
                    // When using a type casts in template expressions,
                    // closure requires another pair of parens, otherwise it will
                    // complain with "Misplaced type annotation. Type annotations are not allowed here."
                    if (this.templateSpanStackCount > 0) {
                        this.emit('(');
                    }
                    this.emitJSDocType(typeAssertion);
                    // When TypeScript emits JS, it removes one layer of "redundant"
                    // parens, but we need them for the Closure type assertion.  Work
                    // around this by using two parens.  See test_files/coerce.*.
                    // This is needed in both, the transformer and non transformer version.
                    // TODO: in the non transformer version, the comment is currently dropped
                    //  alltegether from pure assignments due to
                    //  https://github.com/Microsoft/TypeScript/issues/9873.
                    this.emit('((');
                    this.writeNode(node);
                    this.emit('))');
                    if (this.templateSpanStackCount > 0) {
                        this.emit(')');
                    }
                    return true;
                case ts.SyntaxKind.NonNullExpression:
                    var nnexpr = node;
                    var type = this.typeChecker.getTypeAtLocation(nnexpr.expression);
                    if (type.flags & ts.TypeFlags.Union) {
                        var nonNullUnion = type
                            .types.filter(function (t) { return (t.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) === 0; });
                        var typeCopy = Object.assign({}, type);
                        typeCopy.types = nonNullUnion;
                        type = typeCopy;
                    }
                    // See comment above.
                    if (this.templateSpanStackCount > 0) {
                        this.emit('(');
                    }
                    this.emitJSDocType(nnexpr, undefined, type);
                    // See comment above.
                    this.emit('((');
                    this.writeNode(nnexpr.expression);
                    this.emit('))');
                    if (this.templateSpanStackCount > 0) {
                        this.emit(')');
                    }
                    return true;
                case ts.SyntaxKind.PropertyDeclaration:
                case ts.SyntaxKind.VariableStatement:
                    var docTags = this.getJSDoc(node) || [];
                    if (decorators_1.hasExportingDecorator(node, this.typeChecker)) {
                        docTags.push({ tagName: 'export' });
                    }
                    if (docTags.length > 0 && node.getFirstToken()) {
                        this.emit('\n');
                        this.emit(jsdoc.toString(docTags));
                        var isPolymerBehavior = docTags.some(function (t) { return t.tagName === 'polymerBehavior'; });
                        if (isPolymerBehavior) {
                            this.polymerBehaviorStackCount++;
                        }
                        this.writeNodeFrom(node, node.getStart());
                        if (isPolymerBehavior) {
                            this.polymerBehaviorStackCount--;
                        }
                        return true;
                    }
                    break;
                case ts.SyntaxKind.PropertyAssignment:
                    var pa = node;
                    if (isPolymerBehaviorPropertyInCallExpression(pa)) {
                        this.polymerBehaviorStackCount++;
                        this.writeNodeFrom(node, node.getStart());
                        this.polymerBehaviorStackCount--;
                        return true;
                    }
                    return false;
                case ts.SyntaxKind.ElementAccessExpression:
                    // Warn for quoted accesses to properties that have a symbol declared.
                    // Mixing quoted and non-quoted access to a symbol (x['foo'] and x.foo) risks breaking
                    // Closure Compiler renaming. Quoted access is more cumbersome to write than dotted access
                    // though, so chances are users did intend to avoid renaming. The better fix is to use
                    // `declare interface` though.
                    var eae = node;
                    if (!eae.argumentExpression ||
                        eae.argumentExpression.kind !== ts.SyntaxKind.StringLiteral) {
                        return false;
                    }
                    var quotedPropSym = this.typeChecker.getSymbolAtLocation(eae.argumentExpression);
                    // If it has a symbol, it's actually a regular declared property.
                    if (!quotedPropSym)
                        return false;
                    var declarationHasQuotes = !quotedPropSym.declarations || quotedPropSym.declarations.some(function (d) {
                        var decl = d;
                        if (!decl.name)
                            return false;
                        return decl.name.kind === ts.SyntaxKind.StringLiteral;
                    });
                    // If the property is declared with quotes, it should also be accessed with them.
                    if (declarationHasQuotes)
                        return false;
                    var propName = eae.argumentExpression.text;
                    // Properties containing non-JS identifier names can only be accessed with quotes.
                    if (!isValidClosurePropertyName(propName))
                        return false;
                    var symName = this.typeChecker.symbolToString(quotedPropSym);
                    this.debugWarn(eae, "Declared property " + symName + " accessed with quotes. " +
                        "This can lead to renaming bugs. A better fix is to use 'declare interface' " +
                        "on the declaration.");
                    // Previously, the code below changed the quoted into a non-quoted access.
                    // this.writeNode(eae.expression);
                    // this.emit(`.${propName}`);
                    return false;
                case ts.SyntaxKind.PropertyAccessExpression:
                    // Convert dotted accesses to types that have an index type declared to quoted accesses, to
                    // avoid Closure renaming one access but not the other.
                    // This can happen because TS allows dotted access to string index types.
                    var pae = node;
                    var t = this.typeChecker.getTypeAtLocation(pae.expression);
                    if (!t.getStringIndexType())
                        return false;
                    // Types can have string index signatures and declared properties (of the matching type).
                    // These properties have a symbol, as opposed to pure string index types.
                    var propSym = this.typeChecker.getSymbolAtLocation(pae.name);
                    // The decision to return below is a judgement call. Presumably, in most situations, dotted
                    // access to a property is correct, and should not be turned into quoted access even if
                    // there is a string index on the type. However it is possible to construct programs where
                    // this is incorrect, e.g. where user code assigns into a property through the index access
                    // in another location.
                    if (propSym)
                        return false;
                    this.debugWarn(pae, this.typeChecker.typeToString(t) +
                        " has a string index type but is accessed using dotted access. " +
                        "Quoting the access.");
                    this.writeNode(pae.expression);
                    this.emit('["');
                    this.writeNode(pae.name);
                    this.emit('"]');
                    return true;
                case ts.SyntaxKind.Decorator:
                    if (this.currentDecoratorConverter) {
                        return this.currentDecoratorConverter.maybeProcessDecorator(node);
                    }
                    return false;
                default:
                    break;
            }
            return false;
            var _a;
        };
        Annotator.prototype.shouldEmitExportSymbol = function (sym) {
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = this.typeChecker.getAliasedSymbol(sym);
            }
            if ((sym.flags & ts.SymbolFlags.Value) === 0) {
                // Note: We create explicit reexports via closure at another place in
                return false;
            }
            if (sym.flags & ts.SymbolFlags.ConstEnum) {
                return false;
            }
            return true;
        };
        Annotator.prototype.handleSourceFile = function (sf) {
            // Emit leading detached comments: comments separated by a \n\n from the document.
            // While handlers below generally emit comments preceding them, not all of them do in all
            // situations (e.g. JSDoc preceding a class).
            // This is symmetric with `getJSDoc` below not returning detached file level comments.
            var comments = ts.getLeadingCommentRanges(sf.text, 0) || [];
            var start = sf.getFullStart();
            for (var i = comments.length - 1; i >= 0; i--) {
                if (sf.text.substring(comments[i].end, comments[i].end + 2) === '\n\n') {
                    this.emit(sf.text.substring(0, comments[i].end + 2));
                    start = comments[i].end + 2;
                    break;
                }
            }
            this.writeNodeFrom(sf, start);
        };
        /**
         * Given a "export * from ..." statement, gathers the symbol names it actually
         * exports to be used in a statement like "export {foo, bar, baz} from ...".
         *
         * This is necessary because TS transpiles "export *" by just doing a runtime loop
         * over the target module's exports, which means Closure won't see the declarations/types
         * that are exported.
         */
        Annotator.prototype.expandSymbolsFromExportStar = function (exportDecl) {
            // You can't have an "export *" without a module specifier.
            var moduleSpecifier = exportDecl.moduleSpecifier;
            // Gather the names of local exports, to avoid reexporting any
            // names that are already locally exported.
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(this.file);
            var moduleExports = moduleSymbol && moduleSymbol.exports || new Map();
            // Expand the export list, then filter it to the symbols we want to reexport.
            var exports = this.typeChecker.getExportsOfModule(this.mustGetSymbolAtLocation(moduleSpecifier));
            var reexports = new Set();
            try {
                for (var exports_1 = __values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
                    var sym = exports_1_1.value;
                    var name_3 = rewriter_1.unescapeName(sym.name);
                    if (moduleExports instanceof Map) {
                        if (moduleExports.has(name_3)) {
                            // This name is shadowed by a local definition, such as:
                            // - export var foo ...
                            // - export {foo} from ...
                            // - export {bar as foo} from ...
                            continue;
                        }
                    }
                    else {
                        // TODO(#634): check if this is a safe cast.
                        if (moduleExports.has(name_3))
                            continue;
                    }
                    if (this.generatedExports.has(name_3)) {
                        // Already exported via an earlier expansion of an "export * from ...".
                        continue;
                    }
                    this.generatedExports.add(name_3);
                    reexports.add(sym);
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
                }
                finally { if (e_9) throw e_9.error; }
            }
            return Array.from(reexports.keys()).map(function (sym) {
                return { name: sym.name, sym: sym };
            });
            var e_9, _a;
        };
        /**
         * Write an `exports.` assignment for each type alias exported in the given `exports`.
         * TypeScript by itself does not export non-value symbols (e.g. interfaces, typedefs), as it
         * expects to remove those entirely for runtime. For Closure, types must be
         * exported as downstream code will import the type.
         *
         * The tsickle pass turns interfaces into values by generating a `function MyInterface() {}` for
         * them, so in the second conversion pass, TypeScript does export a value for them. However for
         * pure typedefs, tsickle only generates a property access with a JSDoc comment, so they need to
         * be exported explicitly here.
         */
        Annotator.prototype.emitTypeDefExports = function (exports) {
            if (this.host.untyped)
                return;
            try {
                for (var exports_2 = __values(exports), exports_2_1 = exports_2.next(); !exports_2_1.done; exports_2_1 = exports_2.next()) {
                    var exp = exports_2_1.value;
                    if (exp.sym.flags & ts.SymbolFlags.Alias)
                        exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);
                    var isTypeAlias = ((exp.sym.flags & ts.SymbolFlags.TypeAlias) !== 0 &&
                        (exp.sym.flags & ts.SymbolFlags.Value) === 0) ||
                        (exp.sym.flags & ts.SymbolFlags.Interface) !== 0 &&
                            (exp.sym.flags & ts.SymbolFlags.Value) === 0;
                    if (!isTypeAlias)
                        continue;
                    var typeName = this.symbolsToAliasedNames.get(exp.sym) || exp.sym.name;
                    this.emit("\n/** @typedef {" + typeName + "} */\nexports." + exp.name + "; // re-export typedef");
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (exports_2_1 && !exports_2_1.done && (_a = exports_2.return)) _a.call(exports_2);
                }
                finally { if (e_10) throw e_10.error; }
            }
            var e_10, _a;
        };
        /**
         * Convert from implicit `import {} from 'pkg'` to `import {} from 'pkg/index'.
         * TypeScript supports the shorthand, but not all ES6 module loaders do.
         * Workaround for https://github.com/Microsoft/TypeScript/issues/12597
         */
        Annotator.prototype.resolveModuleSpecifier = function (moduleSpecifier) {
            if (moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
                throw new Error("unhandled moduleSpecifier kind: " + ts.SyntaxKind[moduleSpecifier.kind]);
            }
            var moduleId = moduleSpecifier.text;
            if (this.host.convertIndexImportShorthand) {
                if (!this.tsOpts || !this.tsHost) {
                    throw new Error('option convertIndexImportShorthand requires that annotate be called with a TypeScript host and options.');
                }
                var resolved = ts.resolveModuleName(moduleId, this.file.fileName, this.tsOpts, this.tsHost);
                if (resolved && resolved.resolvedModule) {
                    var requestedModule = moduleId.replace(extension, '');
                    var resolvedModule = resolved.resolvedModule.resolvedFileName.replace(extension, '');
                    if (resolvedModule.indexOf('node_modules') === -1 &&
                        requestedModule.substr(requestedModule.lastIndexOf('/')) !==
                            resolvedModule.substr(resolvedModule.lastIndexOf('/'))) {
                        moduleId = './' +
                            path.relative(path.dirname(this.file.fileName), resolvedModule)
                                .replace(path.sep, '/');
                    }
                }
            }
            return moduleId;
        };
        /**
         * Handles emit of an "import ..." statement.
         * We need to do a bit of rewriting so that imported types show up under the
         * correct name in JSDoc.
         * @return true if the decl was handled, false to allow default processing.
         */
        Annotator.prototype.emitImportDeclaration = function (decl) {
            this.writeLeadingTrivia(decl);
            this.emit('import');
            var importPath = this.resolveModuleSpecifier(decl.moduleSpecifier);
            var importClause = decl.importClause;
            if (!importClause) {
                // import './foo';
                this.emit("'" + importPath + "';");
                this.addSourceMapping(decl);
                return true;
            }
            else if (importClause.name ||
                (importClause.namedBindings &&
                    importClause.namedBindings.kind === ts.SyntaxKind.NamedImports)) {
                this.visit(importClause);
                this.emit(" from '" + importPath + "';");
                this.addSourceMapping(decl);
                // importClause.name implies
                //   import a from ...;
                // namedBindings being NamedImports implies
                //   import {a as b} from ...;
                //
                // Both of these forms create a local name "a", which after TypeScript CommonJS compilation
                // will become some renamed variable like "module_1.default" or "module_1.a" (for default vs
                // named bindings, respectively).
                // tsickle references types in JSDoc. Because the module prefixes are not predictable, and
                // because TypeScript might remove imports entirely if they are only for types, the code below
                // inserts an artificial `const prefix = goog.forwardDeclare` call for the module, and then
                // registers all symbols from this import to be prefixed.
                if (!this.host.untyped) {
                    var symbols = [];
                    if (importClause.name) {
                        // import a from ...;
                        symbols = [{
                                name: rewriter_1.getIdentifierText(importClause.name),
                                sym: this.mustGetSymbolAtLocation(importClause.name),
                            }];
                    }
                    else {
                        // import {a as b} from ...;
                        if (!importClause.namedBindings ||
                            importClause.namedBindings.kind !== ts.SyntaxKind.NamedImports) {
                            throw new Error('unreached'); // Guaranteed by if check above.
                        }
                        symbols = this.getNamedSymbols(importClause.namedBindings.elements);
                    }
                    this.forwardDeclare(decl.moduleSpecifier, symbols, !!importClause.name);
                }
                return true;
            }
            else if (importClause.namedBindings &&
                importClause.namedBindings.kind === ts.SyntaxKind.NamespaceImport) {
                // import * as foo from ...;
                this.visit(importClause);
                this.emit(" from '" + importPath + "';");
                this.addSourceMapping(decl);
                // Introduce a goog.forwardDeclare for the module, so that if TypeScript does not emit the
                // module because it's only used in type positions, the JSDoc comments still reference a valid
                // Closure level symbol.
                var sym = this.typeChecker.getSymbolAtLocation(decl.moduleSpecifier);
                if (!sym) {
                    return true; // modules might not have a symbol if they are unused.
                }
                // forwardDeclare all symbols that can be imported from the module.
                var namedSyms = this.typeChecker.getExportsOfModule(sym).map(function (sym) { return ({ name: sym.name, sym: sym }); });
                this.forwardDeclare(decl.moduleSpecifier, namedSyms, false);
                return true;
            }
            else {
                this.errorUnimplementedKind(decl, 'unexpected kind of import');
                return false; // Use default processing.
            }
        };
        Annotator.prototype.getNamedSymbols = function (specifiers) {
            var _this = this;
            return specifiers.map(function (e) {
                return {
                    // e.name might be renaming symbol as in `export {Foo as Bar}`, where e.name would be 'Bar'
                    // and != sym.name. Store away the name so forwardDeclare below can emit the right name.
                    name: rewriter_1.getIdentifierText(e.name),
                    sym: _this.mustGetSymbolAtLocation(e.name),
                };
            });
        };
        /**
         * Emits a `goog.forwardDeclare` alias for each symbol from the given list.
         * @param specifier the import specifier, i.e. module path ("from '...'").
         */
        Annotator.prototype.forwardDeclare = function (specifier, exportedSymbols, isDefaultImport) {
            if (isDefaultImport === void 0) { isDefaultImport = false; }
            if (this.host.untyped)
                return;
            var importPath = this.resolveModuleSpecifier(specifier);
            var nsImport = es5processor.extractGoogNamespaceImport(importPath);
            var forwardDeclarePrefix = "tsickle_forward_declare_" + ++this.forwardDeclareCounter;
            var moduleNamespace = nsImport !== null ? nsImport : this.host.pathToModuleName(this.file.fileName, importPath);
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(specifier);
            // Scripts do not have a symbol. Scripts can still be imported, either as side effect imports or
            // with an empty import set ("{}"). TypeScript does not emit a runtime load for an import with
            // an empty list of symbols, but the import forces any global declarations from the library to
            // be visible, which is what users use this for. No symbols from the script need forward
            // declaration, so just return.
            if (!moduleSymbol)
                return;
            var exports = this.typeChecker.getExportsOfModule(moduleSymbol);
            // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.
            // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires
            // here would cause a change in load order, which is observable (and can lead to errors).
            // Instead, goog.forwardDeclare types, which allows using them in type annotations without
            // causing a load. See below for the exception to the rule.
            this.emit("\nconst " + forwardDeclarePrefix + " = goog.forwardDeclare(\"" + moduleNamespace + "\");");
            var hasValues = exports.some(function (e) { return (e.flags & ts.SymbolFlags.Value) !== 0; });
            if (!hasValues) {
                // Closure Compiler's toolchain will drop files that are never goog.require'd *before* type
                // checking (e.g. when using --closure_entry_point or similar tools). This causes errors
                // complaining about values not matching 'NoResolvedType', or modules not having a certain
                // member.
                // To fix, explicitly goog.require() modules that only export types. This should usually not
                // cause breakages due to load order (as no symbols are accessible from the module - though
                // contrived code could observe changes in side effects).
                // This is a heuristic - if the module exports some values, but those are never imported,
                // the file will still end up not being imported. Hopefully modules that export values are
                // imported for their value in some place.
                this.emit("\ngoog.require(\"" + moduleNamespace + "\"); // force type-only module to be loaded");
            }
            try {
                for (var exportedSymbols_1 = __values(exportedSymbols), exportedSymbols_1_1 = exportedSymbols_1.next(); !exportedSymbols_1_1.done; exportedSymbols_1_1 = exportedSymbols_1.next()) {
                    var exp = exportedSymbols_1_1.value;
                    if (exp.sym.flags & ts.SymbolFlags.Alias)
                        exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);
                    // goog: imports don't actually use the .default property that TS thinks they have.
                    var qualifiedName = nsImport && isDefaultImport ? forwardDeclarePrefix :
                        forwardDeclarePrefix + '.' + exp.sym.name;
                    this.symbolsToAliasedNames.set(exp.sym, qualifiedName);
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (exportedSymbols_1_1 && !exportedSymbols_1_1.done && (_a = exportedSymbols_1.return)) _a.call(exportedSymbols_1);
                }
                finally { if (e_11) throw e_11.error; }
            }
            var e_11, _a;
        };
        Annotator.prototype.visitClassDeclaration = function (classDecl) {
            this.addSourceMapping(classDecl);
            var oldDecoratorConverter = this.currentDecoratorConverter;
            this.currentDecoratorConverter =
                new decorator.DecoratorClassVisitor(this.typeChecker, this, classDecl, this.importedNames);
            var docTags = this.getJSDoc(classDecl) || [];
            if (util_1.hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {
                docTags.push({ tagName: 'abstract' });
            }
            if (!this.host.untyped) {
                this.maybeAddTemplateClause(docTags, classDecl);
                this.maybeAddHeritageClauses(docTags, classDecl);
            }
            this.emit('\n');
            if (docTags.length > 0)
                this.emit(jsdoc.toString(docTags));
            decorator.visitClassContentIncludingDecorators(classDecl, this, this.currentDecoratorConverter);
            this.emitTypeAnnotationsHelper(classDecl);
            this.currentDecoratorConverter = oldDecoratorConverter;
            return true;
        };
        Annotator.prototype.emitInterface = function (iface) {
            // If this symbol is both a type and a value, we cannot emit both into Closure's
            // single namespace.
            var sym = this.mustGetSymbolAtLocation(iface.name);
            if (sym.flags & ts.SymbolFlags.Value)
                return;
            var docTags = this.getJSDoc(iface) || [];
            docTags.push({ tagName: 'record' });
            if (!this.host.untyped) {
                this.maybeAddTemplateClause(docTags, iface);
                this.maybeAddHeritageClauses(docTags, iface);
            }
            this.emit('\n');
            this.emit(jsdoc.toString(docTags));
            if (util_1.hasModifierFlag(iface, ts.ModifierFlags.Export))
                this.emit('export ');
            var name = rewriter_1.getIdentifierText(iface.name);
            this.emit("function " + name + "() {}\n");
            this.emit("\n\nfunction " + name + "_tsickle_Closure_declarations() {\n");
            var memberNamespace = [name, 'prototype'];
            try {
                for (var _a = __values(iface.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var elem = _b.value;
                    var isOptional = elem.questionToken != null;
                    this.visitProperty(memberNamespace, elem, isOptional);
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_12) throw e_12.error; }
            }
            this.emit("}\n");
            var e_12, _c;
        };
        /**
         * emitTypeAnnotationsHelper produces a _tsickle_typeAnnotationsHelper() where
         * none existed in the original source. It's necessary in the case where
         * TypeScript syntax specifies there are additional properties on the class,
         * because to declare these in Closure you must declare these in a method
         * somewhere.
         */
        Annotator.prototype.emitTypeAnnotationsHelper = function (classDecl) {
            var _this = this;
            // Gather parameter properties from the constructor, if it exists.
            var ctors = [];
            var paramProps = [];
            var nonStaticProps = [];
            var staticProps = [];
            var abstractMethods = [];
            try {
                for (var _a = __values(classDecl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    if (member.kind === ts.SyntaxKind.Constructor) {
                        ctors.push(member);
                    }
                    else if (member.kind === ts.SyntaxKind.PropertyDeclaration) {
                        var prop = member;
                        var isStatic = util_1.hasModifierFlag(prop, ts.ModifierFlags.Static);
                        if (isStatic) {
                            staticProps.push(prop);
                        }
                        else {
                            nonStaticProps.push(prop);
                        }
                    }
                    else if (util_1.hasModifierFlag(member, ts.ModifierFlags.Abstract) &&
                        (member.kind === ts.SyntaxKind.MethodDeclaration ||
                            member.kind === ts.SyntaxKind.GetAccessor ||
                            member.kind === ts.SyntaxKind.SetAccessor)) {
                        abstractMethods.push(member);
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_13) throw e_13.error; }
            }
            if (ctors.length > 0) {
                var ctor = ctors[0];
                paramProps = ctor.parameters.filter(function (p) { return util_1.hasModifierFlag(p, FIELD_DECLARATION_MODIFIERS); });
            }
            if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&
                abstractMethods.length === 0 &&
                !(this.currentDecoratorConverter && this.currentDecoratorConverter.foundDecorators())) {
                // There are no members so we don't need to emit any type
                // annotations helper.
                return;
            }
            if (!classDecl.name)
                return;
            var className = rewriter_1.getIdentifierText(classDecl.name);
            this.emit("\n\nfunction " + className + "_tsickle_Closure_declarations() {\n");
            if (this.currentDecoratorConverter) {
                this.currentDecoratorConverter.emitMetadataTypeAnnotationsHelpers();
            }
            staticProps.forEach(function (p) { return _this.visitProperty([className], p); });
            var memberNamespace = [className, 'prototype'];
            nonStaticProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });
            paramProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });
            try {
                for (var abstractMethods_1 = __values(abstractMethods), abstractMethods_1_1 = abstractMethods_1.next(); !abstractMethods_1_1.done; abstractMethods_1_1 = abstractMethods_1.next()) {
                    var fnDecl = abstractMethods_1_1.value;
                    var name_4 = this.propertyName(fnDecl);
                    if (!name_4) {
                        this.error(fnDecl, 'anonymous abstract function');
                        continue;
                    }
                    var tags = decorators_1.hasExportingDecorator(fnDecl, this.typeChecker) ? [{ tagName: 'export' }] : [];
                    var paramNames = this.emitFunctionType([fnDecl], tags);
                    // memberNamespace because abstract methods cannot be static in TypeScript.
                    this.emit(memberNamespace.join('.') + "." + name_4 + " = function(" + paramNames.join(', ') + ") {};\n");
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (abstractMethods_1_1 && !abstractMethods_1_1.done && (_d = abstractMethods_1.return)) _d.call(abstractMethods_1);
                }
                finally { if (e_14) throw e_14.error; }
            }
            this.emit("}\n");
            var e_13, _c, e_14, _d;
        };
        Annotator.prototype.propertyName = function (prop) {
            if (!prop.name)
                return null;
            switch (prop.name.kind) {
                case ts.SyntaxKind.Identifier:
                    return rewriter_1.getIdentifierText(prop.name);
                case ts.SyntaxKind.StringLiteral:
                    // E.g. interface Foo { 'bar': number; }
                    // If 'bar' is a name that is not valid in Closure then there's nothing we can do.
                    var text = prop.name.text;
                    if (!isValidClosurePropertyName(text))
                        return null;
                    return text;
                default:
                    return null;
            }
        };
        /**
         * @param optional If true, property is optional (e.g. written "foo?: string").
         */
        Annotator.prototype.visitProperty = function (namespace, prop, optional) {
            if (optional === void 0) { optional = false; }
            var name = this.propertyName(prop);
            if (!name) {
                this.emit("/* TODO: handle strange member:\n" + this.escapeForComment(prop.getText()) + "\n*/\n");
                return;
            }
            var type = this.typeToClosure(prop);
            // When a property is optional, e.g.
            //   foo?: string;
            // Then the TypeScript type of the property is string|undefined, the
            // typeToClosure translation handles it correctly, and string|undefined is
            // how you write an optional property in Closure.
            //
            // But in the special case of an optional property with type any:
            //   foo?: any;
            // The TypeScript type of the property is just "any" (because any includes
            // undefined as well) so our default translation of the type is just "?".
            // To mark the property as optional in Closure it must have "|undefined",
            // so the Closure type must be ?|undefined.
            if (optional && type === '?')
                type += '|undefined';
            var tags = this.getJSDoc(prop) || [];
            tags.push({ tagName: 'type', type: type });
            if (decorators_1.hasExportingDecorator(prop, this.typeChecker)) {
                tags.push({ tagName: 'export' });
            }
            // Avoid printing annotations that can conflict with @type
            // This avoids Closure's error "type annotation incompatible with other annotations"
            this.emit(jsdoc.toString(tags, new Set(['param', 'return'])));
            namespace = namespace.concat([name]);
            this.emit(namespace.join('.') + ";\n");
        };
        Annotator.prototype.visitTypeAlias = function (node) {
            if (this.host.untyped)
                return;
            // If the type is also defined as a value, skip emitting it. Closure collapses type & value
            // namespaces, the two emits would conflict if tsickle emitted both.
            var sym = this.mustGetSymbolAtLocation(node.name);
            if (sym.flags & ts.SymbolFlags.Value)
                return;
            // Write a Closure typedef, which involves an unused "var" declaration.
            // Note: in the case of an export, we cannot emit a literal "var" because
            // TypeScript drops exports that are never assigned to (and Closure
            // requires us to not assign to typedef exports).  Instead, emit the
            // "exports.foo;" line directly in that case.
            this.newTypeTranslator(node).blacklistTypeParameters(this.symbolsToAliasedNames, node.typeParameters);
            var typeStr = this.typeToClosure(node, undefined, true /* resolveAlias */);
            this.emit("\n/** @typedef {" + typeStr + "} */\n");
            if (util_1.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                this.emit('exports.');
            }
            else {
                this.emit('var ');
            }
            this.emit(node.name.getText() + ";\n");
        };
        /**
         * getEnumType computes the Closure type of an enum, by iterating through the members
         * and gathering their types.
         */
        Annotator.prototype.getEnumType = function (enumDecl) {
            var hasNumber = false;
            var hasString = false;
            try {
                for (var _a = __values(enumDecl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    if (member.initializer) {
                        var type = this.typeChecker.getTypeAtLocation(member.initializer);
                        // Note: checking against 'NumberLike' instead of just 'Number' means this code
                        // handles both
                        //   MEMBER = 3,  // TypeFlags.NumberLiteral
                        // and
                        //   MEMBER = someFunction(),  // TypeFlags.Number
                        if (type.flags & ts.TypeFlags.NumberLike) {
                            hasNumber = true;
                        }
                        else if (type.flags & ts.TypeFlags.StringLike) {
                            hasString = true;
                        }
                        else {
                            // Enum contains something other than a string or a number; bail.
                            return '?';
                        }
                    }
                    else {
                        // Members without initializers default to numeric.
                        hasNumber = true;
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_15) throw e_15.error; }
            }
            if (hasNumber && hasString) {
                return '?'; // Closure's new type inference doesn't support enums of unions.
            }
            else if (hasNumber) {
                return 'number';
            }
            else if (hasString) {
                return 'string';
            }
            else {
                // Perhaps an empty enum?
                return '?';
            }
            var e_15, _c;
        };
        /**
         * Processes an EnumDeclaration into a Closure type. Always emits a Closure type, even in untyped
         * mode, as that should be harmless (it only ever uses the number type).
         */
        Annotator.prototype.processEnum = function (node) {
            // Emit the enum declaration, which looks like:
            //   /** @enum {number} */
            //   const Foo = {BAR: 0, BAZ: 1, ...};
            //   export {Foo};  // even if originally exported on one line.
            // This declares an enum type for Closure Compiler (and Closure JS users of this TS code).
            // Splitting the enum into declaration and export is required so that local references to the
            // type resolve ("@type {Foo}").
            this.emit('\n');
            var name = node.name.getText();
            var enumType = this.getEnumType(node);
            this.emit("/** @enum {" + enumType + "} */\n");
            this.emit("const " + name + ": DontTypeCheckMe = {");
            // Emit enum values ('BAR: 0,').
            var enumIndex = 0;
            try {
                for (var _a = __values(node.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    var memberName = member.name.getText();
                    // Emit any comments and leading whitespace on the enum value definition.
                    this.writeLeadingTrivia(member);
                    this.emit(memberName + ": ");
                    if (member.initializer) {
                        var enumConstValue = this.typeChecker.getConstantValue(member);
                        if (typeof enumConstValue === 'number') {
                            enumIndex = enumConstValue + 1;
                            this.emit(enumConstValue.toString());
                        }
                        else {
                            // Non-numeric enum value (string or an expression).
                            // Emit this initializer expression as-is.
                            // Note: if the member's initializer expression refers to another
                            // value within the enum (e.g. something like
                            //   enum Foo {
                            //     Field1,
                            //     Field2 = Field1 + something(),
                            //   }
                            // Then when we emit the initializer we produce invalid code because
                            // on the Closure side the reference to Field1 has to be namespaced,
                            // e.g. written "Foo.Field1 + something()".
                            // Hopefully this doesn't come up often -- if the enum instead has
                            // something like
                            //     Field2 = Field1 + 3,
                            // then it's still a constant expression and we inline the constant
                            // value in the above branch of this "if" statement.
                            this.visit(member.initializer);
                        }
                    }
                    else {
                        this.emit(enumIndex.toString());
                        enumIndex++;
                    }
                    this.emit(',');
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_16) throw e_16.error; }
            }
            this.emit('};\n');
            var isExported = util_1.hasModifierFlag(node, ts.ModifierFlags.Export);
            if (isExported)
                this.emit("export {" + name + "};\n");
            if (util_1.hasModifierFlag(node, ts.ModifierFlags.Const)) {
                // By TypeScript semantics, const enums disappear after TS compilation.
                // We still need to generate the runtime value above to make Closure Compiler's type system
                // happy and allow refering to enums from JS code, but we should at least not emit string
                // value mappings.
                return;
            }
            // Emit the reverse mapping of foo[foo.BAR] = 'BAR'; lines for number enums.
            if (enumType === 'number') {
                try {
                    for (var _d = __values(node.members), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var member = _e.value;
                        var memberName = member.name.getText();
                        this.emit(name + "[" + name + "." + memberName + "] = \"" + memberName + "\";\n");
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
            }
            var e_16, _c, e_17, _f;
        };
        return Annotator;
    }(ClosureRewriter));
    /** ExternsWriter generates Closure externs from TypeScript source. */
    var ExternsWriter = /** @class */ (function (_super) {
        __extends(ExternsWriter, _super);
        function ExternsWriter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ExternsWriter.prototype.process = function () {
            var _this = this;
            this.findExternRoots().forEach(function (node) { return _this.visit(node); });
            return this.getOutput();
        };
        ExternsWriter.prototype.newTypeTranslator = function (context) {
            var tt = _super.prototype.newTypeTranslator.call(this, context);
            tt.isForExterns = true;
            return tt;
        };
        ExternsWriter.prototype.findExternRoots = function () {
            if (util_1.isDtsFileName(this.file.fileName)) {
                return [this.file];
            }
            return this.file.statements.filter(function (stmt) { return util_1.hasModifierFlag(stmt, ts.ModifierFlags.Ambient); });
        };
        /** visit is the main entry point.  It generates externs from a ts.Node. */
        ExternsWriter.prototype.visit = function (node, namespace) {
            if (namespace === void 0) { namespace = []; }
            switch (node.kind) {
                case ts.SyntaxKind.SourceFile:
                    var sourceFile = node;
                    try {
                        for (var _a = __values(sourceFile.statements), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var stmt = _b.value;
                            this.visit(stmt, namespace);
                        }
                    }
                    catch (e_18_1) { e_18 = { error: e_18_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_18) throw e_18.error; }
                    }
                    break;
                case ts.SyntaxKind.ModuleDeclaration:
                    var decl = node;
                    switch (decl.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            // E.g. "declare namespace foo {"
                            var name_5 = rewriter_1.getIdentifierText(decl.name);
                            if (name_5 === 'global') {
                                // E.g. "declare global { ... }".  Reset to the outer namespace.
                                namespace = [];
                            }
                            else {
                                if (this.isFirstDeclaration(decl)) {
                                    this.emit('/** @const */\n');
                                    this.writeExternsVariable(name_5, namespace, '{}');
                                }
                                namespace = namespace.concat(name_5);
                            }
                            if (decl.body)
                                this.visit(decl.body, namespace);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            // E.g. "declare module 'foo' {" (note the quotes).
                            // We still want to emit externs for this module, but
                            // Closure doesn't really provide a mechanism for
                            // module-scoped externs.  For now, ignore the enclosing
                            // namespace (because this is declaring a top-level module)
                            // and emit into a fake namespace.
                            // Declare the top-level "tsickle_declare_module".
                            this.emit('/** @const */\n');
                            this.writeExternsVariable('tsickle_declare_module', [], '{}');
                            namespace = ['tsickle_declare_module'];
                            // Declare the inner "tsickle_declare_module.foo", if it's not
                            // declared already elsewhere.
                            var importName = decl.name.text;
                            this.emit("// Derived from: declare module \"" + importName + "\"\n");
                            // We also don't care about the actual name of the module ("foo"
                            // in the above example), except that we want it to not conflict.
                            importName = importName.replace(/_/, '__').replace(/[^A-Za-z]/g, '_');
                            if (this.isFirstDeclaration(decl)) {
                                this.emit('/** @const */\n');
                                this.writeExternsVariable(importName, namespace, '{}');
                            }
                            // Declare the contents inside the "tsickle_declare_module.foo".
                            if (decl.body)
                                this.visit(decl.body, namespace.concat(importName));
                            break;
                        default:
                            this.errorUnimplementedKind(decl.name, 'externs generation of namespace');
                    }
                    break;
                case ts.SyntaxKind.ModuleBlock:
                    var block = node;
                    try {
                        for (var _d = __values(block.statements), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var stmt = _e.value;
                            this.visit(stmt, namespace);
                        }
                    }
                    catch (e_19_1) { e_19 = { error: e_19_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_19) throw e_19.error; }
                    }
                    break;
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    var importEquals = node;
                    var localName = rewriter_1.getIdentifierText(importEquals.name);
                    if (localName === 'ng') {
                        this.emit("\n/* Skipping problematic import ng = ...; */\n");
                        break;
                    }
                    if (importEquals.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {
                        this.emit("\n/* TODO: import " + localName + " = require(...) */\n");
                        break;
                    }
                    var qn = rewriter_1.getEntityNameText(importEquals.moduleReference);
                    // @const so that Closure Compiler understands this is an alias.
                    if (namespace.length === 0)
                        this.emit('/** @const */\n');
                    this.writeExternsVariable(localName, namespace, qn);
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    this.writeExternsType(node, namespace);
                    break;
                case ts.SyntaxKind.FunctionDeclaration:
                    var fnDecl = node;
                    var name_6 = fnDecl.name;
                    if (!name_6) {
                        this.error(fnDecl, 'anonymous function in externs');
                        break;
                    }
                    // Gather up all overloads of this function.
                    var sym = this.mustGetSymbolAtLocation(name_6);
                    var decls = sym.declarations.filter(function (d) { return d.kind === ts.SyntaxKind.FunctionDeclaration; });
                    // Only emit the first declaration of each overloaded function.
                    if (fnDecl !== decls[0])
                        break;
                    var params = this.emitFunctionType(decls);
                    this.writeExternsFunction(name_6, params, namespace);
                    break;
                case ts.SyntaxKind.VariableStatement:
                    try {
                        for (var _g = __values(node.declarationList.declarations), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var decl_1 = _h.value;
                            this.writeExternsVariableDecl(decl_1, namespace);
                        }
                    }
                    catch (e_20_1) { e_20 = { error: e_20_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_j = _g.return)) _j.call(_g);
                        }
                        finally { if (e_20) throw e_20.error; }
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    this.writeExternsEnum(node, namespace);
                    break;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    this.writeExternsTypeAlias(node, namespace);
                    break;
                default:
                    this.emit("\n/* TODO: " + ts.SyntaxKind[node.kind] + " in " + namespace.join('.') + " */\n");
                    break;
            }
            var e_18, _c, e_19, _f, e_20, _j;
        };
        /**
         * isFirstDeclaration returns true if decl is the first declaration
         * of its symbol.  E.g. imagine
         *   interface Foo { x: number; }
         *   interface Foo { y: number; }
         * we only want to emit the "@record" for Foo on the first one.
         */
        ExternsWriter.prototype.isFirstDeclaration = function (decl) {
            if (!decl.name)
                return true;
            var sym = this.mustGetSymbolAtLocation(decl.name);
            if (!sym.declarations || sym.declarations.length < 2)
                return true;
            return decl === sym.declarations[0];
        };
        ExternsWriter.prototype.writeExternsType = function (decl, namespace) {
            var name = decl.name;
            if (!name) {
                this.error(decl, 'anonymous type in externs');
                return;
            }
            var typeName = namespace.concat([name.getText()]).join('.');
            if (exports.closureExternsBlacklist.indexOf(typeName) >= 0)
                return;
            if (this.isFirstDeclaration(decl)) {
                var paramNames = [];
                var jsdocTags = [];
                var writeJsDoc = true;
                this.maybeAddHeritageClauses(jsdocTags, decl);
                if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
                    jsdocTags.push({ tagName: 'constructor' });
                    jsdocTags.push({ tagName: 'struct' });
                    var ctors = decl
                        .members.filter(function (m) { return m.kind === ts.SyntaxKind.Constructor; });
                    if (ctors.length) {
                        writeJsDoc = false;
                        var firstCtor = ctors[0];
                        var ctorTags = [{ tagName: 'constructor' }, { tagName: 'struct' }];
                        if (ctors.length > 1) {
                            paramNames = this.emitFunctionType(ctors, ctorTags);
                        }
                        else {
                            paramNames = this.emitFunctionType([firstCtor], ctorTags);
                        }
                    }
                }
                else {
                    jsdocTags.push({ tagName: 'record' });
                    jsdocTags.push({ tagName: 'struct' });
                }
                if (writeJsDoc)
                    this.emit(jsdoc.toString(jsdocTags));
                this.writeExternsFunction(name, paramNames, namespace);
            }
            // Process everything except (MethodSignature|MethodDeclaration|Constructor)
            var methods = new Map();
            try {
                for (var _a = __values(decl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    switch (member.kind) {
                        case ts.SyntaxKind.PropertySignature:
                        case ts.SyntaxKind.PropertyDeclaration:
                            var prop = member;
                            if (prop.name.kind === ts.SyntaxKind.Identifier) {
                                this.emitJSDocType(prop);
                                if (util_1.hasModifierFlag(prop, ts.ModifierFlags.Static)) {
                                    this.emit("\n" + typeName + "." + prop.name.getText() + ";\n");
                                }
                                else {
                                    this.emit("\n" + typeName + ".prototype." + prop.name.getText() + ";\n");
                                }
                                continue;
                            }
                            // TODO: For now property names other than Identifiers are not handled; e.g.
                            //    interface Foo { "123bar": number }
                            break;
                        case ts.SyntaxKind.MethodSignature:
                        case ts.SyntaxKind.MethodDeclaration:
                            var method = member;
                            var isStatic = util_1.hasModifierFlag(method, ts.ModifierFlags.Static);
                            var methodSignature = method.name.getText() + "$$$" + (isStatic ? 'static' : 'instance');
                            if (methods.has(methodSignature)) {
                                methods.get(methodSignature).push(method);
                            }
                            else {
                                methods.set(methodSignature, [method]);
                            }
                            continue;
                        case ts.SyntaxKind.Constructor:
                            continue; // Handled above.
                        default:
                            // Members can include things like index signatures, for e.g.
                            //   interface Foo { [key: string]: number; }
                            // For now, just skip it.
                            break;
                    }
                    // If we get here, the member wasn't handled in the switch statement.
                    var memberName = namespace;
                    if (member.name) {
                        memberName = memberName.concat([member.name.getText()]);
                    }
                    this.emit("\n/* TODO: " + ts.SyntaxKind[member.kind] + ": " + memberName.join('.') + " */\n");
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_21) throw e_21.error; }
            }
            try {
                // Handle method declarations/signatures separately, since we need to deal with overloads.
                for (var _d = __values(Array.from(methods.values())), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var methodVariants = _e.value;
                    var firstMethodVariant = methodVariants[0];
                    var parameterNames = void 0;
                    if (methodVariants.length > 1) {
                        parameterNames = this.emitFunctionType(methodVariants);
                    }
                    else {
                        parameterNames = this.emitFunctionType([firstMethodVariant]);
                    }
                    var methodNamespace = namespace.concat([name.getText()]);
                    // If the method is static, don't add the prototype.
                    if (!util_1.hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {
                        methodNamespace.push('prototype');
                    }
                    this.writeExternsFunction(firstMethodVariant.name, parameterNames, methodNamespace);
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_22) throw e_22.error; }
            }
            var e_21, _c, e_22, _f;
        };
        ExternsWriter.prototype.writeExternsVariableDecl = function (decl, namespace) {
            if (decl.name.kind === ts.SyntaxKind.Identifier) {
                var name_7 = rewriter_1.getIdentifierText(decl.name);
                if (exports.closureExternsBlacklist.indexOf(name_7) >= 0)
                    return;
                this.emitJSDocType(decl);
                this.emit('\n');
                this.writeExternsVariable(name_7, namespace);
            }
            else {
                this.errorUnimplementedKind(decl.name, 'externs for variable');
            }
        };
        ExternsWriter.prototype.writeExternsVariable = function (name, namespace, value) {
            var qualifiedName = namespace.concat([name]).join('.');
            if (namespace.length === 0)
                this.emit("var ");
            this.emit(qualifiedName);
            if (value)
                this.emit(" = " + value);
            this.emit(';\n');
        };
        ExternsWriter.prototype.writeExternsFunction = function (name, params, namespace) {
            var paramsStr = params.join(', ');
            if (namespace.length > 0) {
                var fqn = namespace.join('.');
                if (name.kind === ts.SyntaxKind.Identifier) {
                    fqn += '.'; // computed names include [ ] in their getText() representation.
                }
                fqn += name.getText();
                this.emit(fqn + " = function(" + paramsStr + ") {};\n");
            }
            else {
                if (name.kind !== ts.SyntaxKind.Identifier) {
                    this.error(name, 'Non-namespaced computed name in externs');
                }
                this.emit("function " + name.getText() + "(" + paramsStr + ") {}\n");
            }
        };
        ExternsWriter.prototype.writeExternsEnum = function (decl, namespace) {
            var name = rewriter_1.getIdentifierText(decl.name);
            this.emit('\n/** @const */\n');
            this.writeExternsVariable(name, namespace, '{}');
            namespace = namespace.concat([name]);
            try {
                for (var _a = __values(decl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    var memberName = void 0;
                    switch (member.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            memberName = rewriter_1.getIdentifierText(member.name);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            var text = member.name.text;
                            if (isValidClosurePropertyName(text))
                                memberName = text;
                            break;
                        default:
                            break;
                    }
                    if (!memberName) {
                        this.emit("\n/* TODO: " + ts.SyntaxKind[member.name.kind] + ": " + member.name.getText() + " */\n");
                        continue;
                    }
                    this.emit('/** @const {number} */\n');
                    this.writeExternsVariable(memberName, namespace);
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_23) throw e_23.error; }
            }
            var e_23, _c;
        };
        ExternsWriter.prototype.writeExternsTypeAlias = function (decl, namespace) {
            var typeStr = this.typeToClosure(decl, undefined, true /* resolveAlias */);
            this.emit("\n/** @typedef {" + typeStr + "} */\n");
            this.writeExternsVariable(rewriter_1.getIdentifierText(decl.name), namespace);
        };
        return ExternsWriter;
    }(ClosureRewriter));
    function isPolymerBehaviorPropertyInCallExpression(pa) {
        var parentParent = pa.parent && pa.parent.parent;
        if (pa.name.kind !== ts.SyntaxKind.Identifier ||
            pa.name.text !== 'behaviors' || !pa.parent || !pa.parent.parent ||
            pa.parent.parent.kind !== ts.SyntaxKind.CallExpression) {
            return false;
        }
        var expr = parentParent.expression;
        return expr.kind === ts.SyntaxKind.Identifier && expr.text === 'Polymer';
    }
    function annotate(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {
        return new Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper).annotate();
    }
    exports.annotate = annotate;
    function writeExterns(typeChecker, file, host) {
        return new ExternsWriter(typeChecker, file, host).process();
    }
    exports.writeExterns = writeExterns;
    /** Concatenate all generated externs definitions together into a string. */
    function getGeneratedExterns(externs) {
        var allExterns = exports.EXTERNS_HEADER;
        try {
            for (var _a = __values(Object.keys(externs)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var fileName = _b.value;
                allExterns += "// externs from " + fileName + ":\n";
                allExterns += externs[fileName];
            }
        }
        catch (e_24_1) { e_24 = { error: e_24_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_24) throw e_24.error; }
        }
        return allExterns;
        var e_24, _c;
    }
    exports.getGeneratedExterns = getGeneratedExterns;
    function mergeEmitResults(emitResults) {
        var diagnostics = [];
        var emitSkipped = true;
        var emittedFiles = [];
        var externs = {};
        var modulesManifest = new modules_manifest_1.ModulesManifest();
        try {
            for (var emitResults_1 = __values(emitResults), emitResults_1_1 = emitResults_1.next(); !emitResults_1_1.done; emitResults_1_1 = emitResults_1.next()) {
                var er = emitResults_1_1.value;
                diagnostics.push.apply(diagnostics, __spread(er.diagnostics));
                emitSkipped = emitSkipped || er.emitSkipped;
                emittedFiles.push.apply(emittedFiles, __spread(er.emittedFiles));
                Object.assign(externs, er.externs);
                modulesManifest.addManifest(er.modulesManifest);
            }
        }
        catch (e_25_1) { e_25 = { error: e_25_1 }; }
        finally {
            try {
                if (emitResults_1_1 && !emitResults_1_1.done && (_a = emitResults_1.return)) _a.call(emitResults_1);
            }
            finally { if (e_25) throw e_25.error; }
        }
        return { diagnostics: diagnostics, emitSkipped: emitSkipped, emittedFiles: emittedFiles, externs: externs, modulesManifest: modulesManifest };
        var e_25, _a;
    }
    exports.mergeEmitResults = mergeEmitResults;
    function emitWithTsickle(program, host, tsHost, tsOptions, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        if (customTransformers === void 0) { customTransformers = {}; }
        var tsickleDiagnostics = [];
        var typeChecker = program.getTypeChecker();
        var tsickleSourceTransformers = [];
        if (host.transformTypesToClosure) {
            // Note: tsickle.annotate can also lower decorators in the same run.
            tsickleSourceTransformers.push(transformer_sourcemap_1.createTransformerFromSourceMap(function (sourceFile, sourceMapper) {
                var _a = annotate(typeChecker, sourceFile, host, tsHost, tsOptions, sourceMapper), output = _a.output, diagnostics = _a.diagnostics;
                tsickleDiagnostics.push.apply(tsickleDiagnostics, __spread(diagnostics));
                return output;
            }));
            // Only add @suppress {checkTypes} comments when also adding type annotations.
            tsickleSourceTransformers.push(fileoverview_comment_transformer_1.transformFileoverviewComment);
            tsickleSourceTransformers.push(class_decorator_downlevel_transformer_1.classDecoratorDownlevelTransformer(typeChecker, tsickleDiagnostics));
        }
        else if (host.transformDecorators) {
            tsickleSourceTransformers.push(transformer_sourcemap_1.createTransformerFromSourceMap(function (sourceFile, sourceMapper) {
                var _a = decorator.convertDecorators(typeChecker, sourceFile, sourceMapper), output = _a.output, diagnostics = _a.diagnostics;
                tsickleDiagnostics.push.apply(tsickleDiagnostics, __spread(diagnostics));
                return output;
            }));
            tsickleSourceTransformers.push(class_decorator_downlevel_transformer_1.classDecoratorDownlevelTransformer(typeChecker, tsickleDiagnostics));
        }
        // // For debugging: transformer that just emits the same text.
        // beforeTsTransformers.push(createTransformer(host, typeChecker, (sourceFile, sourceMapper) => {
        //   sourceMapper.addMapping(sourceFile, {position: 0, line: 0, column: 0}, {position: 0, line: 0,
        //   column: 0}, sourceFile.text.length); return sourceFile.text;
        // }));
        var tsickleTransformers = transformer_util_1.createCustomTransformers({ before: tsickleSourceTransformers });
        var tsTransformers = {
            before: __spread((customTransformers.beforeTsickle || []), (tsickleTransformers.before || []).map(function (tf) { return skipTransformForSourceFileIfNeeded(host, tf); }), (customTransformers.beforeTs || [])),
            after: __spread((customTransformers.afterTs || []), (tsickleTransformers.after || []).map(function (tf) { return skipTransformForSourceFileIfNeeded(host, tf); }))
        };
        var writeFileDelegate = writeFile || tsHost.writeFile.bind(tsHost);
        var modulesManifest = new modules_manifest_1.ModulesManifest();
        var writeFileImpl = function (fileName, content, writeByteOrderMark, onError, sourceFiles) {
            if (path.extname(fileName) !== '.map') {
                if (tsOptions.inlineSourceMap) {
                    content = combineInlineSourceMaps(program, fileName, content);
                }
                else {
                    content = source_map_utils_1.removeInlineSourceMap(content);
                }
                content = es5processor.convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content);
            }
            else {
                content = combineSourceMaps(program, fileName, content);
            }
            if (host.addDtsClutzAliases && util_1.isDtsFileName(fileName) && sourceFiles) {
                content = addClutzAliases(fileName, content, sourceFiles, typeChecker, host);
            }
            writeFileDelegate(fileName, content, writeByteOrderMark, onError, sourceFiles);
        };
        var _a = program.emit(targetSourceFile, writeFileImpl, cancellationToken, emitOnlyDtsFiles, tsTransformers), tsDiagnostics = _a.diagnostics, emitSkipped = _a.emitSkipped, emittedFiles = _a.emittedFiles;
        var externs = {};
        if (host.transformTypesToClosure) {
            var sourceFiles = targetSourceFile ? [targetSourceFile] : program.getSourceFiles();
            sourceFiles.forEach(function (sf) {
                if (util_1.isDtsFileName(sf.fileName) && host.shouldSkipTsickleProcessing(sf.fileName)) {
                    return;
                }
                var _a = writeExterns(typeChecker, sf, host), output = _a.output, diagnostics = _a.diagnostics;
                if (output) {
                    externs[sf.fileName] = output;
                }
                if (diagnostics) {
                    tsickleDiagnostics.push.apply(tsickleDiagnostics, __spread(diagnostics));
                }
            });
        }
        // All diagnostics (including warnings) are treated as errors.
        // If the host decides to ignore warnings, just discard them.
        // Warnings include stuff like "don't use @type in your jsdoc"; tsickle
        // warns and then fixes up the code to be Closure-compatible anyway.
        tsickleDiagnostics = tsickleDiagnostics.filter(function (d) { return d.category === ts.DiagnosticCategory.Error ||
            !host.shouldIgnoreWarningsForPath(d.file.fileName); });
        return {
            modulesManifest: modulesManifest,
            emitSkipped: emitSkipped,
            emittedFiles: emittedFiles || [],
            diagnostics: __spread(tsDiagnostics, tsickleDiagnostics),
            externs: externs
        };
    }
    exports.emitWithTsickle = emitWithTsickle;
    function addClutzAliases(fileName, dtsFileContent, sourceFiles, typeChecker, host) {
        var reexports = [];
        try {
            for (var sourceFiles_1 = __values(sourceFiles), sourceFiles_1_1 = sourceFiles_1.next(); !sourceFiles_1_1.done; sourceFiles_1_1 = sourceFiles_1.next()) {
                var sf = sourceFiles_1_1.value;
                var moduleSymbol = typeChecker.getSymbolAtLocation(sf);
                var moduleExports = moduleSymbol && typeChecker.getExportsOfModule(moduleSymbol);
                if (!moduleExports) {
                    return dtsFileContent;
                }
                // pathToModuleName expects the file name to end in .js
                var jsFileName = fileName.replace('.d.ts', '.js');
                var moduleName = host.pathToModuleName('', jsFileName);
                var clutzModuleName = moduleName.replace(/\./g, '$');
                try {
                    // moduleExports is a ts.Map<ts.Symbol> which is an es6 Map, but has a
                    // different type for no reason
                    for (var moduleExports_1 = __values(moduleExports), moduleExports_1_1 = moduleExports_1.next(); !moduleExports_1_1.done; moduleExports_1_1 = moduleExports_1.next()) {
                        var symbol = moduleExports_1_1.value;
                        // Want to alias the symbol to match what clutz would produce, so clutz .d.ts's
                        // can reference symbols from typescript .d.ts's. See examples at:
                        // https://github.com/angular/clutz/tree/master/src/test/java/com/google/javascript/clutz
                        var clutzSymbolName = 'module$contents$' + clutzModuleName + '_' + symbol.name;
                        var _a = getGenericTypeParameters(symbol), params = _a.params, paramsWithContraint = _a.paramsWithContraint;
                        if (symbol.flags & ts.SymbolFlags.Class) {
                            // classes need special care to match clutz, which seperates class types into a
                            // type for the static properties and a type for the instance properties
                            reexports.push("type " + clutzSymbolName + paramsWithContraint + " = " + symbol.name + params + ";");
                            reexports.push("const " + clutzSymbolName + ": typeof " + symbol.name + ";");
                            reexports.push("type " + clutzSymbolName + "_Instance" + paramsWithContraint + " = " + symbol.name + params + ";");
                            reexports.push("const " + clutzSymbolName + "_Instance: typeof " + symbol.name + ";");
                            continue;
                        }
                        if (symbol.flags & ts.SymbolFlags.Type) {
                            reexports.push("type " + clutzSymbolName + paramsWithContraint + " = " + symbol.name + params + ";");
                        }
                        if (symbol.flags & ts.SymbolFlags.Value) {
                            reexports.push("const " + clutzSymbolName + ": typeof " + symbol.name + ";");
                        }
                    }
                }
                catch (e_26_1) { e_26 = { error: e_26_1 }; }
                finally {
                    try {
                        if (moduleExports_1_1 && !moduleExports_1_1.done && (_b = moduleExports_1.return)) _b.call(moduleExports_1);
                    }
                    finally { if (e_26) throw e_26.error; }
                }
            }
        }
        catch (e_27_1) { e_27 = { error: e_27_1 }; }
        finally {
            try {
                if (sourceFiles_1_1 && !sourceFiles_1_1.done && (_c = sourceFiles_1.return)) _c.call(sourceFiles_1);
            }
            finally { if (e_27) throw e_27.error; }
        }
        if (reexports.length) {
            dtsFileContent += 'declare global {\n';
            dtsFileContent += "\tnamespace \u0CA0_\u0CA0.clutz {\n";
            try {
                for (var reexports_1 = __values(reexports), reexports_1_1 = reexports_1.next(); !reexports_1_1.done; reexports_1_1 = reexports_1.next()) {
                    var reexport = reexports_1_1.value;
                    dtsFileContent += "\t\t" + reexport + "\n";
                }
            }
            catch (e_28_1) { e_28 = { error: e_28_1 }; }
            finally {
                try {
                    if (reexports_1_1 && !reexports_1_1.done && (_d = reexports_1.return)) _d.call(reexports_1);
                }
                finally { if (e_28) throw e_28.error; }
            }
            dtsFileContent += '\t}\n}\n';
        }
        return dtsFileContent;
        var e_27, _c, e_26, _b, e_28, _d;
    }
    /**
     * Returns 2 strings specifying the generic type arguments for the symbol.  The constrained params
     * include any `T extends foo` arguments, the regular params are just a list of the type symbols,
     * since we need the constraints on the LHS of the alias declaration, but can't have them on the
     * RHS.
     */
    function getGenericTypeParameters(symbol) {
        if (!symbol.declarations) {
            return { params: '', paramsWithContraint: '' };
        }
        // All declarations have to have matching generic types, so we're safe just looking at
        // the first one.
        if (!symbol.declarations[0]) {
            return { params: '', paramsWithContraint: '' };
        }
        var declaration = symbol.declarations[0];
        if ([
            ts.SyntaxKind.FunctionDeclaration, ts.SyntaxKind.ConstructorKeyword,
            ts.SyntaxKind.ClassDeclaration, ts.SyntaxKind.InterfaceDeclaration,
            ts.SyntaxKind.TypeAliasDeclaration
        ].indexOf(declaration.kind) === -1) {
            return { params: '', paramsWithContraint: '' };
        }
        var declarationWithTypeParameters = declaration;
        if (!declarationWithTypeParameters.typeParameters) {
            return { params: '', paramsWithContraint: '' };
        }
        var paramList = [];
        var constrainedParamList = [];
        try {
            for (var _a = __values(declarationWithTypeParameters.typeParameters), _b = _a.next(); !_b.done; _b = _a.next()) {
                var param = _b.value;
                var constrainedParam = param.name.getText();
                if (param.constraint) {
                    constrainedParam += " extends " + param.constraint.getText();
                }
                if (param.default) {
                    constrainedParam += " = " + param.default.getText();
                }
                constrainedParamList.push(constrainedParam);
                paramList.push(param.name.getText());
            }
        }
        catch (e_29_1) { e_29 = { error: e_29_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_29) throw e_29.error; }
        }
        var params = "<" + paramList.join(',') + ">";
        var paramsWithContraint = "<" + constrainedParamList.join(',') + ">";
        return { params: params, paramsWithContraint: paramsWithContraint };
        var e_29, _c;
    }
    function skipTransformForSourceFileIfNeeded(host, delegateFactory) {
        return function (context) {
            var delegate = delegateFactory(context);
            return function (sourceFile) {
                if (host.shouldSkipTsickleProcessing(sourceFile.fileName)) {
                    return sourceFile;
                }
                return delegate(sourceFile);
            };
        };
    }
    function combineInlineSourceMaps(program, filePath, compiledJsWithInlineSourceMap) {
        if (util_1.isDtsFileName(filePath)) {
            return compiledJsWithInlineSourceMap;
        }
        var sourceMapJson = source_map_utils_1.extractInlineSourceMap(compiledJsWithInlineSourceMap);
        compiledJsWithInlineSourceMap = source_map_utils_1.removeInlineSourceMap(compiledJsWithInlineSourceMap);
        var composedSourceMap = combineSourceMaps(program, filePath, sourceMapJson);
        return source_map_utils_1.setInlineSourceMap(compiledJsWithInlineSourceMap, composedSourceMap);
    }
    function combineSourceMaps(program, filePath, tscSourceMapText) {
        var tscSourceMap = source_map_utils_1.parseSourceMap(tscSourceMapText);
        if (tscSourceMap.sourcesContent) {
            // strip incoming sourcemaps from the sources in the sourcemap
            // to reduce the size of the sourcemap.
            tscSourceMap.sourcesContent = tscSourceMap.sourcesContent.map(function (content) {
                if (source_map_utils_1.containsInlineSourceMap(content)) {
                    content = source_map_utils_1.removeInlineSourceMap(content);
                }
                return content;
            });
        }
        var fileDir = path.dirname(filePath);
        var tscSourceMapGenerator;
        try {
            for (var _a = __values(tscSourceMap.sources), _b = _a.next(); !_b.done; _b = _a.next()) {
                var sourceFileName = _b.value;
                var sourceFile = program.getSourceFile(path.resolve(fileDir, sourceFileName));
                if (!sourceFile || !source_map_utils_1.containsInlineSourceMap(sourceFile.text)) {
                    continue;
                }
                var preexistingSourceMapText = source_map_utils_1.extractInlineSourceMap(sourceFile.text);
                if (!tscSourceMapGenerator) {
                    tscSourceMapGenerator = source_map_1.SourceMapGenerator.fromSourceMap(new source_map_1.SourceMapConsumer(tscSourceMap));
                }
                tscSourceMapGenerator.applySourceMap(new source_map_1.SourceMapConsumer(source_map_utils_1.parseSourceMap(preexistingSourceMapText, sourceFileName)));
            }
        }
        catch (e_30_1) { e_30 = { error: e_30_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_30) throw e_30.error; }
        }
        return tscSourceMapGenerator ? tscSourceMapGenerator.toString() : tscSourceMapText;
        var e_30, _c;
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHNpY2tsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90c2lja2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVILDJCQUE2QjtJQUM3Qix5Q0FBK0U7SUFFL0UsMkdBQTJGO0lBQzNGLDJEQUFtRDtJQUNuRCxxREFBbUQ7SUFDbkQsdURBQStDO0lBQy9DLGlHQUFnRjtJQUNoRix5Q0FBaUM7SUFDakMsaUVBQW1EO0lBQ25ELGlEQUF3RjtJQUN4RixpRUFBNEs7SUFDNUssMkVBQXVFO0lBQ3ZFLGlFQUE0RDtJQUM1RCw0REFBb0Q7SUFDcEQsMkNBQW1DO0lBQ25DLHlDQUFzRDtJQUV0RCxpRUFBNEQ7SUFBM0MsNkNBQUEsZUFBZSxDQUFBO0lBd0JoQzs7OztPQUlHO0lBQ1UsUUFBQSxjQUFjLEdBQUcsMkdBSzdCLENBQUM7SUFFRjs7O09BR0c7SUFDUSxRQUFBLHVCQUF1QixHQUFhO1FBQzdDLFNBQVM7UUFDVCxRQUFRO1FBQ1IsUUFBUTtRQUNSLGdFQUFnRTtRQUNoRSx1RUFBdUU7UUFDdkUsa0VBQWtFO1FBQ2xFLHFFQUFxRTtRQUNyRSxtRUFBbUU7UUFDbkUsd0VBQXdFO1FBQ3hFLGdDQUFnQztRQUNoQyxrQkFBa0I7UUFDbEIsUUFBUTtRQUNSLG1CQUFtQjtLQUNwQixDQUFDO0lBRUYsMkJBQWtDLEtBQXNCO1FBQ3RELE1BQU0sQ0FBQyxLQUFLO2FBQ1AsR0FBRyxDQUFDLFVBQUMsQ0FBQztZQUNMLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDNUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ1gsR0FBRyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFB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LE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZDLElBQUkscUJBQW1ELENBQUM7O1lBQ3hELEdBQUcsQ0FBQyxDQUF5QixJQUFBLEtBQUEsU0FBQSxZQUFZLENBQUMsT0FBTyxDQUFBLGdCQUFBO2dCQUE1QyxJQUFNLGNBQWMsV0FBQTtnQkFDdkIsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUNoRixFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsSUFBSSxDQUFDLDBDQUF1QixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzdELFFBQVEsQ0FBQztnQkFDWCxDQUFDO2dCQUNELElBQU0sd0JBQXdCLEdBQUcseUNBQXNCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6RSxFQUFFLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztvQkFDM0IscUJBQXFCLEdBQUcsK0JBQWtCLENBQUMsYUFBYSxDQUFDLElBQUksOEJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFDaEcsQ0FBQztnQkFDRCxxQkFBcUIsQ0FBQyxjQUFjLENBQ2hDLElBQUksOEJBQWlCLENBQUMsaUNBQWMsQ0FBQyx3QkFBd0IsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdEY7Ozs7Ozs7OztRQUNELE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDOztJQUNyRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtSYXdTb3VyY2VNYXAsIFNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3J9IGZyb20gJ3NvdXJjZS1tYXAnO1xuXG5pbXBvcnQge2NsYXNzRGVjb3JhdG9yRG93bmxldmVsVHJhbnNmb3JtZXJ9IGZyb20gJy4vY2xhc3NfZGVjb3JhdG9yX2Rvd25sZXZlbF90cmFuc2Zvcm1lcic7XG5pbXBvcnQgKiBhcyBkZWNvcmF0b3IgZnJvbSAnLi9kZWNvcmF0b3ItYW5ub3RhdG9yJztcbmltcG9ydCB7aGFzRXhwb3J0aW5nRGVjb3JhdG9yfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0ICogYXMgZXM1cHJvY2Vzc29yIGZyb20gJy4vZXM1cHJvY2Vzc29yJztcbmltcG9ydCB7dHJhbnNmb3JtRmlsZW92ZXJ2aWV3Q29tbWVudH0gZnJvbSAnLi9maWxlb3ZlcnZpZXdfY29tbWVudF90cmFuc2Zvcm1lcic7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7TW9kdWxlc01hbmlmZXN0fSBmcm9tICcuL21vZHVsZXNfbWFuaWZlc3QnO1xuaW1wb3J0IHtnZXRFbnRpdHlOYW1lVGV4dCwgZ2V0SWRlbnRpZmllclRleHQsIFJld3JpdGVyLCB1bmVzY2FwZU5hbWV9IGZyb20gJy4vcmV3cml0ZXInO1xuaW1wb3J0IHtjb250YWluc0lubGluZVNvdXJjZU1hcCwgZXh0cmFjdElubGluZVNvdXJjZU1hcCwgcGFyc2VTb3VyY2VNYXAsIHJlbW92ZUlubGluZVNvdXJjZU1hcCwgc2V0SW5saW5lU291cmNlTWFwLCBTb3VyY2VNYXBwZXIsIFNvdXJjZVBvc2l0aW9ufSBmcm9tICcuL3NvdXJjZV9tYXBfdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVUcmFuc2Zvcm1lckZyb21Tb3VyY2VNYXB9IGZyb20gJy4vdHJhbnNmb3JtZXJfc291cmNlbWFwJztcbmltcG9ydCB7Y3JlYXRlQ3VzdG9tVHJhbnNmb3JtZXJzfSBmcm9tICcuL3RyYW5zZm9ybWVyX3V0aWwnO1xuaW1wb3J0ICogYXMgdHlwZVRyYW5zbGF0b3IgZnJvbSAnLi90eXBlLXRyYW5zbGF0b3InO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAnLi90eXBlc2NyaXB0JztcbmltcG9ydCB7aGFzTW9kaWZpZXJGbGFnLCBpc0R0c0ZpbGVOYW1lfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQge0ZpbGVNYXAsIE1vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcblxuZXhwb3J0IGludGVyZmFjZSBBbm5vdGF0b3JIb3N0IHtcbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkIGEgZnVuY3Rpb24gdGhhdCBsb2dzIGFuIGludGVybmFsIHdhcm5pbmcuXG4gICAqIFRoZXNlIHdhcm5pbmdzIGFyZSBub3QgYWN0aW9uYWJsZSBieSBhbiBlbmQgdXNlciBhbmQgc2hvdWxkIGJlIGhpZGRlblxuICAgKiBieSBkZWZhdWx0LlxuICAgKi9cbiAgbG9nV2FybmluZz86ICh3YXJuaW5nOiB0cy5EaWFnbm9zdGljKSA9PiB2b2lkO1xuICBwYXRoVG9Nb2R1bGVOYW1lOiAoY29udGV4dDogc3RyaW5nLCBpbXBvcnRQYXRoOiBzdHJpbmcpID0+IHN0cmluZztcbiAgLyoqXG4gICAqIElmIHRydWUsIGNvbnZlcnQgZXZlcnkgdHlwZSB0byB0aGUgQ2xvc3VyZSB7P30gdHlwZSwgd2hpY2ggbWVhbnNcbiAgICogXCJkb24ndCBjaGVjayB0eXBlc1wiLlxuICAgKi9cbiAgdW50eXBlZD86IGJvb2xlYW47XG4gIC8qKiBJZiBwcm92aWRlZCwgYSBzZXQgb2YgcGF0aHMgd2hvc2UgdHlwZXMgc2hvdWxkIGFsd2F5cyBnZW5lcmF0ZSBhcyB7P30uICovXG4gIHR5cGVCbGFja0xpc3RQYXRocz86IFNldDxzdHJpbmc+O1xuICAvKipcbiAgICogQ29udmVydCBzaG9ydGhhbmQgXCIvaW5kZXhcIiBpbXBvcnRzIHRvIGZ1bGwgcGF0aCAoaW5jbHVkZSB0aGUgXCIvaW5kZXhcIikuXG4gICAqIEFubm90YXRpb24gd2lsbCBiZSBzbG93ZXIgYmVjYXVzZSBldmVyeSBpbXBvcnQgbXVzdCBiZSByZXNvbHZlZC5cbiAgICovXG4gIGNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGhlIGhlYWRlciB0byBiZSB1c2VkIGluIGdlbmVyYXRlZCBleHRlcm5zLiAgVGhpcyBpcyBub3QgaW5jbHVkZWQgaW4gdGhlXG4gKiBvdXRwdXQgb2YgYW5ub3RhdGUoKSBiZWNhdXNlIGFubm90YXRlKCkgd29ya3Mgb25lIGZpbGUgYXQgYSB0aW1lLCBhbmRcbiAqIHR5cGljYWxseSB5b3UgY3JlYXRlIG9uZSBleHRlcm5zIGZpbGUgZnJvbSB0aGUgZW50aXJlIGNvbXBpbGF0aW9uIHVuaXQuXG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFUk5TX0hFQURFUiA9IGAvKipcbiAqIEBleHRlcm5zXG4gKiBAc3VwcHJlc3Mge2R1cGxpY2F0ZSxjaGVja1R5cGVzfVxuICovXG4vLyBOT1RFOiBnZW5lcmF0ZWQgYnkgdHNpY2tsZSwgZG8gbm90IGVkaXQuXG5gO1xuXG4vKipcbiAqIFN5bWJvbHMgdGhhdCBhcmUgYWxyZWFkeSBkZWNsYXJlZCBhcyBleHRlcm5zIGluIENsb3N1cmUsIHRoYXQgc2hvdWxkXG4gKiBiZSBhdm9pZGVkIGJ5IHRzaWNrbGUncyBcImRlY2xhcmUgLi4uXCIgPT4gZXh0ZXJucy5qcyBjb252ZXJzaW9uLlxuICovXG5leHBvcnQgbGV0IGNsb3N1cmVFeHRlcm5zQmxhY2tsaXN0OiBzdHJpbmdbXSA9IFtcbiAgJ2V4cG9ydHMnLFxuICAnZ2xvYmFsJyxcbiAgJ21vZHVsZScsXG4gIC8vIEVycm9yQ29uc3RydWN0b3IgaXMgdGhlIGludGVyZmFjZSBvZiB0aGUgRXJyb3Igb2JqZWN0IGl0c2VsZi5cbiAgLy8gdHNpY2tsZSBkZXRlY3RzIHRoYXQgdGhpcyBpcyBwYXJ0IG9mIHRoZSBUeXBlU2NyaXB0IHN0YW5kYXJkIGxpYnJhcnlcbiAgLy8gYW5kIGFzc3VtZXMgaXQncyBwYXJ0IG9mIHRoZSBDbG9zdXJlIHN0YW5kYXJkIGxpYnJhcnksIGJ1dCB0aGlzXG4gIC8vIGFzc3VtcHRpb24gaXMgd3JvbmcgZm9yIEVycm9yQ29uc3RydWN0b3IuICBUbyBwcm9wZXJseSBoYW5kbGUgdGhpc1xuICAvLyB3ZSdkIHNvbWVob3cgbmVlZCB0byBtYXAgbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBFcnJvckNvbnN0cnVjdG9yXG4gIC8vIGludGVyZmFjZSBpbnRvIHByb3BlcnRpZXMgb24gQ2xvc3VyZSdzIEVycm9yIG9iamVjdCwgYnV0IGZvciBub3cgaXQnc1xuICAvLyBzaW1wbGVyIHRvIGp1c3QgYmxhY2tsaXN0IGl0LlxuICAnRXJyb3JDb25zdHJ1Y3RvcicsXG4gICdTeW1ib2wnLFxuICAnV29ya2VyR2xvYmFsU2NvcGUnLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERpYWdub3N0aWNzKGRpYWdzOiB0cy5EaWFnbm9zdGljW10pOiBzdHJpbmcge1xuICByZXR1cm4gZGlhZ3NcbiAgICAgIC5tYXAoKGQpID0+IHtcbiAgICAgICAgbGV0IHJlcyA9IHRzLkRpYWdub3N0aWNDYXRlZ29yeVtkLmNhdGVnb3J5XTtcbiAgICAgICAgaWYgKGQuZmlsZSkge1xuICAgICAgICAgIHJlcyArPSAnIGF0ICcgKyBkLmZpbGUuZmlsZU5hbWUgKyAnOic7XG4gICAgICAgICAgaWYgKGQuc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsaW5lLCBjaGFyYWN0ZXJ9ID0gZC5maWxlLmdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uKGQuc3RhcnQpO1xuICAgICAgICAgICAgcmVzICs9IChsaW5lICsgMSkgKyAnOicgKyAoY2hhcmFjdGVyICsgMSkgKyAnOic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyArPSAnICcgKyB0cy5mbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGQubWVzc2FnZVRleHQsICdcXG4nKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pXG4gICAgICAuam9pbignXFxuJyk7XG59XG5cbi8qKiBAcmV0dXJuIHRydWUgaWYgbm9kZSBoYXMgdGhlIHNwZWNpZmllZCBtb2RpZmllciBmbGFnIHNldC4gKi9cbmZ1bmN0aW9uIGlzQW1iaWVudChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gIGxldCBjdXJyZW50OiB0cy5Ob2RlfHVuZGVmaW5lZCA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgaWYgKGhhc01vZGlmaWVyRmxhZyhjdXJyZW50LCB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFR5cGVTY3JpcHQgYWxsb3dzIHlvdSB0byB3cml0ZSBpZGVudGlmaWVycyBxdW90ZWQsIGxpa2U6XG4gKiAgIGludGVyZmFjZSBGb28ge1xuICogICAgICdiYXInOiBzdHJpbmc7XG4gKiAgICAgJ2NvbXBsZXggbmFtZSc6IHN0cmluZztcbiAqICAgfVxuICogICBGb28uYmFyOyAgLy8gb2tcbiAqICAgRm9vWydiYXInXSAgLy8gb2tcbiAqICAgRm9vWydjb21wbGV4IG5hbWUnXSAgLy8gb2tcbiAqXG4gKiBJbiBDbG9zdXJlLWxhbmQsIHdlIHdhbnQgaWRlbnRpZnkgdGhhdCB0aGUgbGVnYWwgbmFtZSAnYmFyJyBjYW4gYmVjb21lIGFuXG4gKiBvcmRpbmFyeSBmaWVsZCwgYnV0IHdlIG5lZWQgdG8gc2tpcCBzdHJpbmdzIGxpa2UgJ2NvbXBsZXggbmFtZScuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBJbiBsb2NhbCBleHBlcmltZW50YXRpb24sIGl0IGFwcGVhcnMgdGhhdCByZXNlcnZlZCB3b3JkcyBsaWtlICd2YXInIGFuZFxuICAvLyAnaWYnIGFyZSBsZWdhbCBKUyBhbmQgc3RpbGwgYWNjZXB0ZWQgYnkgQ2xvc3VyZS5cbiAgcmV0dXJuIC9eW2EtekEtWl9dW2EtekEtWjAtOV9dKiQvLnRlc3QobmFtZSk7XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBDbG9zdXJlIG5hbWUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIsIHNwZWNpYWwtY2FzaW5nIGRlc3RydWN0dXJpbmcuICovXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJOYW1lKHBhcmFtOiB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbiwgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gIHN3aXRjaCAocGFyYW0ubmFtZS5raW5kKSB7XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICBsZXQgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KHBhcmFtLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICAvLyBUeXBlU2NyaXB0IGFsbG93cyBwYXJhbWV0ZXJzIG5hbWVkIFwiYXJndW1lbnRzXCIsIGJ1dCBDbG9zdXJlXG4gICAgICAvLyBkaXNhbGxvd3MgdGhpcywgZXZlbiBpbiBleHRlcm5zLlxuICAgICAgaWYgKG5hbWUgPT09ICdhcmd1bWVudHMnKSBuYW1lID0gJ3RzaWNrbGVfYXJndW1lbnRzJztcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIGNhc2UgdHMuU3ludGF4S2luZC5BcnJheUJpbmRpbmdQYXR0ZXJuOlxuICAgIGNhc2UgdHMuU3ludGF4S2luZC5PYmplY3RCaW5kaW5nUGF0dGVybjpcbiAgICAgIC8vIENsb3N1cmUgY3Jhc2hlcyBpZiB5b3UgcHV0IGEgYmluZGluZyBwYXR0ZXJuIGluIHRoZSBleHRlcm5zLlxuICAgICAgLy8gQXZvaWQgdGhpcyBieSBqdXN0IGdlbmVyYXRpbmcgYW4gdW51c2VkIG5hbWU7IHRoZSBuYW1lIGlzXG4gICAgICAvLyBpZ25vcmVkIGFueXdheS5cbiAgICAgIHJldHVybiBgX18ke2luZGV4fWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFRoZSBhYm92ZSBsaXN0IG9mIGtpbmRzIGlzIGV4aGF1c3RpdmUuICBwYXJhbS5uYW1lIGlzICduZXZlcicgYXQgdGhpcyBwb2ludC5cbiAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtLm5hbWUgYXMgdHMuTm9kZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGZ1bmN0aW9uIHBhcmFtZXRlciBraW5kOiAke3RzLlN5bnRheEtpbmRbcGFyYW1OYW1lLmtpbmRdfWApO1xuICB9XG59XG5cbi8qKiBGbGFncyB0aGF0IGRlY2xhcmUgYSBmaWVsZCBvZiB0aGUgc2FtZSBuYW1lIGlmIHNldCBvbiBhIGN0b3IgcGFyYW1ldGVyLiAqL1xuY29uc3QgRklFTERfREVDTEFSQVRJT05fTU9ESUZJRVJTOiB0cy5Nb2RpZmllckZsYWdzID0gdHMuTW9kaWZpZXJGbGFncy5Qcml2YXRlIHxcbiAgICB0cy5Nb2RpZmllckZsYWdzLlByb3RlY3RlZCB8IHRzLk1vZGlmaWVyRmxhZ3MuUHVibGljIHwgdHMuTW9kaWZpZXJGbGFncy5SZWFkb25seTtcblxuLyoqXG4gKiBBIHN5bWJvbCBjb21iaW5lZCB3aXRoIGl0cyBuYW1lIGluIHRoZSBsb2NhbCBmaWxlLiBTeW1ib2xzIGNhbiBiZSByZW5hbWVkIG9uIGltcG9ydCBvciBleHBvcnRcbiAqIChgaW1wb3J0IHtGb28gYXMgQmFyfWApLlxuICovXG5pbnRlcmZhY2UgTmFtZWRTeW1ib2wge1xuICAvKiogVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHN5bWJvbCAobmFtZWQgYEJhcmAgaW4gdGhlIGV4YW1wbGUgYWJvdmUpLiAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKiBUaGUgc3ltYm9sIChuYW1lZCBgRm9vYCBpbiB0aGUgZXhhbXBsZSBhYm92ZSkuICovXG4gIHN5bTogdHMuU3ltYm9sO1xufVxuXG4vKipcbiAqIEEgUmV3cml0ZXIgc3ViY2xhc3MgdGhhdCBhZGRzIFRzaWNrbGUtc3BlY2lmaWMgKENsb3N1cmUgdHJhbnNsYXRpb24pIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogT25lIFJld3JpdGVyIHN1YmNsYXNzIG1hbmFnZXMgLnRzID0+IC50cytDbG9zdXJlIHRyYW5zbGF0aW9uLlxuICogQW5vdGhlciBSZXdyaXRlciBzdWJjbGFzcyBtYW5hZ2VzIC50cyA9PiBleHRlcm5zIHRyYW5zbGF0aW9uLlxuICovXG5jbGFzcyBDbG9zdXJlUmV3cml0ZXIgZXh0ZW5kcyBSZXdyaXRlciB7XG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgb2YgYWxpYXNlcyBmb3Igc3ltYm9scyBpbiB0aGUgY3VycmVudCBmaWxlLCB1c2VkIHdoZW4gZW1pdHRpbmcgdHlwZXMuXG4gICAqIFR5cGVTY3JpcHQgZW1pdHMgaW1wb3J0ZWQgc3ltYm9scyB3aXRoIHVucHJlZGljdGFibGUgcHJlZml4ZXMuIFRvIGdlbmVyYXRlIGNvcnJlY3QgdHlwZVxuICAgKiBhbm5vdGF0aW9ucywgdHNpY2tsZSBjcmVhdGVzIGl0cyBvd24gYWxpYXNlcyBmb3IgdHlwZXMsIGFuZCByZWdpc3RlcnMgdGhlbSBpbiB0aGlzIG1hcCAoc2VlXG4gICAqIGBlbWl0SW1wb3J0RGVjbGFyYXRpb25gIGFuZCBgZm9yd2FyZERlY2xhcmUoKWAgYmVsb3cpLiBUaGUgYWxpYXNlcyBhcmUgdGhlbiB1c2VkIHdoZW4gZW1pdHRpbmdcbiAgICogdHlwZXMuXG4gICAqL1xuICBzeW1ib2xzVG9BbGlhc2VkTmFtZXMgPSBuZXcgTWFwPHRzLlN5bWJvbCwgc3RyaW5nPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJvdGVjdGVkIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgZmlsZTogdHMuU291cmNlRmlsZSwgcHJvdGVjdGVkIGhvc3Q6IEFubm90YXRvckhvc3QsXG4gICAgICBzb3VyY2VNYXBwZXI/OiBTb3VyY2VNYXBwZXIpIHtcbiAgICBzdXBlcihmaWxlLCBzb3VyY2VNYXBwZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHMuU3ltYm9sIGF0IGEgbG9jYXRpb24gb3IgdGhyb3cuXG4gICAqIFRoZSBUeXBlU2NyaXB0IEFQSSBjYW4gcmV0dXJuIHVuZGVmaW5lZCB3aGVuIGZldGNoaW5nIGEgc3ltYm9sLCBidXRcbiAgICogaW4gbWFueSBjb250ZXh0cyB3ZSBrbm93IGl0IHdvbid0IChlLmcuIG91ciBpbnB1dCBpcyBhbHJlYWR5IHR5cGUtY2hlY2tlZCkuXG4gICAqL1xuICBtdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihub2RlOiB0cy5Ob2RlKTogdHMuU3ltYm9sIHtcbiAgICBjb25zdCBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG4gICAgaWYgKCFzeW0pIHRocm93IG5ldyBFcnJvcignbm8gc3ltYm9sJyk7XG4gICAgcmV0dXJuIHN5bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGVtaXR0bmcgdGhlIGpzZG9jIGZvciBtZXRob2RzLCBpbmNsdWRpbmcgb3ZlcmxvYWRzLlxuICAgKiBJZiBvdmVybG9hZGVkLCBtZXJnZXMgdGhlIHNpZ25hdHVyZXMgaW4gdGhlIGxpc3Qgb2YgU2lnbmF0dXJlRGVjbGFyYXRpb25zIGludG8gYSBzaW5nbGUganNkb2MuXG4gICAqIC0gVG90YWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgd2lsbCBiZSB0aGUgbWF4aW11bSBjb3VudCBmb3VuZCBhY3Jvc3MgYWxsIHZhcmlhbnRzLlxuICAgKiAtIERpZmZlcmVudCBuYW1lcyBhdCB0aGUgc2FtZSBwYXJhbWV0ZXIgaW5kZXggd2lsbCBiZSBqb2luZWQgd2l0aCBcIl9vcl9cIlxuICAgKiAtIFZhcmlhYmxlIGFyZ3MgKC4uLnR5cGVbXSBpbiBUeXBlU2NyaXB0KSB3aWxsIGJlIG91dHB1dCBhcyBcIi4uLnR5cGVcIixcbiAgICogICAgZXhjZXB0IGlmIGZvdW5kIGF0IHRoZSBzYW1lIGluZGV4IGFzIGFub3RoZXIgYXJndW1lbnQuXG4gICAqIEBwYXJhbSAgZm5EZWNscyBQYXNzID4gMSBkZWNsYXJhdGlvbiBmb3Igb3ZlcmxvYWRzIG9mIHNhbWUgbmFtZVxuICAgKiBAcmV0dXJuIFRoZSBsaXN0IG9mIHBhcmFtZXRlciBuYW1lcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGVtaXQgdGhlIGFjdHVhbFxuICAgKiAgICBmdW5jdGlvbiBzdGF0ZW1lbnQ7IGZvciBvdmVybG9hZHMsIG5hbWUgd2lsbCBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgKi9cbiAgZW1pdEZ1bmN0aW9uVHlwZShmbkRlY2xzOiB0cy5TaWduYXR1cmVEZWNsYXJhdGlvbltdLCBleHRyYVRhZ3M6IGpzZG9jLlRhZ1tdID0gW10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuICAgIGNvbnN0IG5ld0RvYyA9IGV4dHJhVGFncztcbiAgICBjb25zdCBsZW5zID0gZm5EZWNscy5tYXAoZm5EZWNsID0+IGZuRGVjbC5wYXJhbWV0ZXJzLmxlbmd0aCk7XG4gICAgY29uc3QgbWluQXJnc0NvdW50ID0gTWF0aC5taW4oLi4ubGVucyk7XG4gICAgY29uc3QgbWF4QXJnc0NvdW50ID0gTWF0aC5tYXgoLi4ubGVucyk7XG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IGZuRGVjbHMuZmluZChkID0+IGQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3RvcikgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBGb3IgZWFjaCBwYXJhbWV0ZXIgaW5kZXggaSwgcGFyYW1UYWdzW2ldIGlzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnNcbiAgICAvLyB0aGF0IGNhbiBiZSBmb3VuZCBhdCBpbmRleCBpLiAgRS5nLlxuICAgIC8vICAgIGZ1bmN0aW9uIGZvbyh4OiBzdHJpbmcpXG4gICAgLy8gICAgZnVuY3Rpb24gZm9vKHk6IG51bWJlciwgejogc3RyaW5nKVxuICAgIC8vIHRoZW4gcGFyYW1UYWdzWzBdID0gW2luZm8gYWJvdXQgeCwgaW5mbyBhYm91dCB5XS5cbiAgICBjb25zdCBwYXJhbVRhZ3M6IGpzZG9jLlRhZ1tdW10gPSBbXTtcbiAgICBjb25zdCByZXR1cm5UYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBmbkRlY2wgb2YgZm5EZWNscykge1xuICAgICAgLy8gQ29uc3RydWN0IHRoZSBKU0RvYyBjb21tZW50IGJ5IHJlYWRpbmcgdGhlIGV4aXN0aW5nIEpTRG9jLCBpZlxuICAgICAgLy8gYW55LCBhbmQgbWVyZ2luZyBpdCB3aXRoIHRoZSBrbm93biB0eXBlcyBvZiB0aGUgZnVuY3Rpb25cbiAgICAgIC8vIHBhcmFtZXRlcnMgYW5kIHJldHVybiB0eXBlLlxuICAgICAgY29uc3QgZG9jVGFncyA9IHRoaXMuZ2V0SlNEb2MoZm5EZWNsKSB8fCBbXTtcblxuICAgICAgLy8gQ29weSBhbGwgdGhlIHRhZ3Mgb3RoZXIgdGhhbiBAcGFyYW0vQHJldHVybiBpbnRvIHRoZSBuZXdcbiAgICAgIC8vIEpTRG9jIHdpdGhvdXQgYW55IGNoYW5nZTsgQHBhcmFtL0ByZXR1cm4gYXJlIGhhbmRsZWQgc3BlY2lhbGx5LlxuICAgICAgLy8gVE9ETzogdGhlcmUgbWF5IGJlIHByb2JsZW1zIGlmIGFuIGFubm90YXRpb24gZG9lc24ndCBhcHBseSB0byBhbGwgb3ZlcmxvYWRzO1xuICAgICAgLy8gaXMgaXQgd29ydGggY2hlY2tpbmcgZm9yIHRoaXMgYW5kIGVycm9yaW5nP1xuICAgICAgZm9yIChjb25zdCB0YWcgb2YgZG9jVGFncykge1xuICAgICAgICBpZiAodGFnLnRhZ05hbWUgPT09ICdwYXJhbScgfHwgdGFnLnRhZ05hbWUgPT09ICdyZXR1cm4nKSBjb250aW51ZTtcbiAgICAgICAgbmV3RG9jLnB1c2godGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIEBhYnN0cmFjdCBvbiBcImFic3RyYWN0XCIgZGVjbGFyYXRpb25zLlxuICAgICAgaWYgKGhhc01vZGlmaWVyRmxhZyhmbkRlY2wsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpKSB7XG4gICAgICAgIG5ld0RvYy5wdXNoKHt0YWdOYW1lOiAnYWJzdHJhY3QnfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhbnkgQHRlbXBsYXRlIHRhZ3MuXG4gICAgICAvLyBNdWx0aXBsZSBkZWNsYXJhdGlvbnMgd2l0aCB0aGUgc2FtZSB0ZW1wbGF0ZSB2YXJpYWJsZSBuYW1lcyBzaG91bGQgd29yazpcbiAgICAgIC8vIHRoZSBkZWNsYXJhdGlvbnMgZ2V0IHR1cm5lZCBpbnRvIHVuaW9uIHR5cGVzLCBhbmQgQ2xvc3VyZSBDb21waWxlciB3aWxsIG5lZWRcbiAgICAgIC8vIHRvIGZpbmQgYSB1bmlvbiB3aGVyZSBhbGwgdHlwZSBhcmd1bWVudHMgYXJlIHNhdGlzZmllZC5cbiAgICAgIGlmIChmbkRlY2wudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0cCBvZiBmbkRlY2wudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICB0eXBlUGFyYW1ldGVyTmFtZXMuYWRkKGdldElkZW50aWZpZXJUZXh0KHRwLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgdGhlIHBhcmFtZXRlcnMgaW50byBhIHNpbmdsZSBsaXN0IG9mIG1lcmdlZCBuYW1lcyBhbmQgbGlzdCBvZiB0eXBlc1xuICAgICAgY29uc3Qgc2lnID0gdHlwZUNoZWNrZXIuZ2V0U2lnbmF0dXJlRnJvbURlY2xhcmF0aW9uKGZuRGVjbCk7XG4gICAgICBpZiAoIXNpZykgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke2ZuRGVjbC5uYW1lfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWcuZGVjbGFyYXRpb24ucGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJhbU5vZGUgPSBzaWcuZGVjbGFyYXRpb24ucGFyYW1ldGVyc1tpXTtcblxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0UGFyYW1ldGVyTmFtZShwYXJhbU5vZGUsIGkpO1xuICAgICAgICBjb25zdCBpc1RoaXNQYXJhbSA9IG5hbWUgPT09ICd0aGlzJztcblxuICAgICAgICBjb25zdCBuZXdUYWc6IGpzZG9jLlRhZyA9IHtcbiAgICAgICAgICB0YWdOYW1lOiBpc1RoaXNQYXJhbSA/ICd0aGlzJyA6ICdwYXJhbScsXG4gICAgICAgICAgb3B0aW9uYWw6IHBhcmFtTm9kZS5pbml0aWFsaXplciAhPT0gdW5kZWZpbmVkIHx8IHBhcmFtTm9kZS5xdWVzdGlvblRva2VuICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgcGFyYW1ldGVyTmFtZTogaXNUaGlzUGFyYW0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24ocGFyYW1Ob2RlKTtcbiAgICAgICAgaWYgKHBhcmFtTm9kZS5kb3REb3REb3RUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VGFnLnJlc3RQYXJhbSA9IHRydWU7XG4gICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCB5b3Ugd3JpdGUgXCIuLi54OiBudW1iZXJbXVwiLCBidXQgaW4gQ2xvc3VyZVxuICAgICAgICAgIC8vIHlvdSBkb24ndCB3cml0ZSB0aGUgYXJyYXk6IFwiQHBhcmFtIHsuLi5udW1iZXJ9IHhcIi4gIFVud3JhcFxuICAgICAgICAgIC8vIHRoZSBBcnJheTw+IHdyYXBwZXIuXG4gICAgICAgICAgY29uc3QgdHlwZVJlZiA9IHR5cGUgYXMgdHMuVHlwZVJlZmVyZW5jZTtcbiAgICAgICAgICBpZiAoIXR5cGVSZWYudHlwZUFyZ3VtZW50cykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlc3QgcGFyYW0nKTtcbiAgICAgICAgICB0eXBlID0gdHlwZVJlZi50eXBlQXJndW1lbnRzIVswXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdUYWcudHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShmbkRlY2wsIHR5cGUpO1xuXG4gICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHBhcmFtZXRlck5hbWUsIHRleHR9IG9mIGRvY1RhZ3MpIHtcbiAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3BhcmFtJyAmJiBwYXJhbWV0ZXJOYW1lID09PSBuZXdUYWcucGFyYW1ldGVyTmFtZSkge1xuICAgICAgICAgICAgbmV3VGFnLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1UYWdzW2ldKSBwYXJhbVRhZ3MucHVzaChbXSk7XG4gICAgICAgIHBhcmFtVGFnc1tpXS5wdXNoKG5ld1RhZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0eXBlLlxuICAgICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJldFR5cGUgPSB0eXBlQ2hlY2tlci5nZXRSZXR1cm5UeXBlT2ZTaWduYXR1cmUoc2lnKTtcbiAgICAgICAgY29uc3QgcmV0VHlwZVN0cmluZzogc3RyaW5nID0gdGhpcy50eXBlVG9DbG9zdXJlKGZuRGVjbCwgcmV0VHlwZSk7XG4gICAgICAgIGxldCByZXR1cm5Eb2M6IHN0cmluZ3x1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHRleHR9IG9mIGRvY1RhZ3MpIHtcbiAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3JldHVybicpIHtcbiAgICAgICAgICAgIHJldHVybkRvYyA9IHRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVGFncy5wdXNoKHtcbiAgICAgICAgICB0YWdOYW1lOiAncmV0dXJuJyxcbiAgICAgICAgICB0eXBlOiByZXRUeXBlU3RyaW5nLFxuICAgICAgICAgIHRleHQ6IHJldHVybkRvYyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJOYW1lcy5zaXplID4gMCkge1xuICAgICAgbmV3RG9jLnB1c2goe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6IEFycmF5LmZyb20odHlwZVBhcmFtZXRlck5hbWVzLnZhbHVlcygpKS5qb2luKCcsICcpfSk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgdGhlIEpTRG9jIHRhZ3MgZm9yIGVhY2ggb3ZlcmxvYWRlZCBwYXJhbWV0ZXIuXG4gICAgLy8gRW5zdXJlIGVhY2ggcGFyYW1ldGVyIGhhcyBhIHVuaXF1ZSBuYW1lOyB0aGUgbWVyZ2luZyBwcm9jZXNzIGNhbiBvdGhlcndpc2VcbiAgICAvLyBhY2NpZGVudGFsbHkgZ2VuZXJhdGUgdGhlIHNhbWUgcGFyYW1ldGVyIG5hbWUgdHdpY2UuXG4gICAgY29uc3QgcGFyYW1OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRPcHRpb25hbCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXJnc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtVGFnID0ganNkb2MubWVyZ2UocGFyYW1UYWdzW2ldKTtcbiAgICAgIGlmIChwYXJhbU5hbWVzLmhhcyhwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKSkge1xuICAgICAgICBwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lICs9IGkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHBhcmFtTmFtZXMuYWRkKHBhcmFtVGFnLnBhcmFtZXRlck5hbWUpO1xuICAgICAgLy8gSWYgdGhlIHRhZyBpcyBvcHRpb25hbCwgbWFyayBwYXJhbWV0ZXJzIGZvbGxvd2luZyBvcHRpb25hbCBhcyBvcHRpb25hbCxcbiAgICAgIC8vIGV2ZW4gaWYgdGhleSBhcmUgbm90LCBzaW5jZSBDbG9zdXJlIHJlc3RyaWN0cyB0aGlzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMjMxNFxuICAgICAgaWYgKCFwYXJhbVRhZy5yZXN0UGFyYW0gJiYgKHBhcmFtVGFnLm9wdGlvbmFsIHx8IGZvdW5kT3B0aW9uYWwgfHwgaSA+PSBtaW5BcmdzQ291bnQpKSB7XG4gICAgICAgIGZvdW5kT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICBwYXJhbVRhZy5vcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBuZXdEb2MucHVzaChwYXJhbVRhZyk7XG4gICAgICBpZiAocGFyYW1UYWcucmVzdFBhcmFtKSB7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzIGFmdGVyIGEgcmVzdCBwYXJhbS5cbiAgICAgICAgLy8gSnVzdCBkdW1wIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgdGhlIEpTRG9jIHRhZ3MgZm9yIGVhY2ggb3ZlcmxvYWRlZCByZXR1cm4uXG4gICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdEb2MucHVzaChqc2RvYy5tZXJnZShyZXR1cm5UYWdzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdcXG4nICsganNkb2MudG9TdHJpbmcobmV3RG9jKSk7XG4gICAgcmV0dXJuIG5ld0RvYy5maWx0ZXIodCA9PiB0LnRhZ05hbWUgPT09ICdwYXJhbScpLm1hcCh0ID0+IHQucGFyYW1ldGVyTmFtZSEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBleGlzdGluZyBjb21tZW50LlxuICAgKi9cbiAgZ2V0SlNEb2Mobm9kZTogdHMuTm9kZSk6IGpzZG9jLlRhZ1tdfG51bGwge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldEZ1bGxUZXh0KCk7XG4gICAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyh0ZXh0LCAwKTtcblxuICAgIGlmICghY29tbWVudHMgfHwgY29tbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIFdlIG5lZWQgdG8gc2VhcmNoIGJhY2t3YXJkcyBmb3IgdGhlIGZpcnN0IEpTRG9jIGNvbW1lbnQgdG8gYXZvaWQgaWdub3Jpbmcgc3VjaCB3aGVuIGFub3RoZXJcbiAgICAvLyBjb2RlLWxldmVsIGNvbW1lbnQgaXMgYmV0d2VlbiB0aGF0IGNvbW1lbnQgYW5kIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiAoc2VlXG4gICAgLy8gdGVzdGZpbGVzL2RvY19wYXJhbXMgZm9yIGFuIGV4YW1wbGUpLlxuICAgIGxldCBkb2NSZWxhdGl2ZVBvcyA9IDA7XG4gICAgbGV0IHBhcnNlZDoganNkb2MuUGFyc2VkSlNEb2NDb21tZW50fG51bGwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSBjb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3Qge3BvcywgZW5kfSA9IGNvbW1lbnRzW2ldO1xuICAgICAgLy8gZW5kIGlzIHJlbGF0aXZlIHdpdGhpbiBub2RlLmdldEZ1bGxUZXh0KCksIGFkZCBnZXRGdWxsU3RhcnQgdG8gb2J0YWluIGNvb3JkaW5hdGVzIHRoYXQgYXJlXG4gICAgICAvLyBjb21wYXJhYmxlIHRvIG5vZGUgcG9zaXRpb25zLlxuICAgICAgY29uc3QgZG9jUmVsYXRpdmVFbmQgPSBlbmQgKyBub2RlLmdldEZ1bGxTdGFydCgpO1xuICAgICAgaWYgKGRvY1JlbGF0aXZlRW5kIDw9IHRoaXMuZmlsZS5nZXRTdGFydCgpICYmXG4gICAgICAgICAgdGhpcy5maWxlLnRleHQuc3Vic3RyaW5nKGRvY1JlbGF0aXZlRW5kKS5zdGFydHNXaXRoKCdcXG5cXG4nKSkge1xuICAgICAgICAvLyBUaGlzIGNvbW1lbnQgaXMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIGFuZCB0aGVyZSdzIGFuIGVtcHR5IGxpbmUgYmV0d2VlbiB0aGVcbiAgICAgICAgLy8gY29tbWVudCBhbmQgdGhpcyBub2RlLCBpdCdzIGEgXCJkZXRhY2hlZCBjb21tZW50XCIuIFRoYXQgbWVhbnMgd2Ugc2hvdWxkIHRyZWF0IGl0IGFzIGFcbiAgICAgICAgLy8gZmlsZS1sZXZlbCBjb21tZW50LCBub3QgYXR0YWNoZWQgdG8gdGhpcyBjb2RlIG5vZGUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21tZW50ID0gdGV4dC5zdWJzdHJpbmcocG9zLCBlbmQpO1xuICAgICAgcGFyc2VkID0ganNkb2MucGFyc2UoY29tbWVudCk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGRvY1JlbGF0aXZlUG9zID0gbm9kZS5nZXRGdWxsU3RhcnQoKSArIHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKHBhcnNlZC53YXJuaW5ncykge1xuICAgICAgY29uc3Qgc3RhcnQgPSBkb2NSZWxhdGl2ZVBvcztcbiAgICAgIHRoaXMuZGlhZ25vc3RpY3MucHVzaCh7XG4gICAgICAgIGZpbGU6IHRoaXMuZmlsZSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGxlbmd0aDogbm9kZS5nZXRTdGFydCgpIC0gc3RhcnQsXG4gICAgICAgIG1lc3NhZ2VUZXh0OiBwYXJzZWQud2FybmluZ3Muam9pbignXFxuJyksXG4gICAgICAgIGNhdGVnb3J5OiB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyxcbiAgICAgICAgY29kZTogMCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkLnRhZ3M7XG4gIH1cblxuICBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGRvY1RhZ3M6IGpzZG9jLlRhZ1tdLCBkZWNsOiBIYXNUeXBlUGFyYW1ldGVycykge1xuICAgIGlmICghZGVjbC50eXBlUGFyYW1ldGVycykgcmV0dXJuO1xuICAgIC8vIENsb3N1cmUgZG9lcyBub3Qgc3VwcG9ydCB0ZW1wbGF0ZSBjb25zdHJhaW50cyAoVCBleHRlbmRzIFgpLlxuICAgIGRvY1RhZ3MucHVzaCh7XG4gICAgICB0YWdOYW1lOiAndGVtcGxhdGUnLFxuICAgICAgdGV4dDogZGVjbC50eXBlUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIC5tYXAodHAgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHRwLmNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdcXG4vLyB1bnN1cHBvcnRlZDogdGVtcGxhdGUgY29uc3RyYWludHMuJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SWRlbnRpZmllclRleHQodHAubmFtZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKVxuICAgIH0pO1xuICB9XG5cbiAgbWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMoXG4gICAgICBkb2NUYWdzOiBqc2RvYy5UYWdbXSwgZGVjbDogdHMuQ2xhc3NMaWtlRGVjbGFyYXRpb258dHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcbiAgICBpZiAoIWRlY2wuaGVyaXRhZ2VDbGF1c2VzKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBoZXJpdGFnZSBvZiBkZWNsLmhlcml0YWdlQ2xhdXNlcyEpIHtcbiAgICAgIGlmICghaGVyaXRhZ2UudHlwZXMpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgaXNDbGFzcyA9IGRlY2wua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uO1xuICAgICAgaWYgKGlzQ2xhc3MgJiYgaGVyaXRhZ2UudG9rZW4gIT09IHRzLlN5bnRheEtpbmQuSW1wbGVtZW50c0tleXdvcmQgJiYgIWlzQW1iaWVudChkZWNsKSkge1xuICAgICAgICAvLyBJZiBhIGNsYXNzIGhhcyBcImV4dGVuZHMgRm9vXCIsIHRoYXQgaXMgcHJlc2VydmVkIGluIHRoZSBFUzYgb3V0cHV0XG4gICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLiAgQnV0IGlmIGl0IGhhcyBcImltcGxlbWVudHMgRm9vXCIsXG4gICAgICAgIC8vIHRoYXQgaXMgYSBUUy1zcGVjaWZpYyB0aGluZyBhbmQgd2UgbmVlZCB0byB0cmFuc2xhdGUgaXQgdG8gdGhlXG4gICAgICAgIC8vIHRoZSBDbG9zdXJlIFwiQGltcGxlbWVudHMge0Zvb31cIi5cbiAgICAgICAgLy8gSG93ZXZlciBmb3IgYW1iaWVudCBkZWNsYXJhdGlvbnMsIHdlIG9ubHkgZW1pdCBleHRlcm5zLCBhbmQgaW4gdGhvc2Ugd2UgZG8gbmVlZCB0b1xuICAgICAgICAvLyBhZGQgXCJAZXh0ZW5kcyB7Rm9vfVwiIGFzIHRoZXkgdXNlIEVTNSBzeW50YXguXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbXBsIG9mIGhlcml0YWdlLnR5cGVzKSB7XG4gICAgICAgIGxldCB0YWdOYW1lID0gZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uID8gJ2V4dGVuZHMnIDogJ2ltcGxlbWVudHMnO1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IEBpbXBsZW1lbnRzIGFuIGludGVyZmFjZSwgbm90IGEgY2xhc3MuXG4gICAgICAgIC8vIEJ1dCBpdCdzIGZpbmUgdG8gdHJhbnNsYXRlIFRTIFwiaW1wbGVtZW50cyBDbGFzc1wiIGludG8gQ2xvc3VyZVxuICAgICAgICAvLyBcIkBleHRlbmRzIHtDbGFzc31cIiBiZWNhdXNlIHRoaXMgaXMganVzdCBhIHR5cGUgaGludC5cbiAgICAgICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuICAgICAgICBjb25zdCBzeW0gPSB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGltcGwuZXhwcmVzc2lvbik7XG4gICAgICAgIGxldCBhbGlhczogdHMuU3ltYm9sID0gc3ltO1xuICAgICAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZUFsaWFzKSB7XG4gICAgICAgICAgLy8gSXQncyBpbXBsZW1lbnRpbmcgYSB0eXBlIGFsaWFzLiAgRm9sbG93IHRoZSB0eXBlIGFsaWFzIGJhY2tcbiAgICAgICAgICAvLyB0byB0aGUgb3JpZ2luYWwgc3ltYm9sIHRvIGNoZWNrIHdoZXRoZXIgaXQncyBhIHR5cGUgb3IgYSB2YWx1ZS5cbiAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXREZWNsYXJlZFR5cGVPZlN5bWJvbChzeW0pO1xuICAgICAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IGNsZWFyIHdoZW4gdGhpcyBjYW4gaGFwcGVuLCBidXQgaWYgaXQgZG9lcyBhbGwgd2VcbiAgICAgICAgICAgIC8vIGRvIGlzIGZhaWwgdG8gZW1pdCB0aGUgQGltcGxlbWVudHMsIHdoaWNoIGlzbid0IHNvIGhhcm1mdWwuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWxpYXMgPSB0eXBlLnN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpYXMuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICAgIGFsaWFzID0gdHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChhbGlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVRyYW5zbGF0b3IgPSB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGltcGwuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICh0eXBlVHJhbnNsYXRvci5pc0JsYWNrTGlzdGVkKGFsaWFzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGlhcy5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkNsYXNzKSB7XG4gICAgICAgICAgaWYgKCFpc0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNsYXNzZXMgY2FuIGV4dGVuZCBjbGFzc2VzIGluIFRTLiBJZ25vcmluZyB0aGUgaGVyaXRhZ2UgY2xhdXNlIHNob3VsZCBiZSBzYWZlLFxuICAgICAgICAgICAgLy8gYXMgaW50ZXJmYWNlcyBhcmUgQHJlY29yZCBhbnl3YXksIHNvIHNob3VsZCBwcmV2ZW50IHByb3BlcnR5IGRpc2FtYmlndWF0aW9uLlxuXG4gICAgICAgICAgICAvLyBQcm9ibGVtOiB2YWxpZGF0ZSB0aGF0IG1ldGhvZHMgYXJlIHRoZXJlP1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZ05hbWUgPSAnZXh0ZW5kcyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpYXMuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkge1xuICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgd2FzIGFscmVhZHkgaW4gdGhlIHZhbHVlIG5hbWVzcGFjZSwgdGhlbiBpdCB3aWxsXG4gICAgICAgICAgLy8gbm90IGJlIGEgdHlwZSBpbiB0aGUgQ2xvc3VyZSBvdXRwdXQgKGJlY2F1c2UgQ2xvc3VyZSBjb2xsYXBzZXNcbiAgICAgICAgICAvLyB0aGUgdHlwZSBhbmQgdmFsdWUgbmFtZXNwYWNlcykuICBKdXN0IGlnbm9yZSB0aGUgaW1wbGVtZW50cy5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlVG9DbG9zdXJlIGluY2x1ZGVzIG51bGxhYmlsaXR5IG1vZGlmaWVycywgc28gY2FsbCBzeW1ib2xUb1N0cmluZyBkaXJlY3RseSBoZXJlLlxuICAgICAgICBkb2NUYWdzLnB1c2goe3RhZ05hbWUsIHR5cGU6IHR5cGVUcmFuc2xhdG9yLnN5bWJvbFRvU3RyaW5nKHN5bSwgdHJ1ZSl9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogRW1pdHMgYSB0eXBlIGFubm90YXRpb24gaW4gSlNEb2MsIG9yIHs/fSBpZiB0aGUgdHlwZSBpcyB1bmF2YWlsYWJsZS4gKi9cbiAgZW1pdEpTRG9jVHlwZShub2RlOiB0cy5Ob2RlLCBhZGRpdGlvbmFsRG9jVGFnPzogc3RyaW5nLCB0eXBlPzogdHMuVHlwZSkge1xuICAgIHRoaXMuZW1pdCgnIC8qKicpO1xuICAgIGlmIChhZGRpdGlvbmFsRG9jVGFnKSB7XG4gICAgICB0aGlzLmVtaXQoJyAnICsgYWRkaXRpb25hbERvY1RhZyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChgIEB0eXBlIHske3RoaXMudHlwZVRvQ2xvc3VyZShub2RlLCB0eXBlKX19ICovYCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIFR5cGVTY3JpcHQgdHMuVHlwZSBpbnRvIHRoZSBlcXVpdmFsZW50IENsb3N1cmUgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIHRzLk5vZGUgY29udGFpbmluZyB0aGUgdHlwZSByZWZlcmVuY2U7IHVzZWQgZm9yIHJlc29sdmluZyBzeW1ib2xzXG4gICAqICAgICBpbiBjb250ZXh0LlxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byB0cmFuc2xhdGU7IGlmIG5vdCBwcm92aWRlZCwgdGhlIE5vZGUncyB0eXBlIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHJlc29sdmVBbGlhcyBJZiB0cnVlLCBkbyBub3QgZW1pdCBhbGlhc2VzIGFzIHRoZWlyIHN5bWJvbCwgYnV0IHJhdGhlciBhcyB0aGUgcmVzb2x2ZWRcbiAgICogICAgIHR5cGUgdW5kZXJseWluZyB0aGUgYWxpYXMuIFRoaXMgc2hvdWxkIGJlIHRydWUgb25seSB3aGVuIGVtaXR0aW5nIHRoZSB0eXBlZGVmIGl0c2VsZi5cbiAgICovXG4gIHR5cGVUb0Nsb3N1cmUoY29udGV4dDogdHMuTm9kZSwgdHlwZT86IHRzLlR5cGUsIHJlc29sdmVBbGlhcz86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmhvc3QudW50eXBlZCkge1xuICAgICAgcmV0dXJuICc/JztcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlQ2hlY2tlciA9IHRoaXMudHlwZUNoZWNrZXI7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQpLnRyYW5zbGF0ZSh0eXBlLCByZXNvbHZlQWxpYXMpO1xuICB9XG5cbiAgbmV3VHlwZVRyYW5zbGF0b3IoY29udGV4dDogdHMuTm9kZSkge1xuICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBuZXcgdHlwZVRyYW5zbGF0b3IuVHlwZVRyYW5zbGF0b3IoXG4gICAgICAgIHRoaXMudHlwZUNoZWNrZXIsIGNvbnRleHQsIHRoaXMuaG9zdC50eXBlQmxhY2tMaXN0UGF0aHMsIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzKTtcbiAgICB0cmFuc2xhdG9yLndhcm4gPSBtc2cgPT4gdGhpcy5kZWJ1Z1dhcm4oY29udGV4dCwgbXNnKTtcbiAgICByZXR1cm4gdHJhbnNsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWJ1ZyBsb2dzIGEgZGVidWcgd2FybmluZy4gIFRoZXNlIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNhc2VzXG4gICAqIHdoZXJlIHRzaWNrbGUgaXMgbWFraW5nIGEgcXVlc3Rpb25hYmxlIGp1ZGdlbWVudCBhYm91dCB3aGF0IHRvIGRvLlxuICAgKiBCeSBkZWZhdWx0LCB0c2lja2xlIGRvZXMgbm90IHJlcG9ydCBhbnkgd2FybmluZ3MgdG8gdGhlIGNhbGxlcixcbiAgICogYW5kIHdhcm5pbmdzIGFyZSBoaWRkZW4gYmVoaW5kIGEgZGVidWcgZmxhZywgYXMgd2FybmluZ3MgYXJlIG9ubHlcbiAgICogZm9yIHRzaWNrbGUgdG8gZGVidWcgaXRzZWxmLlxuICAgKi9cbiAgZGVidWdXYXJuKG5vZGU6IHRzLk5vZGUsIG1lc3NhZ2VUZXh0OiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuaG9zdC5sb2dXYXJuaW5nKSByZXR1cm47XG4gICAgLy8gVXNlIGEgdHMuRGlhZ25vc2ljIHNvIHRoYXQgdGhlIHdhcm5pbmcgaW5jbHVkZXMgY29udGV4dCBhbmQgZmlsZSBvZmZldHMuXG4gICAgY29uc3QgZGlhZ25vc3RpYzogdHMuRGlhZ25vc3RpYyA9IHtcbiAgICAgIGZpbGU6IHRoaXMuZmlsZSxcbiAgICAgIHN0YXJ0OiBub2RlLmdldFN0YXJ0KCksXG4gICAgICBsZW5ndGg6IG5vZGUuZ2V0RW5kKCkgLSBub2RlLmdldFN0YXJ0KCksXG4gICAgICBtZXNzYWdlVGV4dCxcbiAgICAgIGNhdGVnb3J5OiB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyxcbiAgICAgIGNvZGU6IDAsXG4gICAgfTtcbiAgICB0aGlzLmhvc3QubG9nV2FybmluZyhkaWFnbm9zdGljKTtcbiAgfVxufVxuXG50eXBlIEhhc1R5cGVQYXJhbWV0ZXJzID1cbiAgICB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbnx0cy5DbGFzc0xpa2VEZWNsYXJhdGlvbnx0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbnx0cy5TaWduYXR1cmVEZWNsYXJhdGlvbjtcblxuLy8gTWF0Y2hlcyBjb21tb24gZXh0ZW5zaW9ucyBvZiBUeXBlU2NyaXB0IGlucHV0IGZpbGVuYW1lc1xuY29uc3QgZXh0ZW5zaW9uID0gLyhcXC50c3xcXC5kXFwudHN8XFwuanN8XFwuanN4fFxcLnRzeCkkLztcblxuY29uc3QgRklMRU9WRVJWSUVXX0NPTU1FTlRTOiBSZWFkb25seVNldDxzdHJpbmc+ID1cbiAgICBuZXcgU2V0KFsnZmlsZW92ZXJ2aWV3JywgJ2V4dGVybnMnLCAnbW9kTmFtZScsICdtb2RzJywgJ3BpbnRvbW9kdWxlJ10pO1xuXG4vKiogQW5ub3RhdG9yIHRyYW5zbGF0ZXMgYSAudHMgdG8gYSAudHMgd2l0aCBDbG9zdXJlIGFubm90YXRpb25zLiAqL1xuY2xhc3MgQW5ub3RhdG9yIGV4dGVuZHMgQ2xvc3VyZVJld3JpdGVyIHtcbiAgLyoqIEV4cG9ydGVkIHN5bWJvbCBuYW1lcyB0aGF0IGhhdmUgYmVlbiBnZW5lcmF0ZWQgYnkgZXhwYW5kaW5nIGFuIFwiZXhwb3J0ICogZnJvbSAuLi5cIi4gKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZWRFeHBvcnRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIC8qKiBEZWNvcmF0b3JDbGFzc1Zpc2l0b3Igd2hlbiBsb3dlcmluZyBkZWNvcmF0b3JzIHdoaWxlIGNsb3N1cmUgYW5ub3RhdGluZyAqL1xuICBwcml2YXRlIGN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXI6IGRlY29yYXRvci5EZWNvcmF0b3JDbGFzc1Zpc2l0b3J8dW5kZWZpbmVkO1xuICAvKiogQ29sbGVjdGlvbiBvZiBJZGVudGlmaWVycyB1c2VkIGluIGFuIGBpbXBvcnQge2Zvb31gIGRlY2xhcmF0aW9uIHdpdGggdGhlaXIgU3ltYm9sICovXG4gIHByaXZhdGUgaW1wb3J0ZWROYW1lczogQXJyYXk8e25hbWU6IHRzLklkZW50aWZpZXIsIGRlY2xhcmF0aW9uTmFtZXM6IHRzLklkZW50aWZpZXJbXX0+ID0gW107XG5cbiAgcHJpdmF0ZSB0ZW1wbGF0ZVNwYW5TdGFja0NvdW50ID0gMDtcbiAgcHJpdmF0ZSBwb2x5bWVyQmVoYXZpb3JTdGFja0NvdW50ID0gMDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgZmlsZTogdHMuU291cmNlRmlsZSwgaG9zdDogQW5ub3RhdG9ySG9zdCxcbiAgICAgIHByaXZhdGUgdHNIb3N0PzogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3QsIHByaXZhdGUgdHNPcHRzPzogdHMuQ29tcGlsZXJPcHRpb25zLFxuICAgICAgc291cmNlTWFwcGVyPzogU291cmNlTWFwcGVyKSB7XG4gICAgc3VwZXIodHlwZUNoZWNrZXIsIGZpbGUsIGhvc3QsIHNvdXJjZU1hcHBlcik7XG4gIH1cblxuICBhbm5vdGF0ZSgpIHtcbiAgICB0aGlzLnZpc2l0KHRoaXMuZmlsZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0KCk7XG4gIH1cblxuICBnZXRFeHBvcnREZWNsYXJhdGlvbk5hbWVzKG5vZGU6IHRzLk5vZGUpOiB0cy5JZGVudGlmaWVyW10ge1xuICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgIGNvbnN0IHZhckRlY2wgPSBub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50O1xuICAgICAgICByZXR1cm4gdmFyRGVjbC5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zLm1hcChcbiAgICAgICAgICAgIChkKSA9PiB0aGlzLmdldEV4cG9ydERlY2xhcmF0aW9uTmFtZXMoZClbMF0pO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbnRlcmZhY2VEZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBkZWNsID0gbm9kZSBhcyB0cy5OYW1lZERlY2xhcmF0aW9uO1xuICAgICAgICBpZiAoIWRlY2wubmFtZSB8fCBkZWNsLm5hbWUua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtkZWNsLm5hbWVdO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBbGlhc0RlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCB0eXBlQWxpYXMgPSBub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uO1xuICAgICAgICByZXR1cm4gW3R5cGVBbGlhcy5uYW1lXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmVycm9yKFxuICAgICAgICBub2RlLCBgdW5zdXBwb3J0ZWQgZXhwb3J0IGRlY2xhcmF0aW9uICR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfTogJHtub2RlLmdldFRleHQoKX1gKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYW4gRVM2IGV4cG9ydCBmb3IgdGhlIGFtYmllbnQgZGVjbGFyYXRpb24gYmVoaW5kIG5vZGUsIGlmIGl0IGlzIGluZGVlZCBleHBvcnRlZC5cbiAgICovXG4gIG1heWJlRW1pdEFtYmllbnREZWNsYXJhdGlvbkV4cG9ydChub2RlOiB0cy5Ob2RlKSB7XG4gICAgLy8gSW4gVHlwZVNjcmlwdCwgYGV4cG9ydCBkZWNsYXJlYCBzaW1wbHkgZ2VuZXJhdGVzIG5vIGNvZGUgaW4gdGhlIGV4cG9ydGluZyBtb2R1bGUsIGJ1dCBkb2VzXG4gICAgLy8gZ2VuZXJhdGUgYSByZWd1bGFyIGltcG9ydCBpbiB0aGUgaW1wb3J0aW5nIG1vZHVsZS5cbiAgICAvLyBGb3IgQ2xvc3VyZSBDb21waWxlciwgc3VjaCBkZWNsYXJhdGlvbnMgbXVzdCBzdGlsbCBiZSBleHBvcnRlZCwgc28gdGhhdCBpbXBvcnRpbmcgY29kZSBpblxuICAgIC8vIG90aGVyIG1vZHVsZXMgY2FuIHJlZmVyZW5jZSB0aGVtLiBCZWNhdXNlIHRzaWNrbGUgZ2VuZXJhdGVzIGdsb2JhbCBzeW1ib2xzIGZvciBzdWNoIHR5cGVzLFxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBzZW1hbnRpY3MgYXJlIHJlZmVyZW5jaW5nIHRoZSBnbG9iYWwgbmFtZS5cbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQgfHwgIWhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVjbE5hbWVzID0gdGhpcy5nZXRFeHBvcnREZWNsYXJhdGlvbk5hbWVzKG5vZGUpO1xuICAgIGZvciAoY29uc3QgZGVjbCBvZiBkZWNsTmFtZXMpIHtcbiAgICAgIGNvbnN0IHN5bSA9IHRoaXMubXVzdEdldFN5bWJvbEF0TG9jYXRpb24oZGVjbCk7XG4gICAgICBjb25zdCBpc1ZhbHVlID0gc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWU7XG4gICAgICBjb25zdCBkZWNsTmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGRlY2wpO1xuICAgICAgaWYgKG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudCkge1xuICAgICAgICAvLyBGb3IgdmFyaWFibGVzLCBUeXBlU2NyaXB0IHJld3JpdGVzIGV2ZXJ5IHJlZmVyZW5jZSB0byB0aGUgdmFyaWFibGUgbmFtZSBhcyBhblxuICAgICAgICAvLyBcImV4cG9ydHMuXCIgYWNjZXNzLCB0byBtYWludGFpbiBtdXRhYmxlIEVTNiBleHBvcnRzIHNlbWFudGljcy4gSW5kaXJlY3RpbmcgdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gd2luZG93IG9iamVjdCBtZWFucyB3ZSByZWZlcmVuY2UgdGhlIGNvcnJlY3QgZ2xvYmFsIHN5bWJvbC4gQ2xvc3VyZSBDb21waWxlciBkb2VzXG4gICAgICAgIC8vIHVuZGVyc3RhbmQgdGhhdCBcInZhciBmb29cIiBpbiBleHRlcm5zIGNvcnJlc3BvbmRzIHRvIFwid2luZG93LmZvb1wiLlxuICAgICAgICB0aGlzLmVtaXQoYFxcbmV4cG9ydHMuJHtkZWNsTmFtZX0gPSB3aW5kb3cuJHtkZWNsTmFtZX07XFxuYCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZhbHVlKSB7XG4gICAgICAgIC8vIERvIG5vdCBlbWl0IHJlLWV4cG9ydHMgZm9yIE1vZHVsZURlY2xhcmF0aW9ucy5cbiAgICAgICAgLy8gQW1iaWVudCBNb2R1bGVEZWNsYXJhdGlvbnMgYXJlIGFsd2F5cyByZWZlcmVuY2VkIGFzIGdsb2JhbCBzeW1ib2xzLCBzbyB0aGV5IGRvbid0IG5lZWQgdG9cbiAgICAgICAgLy8gYmUgZXhwb3J0ZWQuXG4gICAgICAgIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuTW9kdWxlRGVjbGFyYXRpb24pIGNvbnRpbnVlO1xuICAgICAgICAvLyBOb24tdmFsdWUgb2JqZWN0cyBkbyBub3QgZXhpc3QgYXQgcnVudGltZSwgc28gd2UgY2Fubm90IGFjY2VzcyB0aGUgc3ltYm9sIChpdCBvbmx5XG4gICAgICAgIC8vIGV4aXN0cyBpbiBleHRlcm5zKS4gRXhwb3J0IHRoZW0gYXMgYSB0eXBlZGVmLCB3aGljaCBmb3J3YXJkcyB0byB0aGUgdHlwZSBpbiBleHRlcm5zLlxuICAgICAgICB0aGlzLmVtaXQoYFxcbi8qKiBAdHlwZWRlZiB7JHtkZWNsTmFtZX19ICovXFxuZXhwb3J0cy4ke2RlY2xOYW1lfTtcXG5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChgXFxuZXhwb3J0cy4ke2RlY2xOYW1lfSA9ICR7ZGVjbE5hbWV9O1xcbmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGFtaW5lcyBhIHRzLk5vZGUgYW5kIGRlY2lkZXMgd2hldGhlciB0byBkbyBzcGVjaWFsIHByb2Nlc3Npbmcgb2YgaXQgZm9yIG91dHB1dC5cbiAgICpcbiAgICogQHJldHVybiBUcnVlIGlmIHRoZSB0cy5Ob2RlIGhhcyBiZWVuIGhhbmRsZWQsIGZhbHNlIGlmIHdlIHNob3VsZFxuICAgKiAgICAgZW1pdCBpdCBhcyBpcyBhbmQgdmlzaXQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgbWF5YmVQcm9jZXNzKG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKG5vZGUsIHRzLk1vZGlmaWVyRmxhZ3MuQW1iaWVudCkgfHwgaXNEdHNGaWxlTmFtZSh0aGlzLmZpbGUuZmlsZU5hbWUpKSB7XG4gICAgICAvLyBBbiBhbWJpZW50IGRlY2xhcmF0aW9uIGRlY2xhcmVzIHR5cGVzIGZvciBUeXBlU2NyaXB0J3MgYmVuZWZpdCwgc28gd2Ugd2FudCB0byBza2lwIFRzaWNrbGVcbiAgICAgIC8vIGNvbnZlcnNpb24gb2YgaXRzIGNvbnRlbnRzLlxuICAgICAgdGhpcy53cml0ZVJhbmdlKG5vZGUsIG5vZGUuZ2V0RnVsbFN0YXJ0KCksIG5vZGUuZ2V0RW5kKCkpO1xuICAgICAgLy8gLi4uIGJ1dCBpdCBtaWdodCBuZWVkIHRvIGJlIGV4cG9ydGVkIGZvciBkb3duc3RyZWFtIGltcG9ydGluZyBjb2RlLlxuICAgICAgdGhpcy5tYXliZUVtaXRBbWJpZW50RGVjbGFyYXRpb25FeHBvcnQobm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlcikge1xuICAgICAgdGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyLmJlZm9yZVByb2Nlc3NOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlNvdXJjZUZpbGU6XG4gICAgICAgIHRoaXMuaGFuZGxlU291cmNlRmlsZShub2RlIGFzIHRzLlNvdXJjZUZpbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbXBvcnREZWNsYXJhdGlvbjpcbiAgICAgICAgdGhpcy5pbXBvcnRlZE5hbWVzLnB1c2goXG4gICAgICAgICAgICAuLi5kZWNvcmF0b3IuY29sbGVjdEltcG9ydGVkTmFtZXModGhpcy50eXBlQ2hlY2tlciwgbm9kZSBhcyB0cy5JbXBvcnREZWNsYXJhdGlvbikpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0SW1wb3J0RGVjbGFyYXRpb24obm9kZSBhcyB0cy5JbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGV4cG9ydERlY2wgPSBub2RlIGFzIHRzLkV4cG9ydERlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLndyaXRlTGVhZGluZ1RyaXZpYShub2RlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdleHBvcnQnKTtcbiAgICAgICAgbGV0IGV4cG9ydGVkU3ltYm9sczogTmFtZWRTeW1ib2xbXSA9IFtdO1xuICAgICAgICBpZiAoIWV4cG9ydERlY2wuZXhwb3J0Q2xhdXNlICYmIGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgLy8gSXQncyBhbiBcImV4cG9ydCAqIGZyb20gLi4uXCIgc3RhdGVtZW50LlxuICAgICAgICAgIC8vIFJld3JpdGUgaXQgdG8gcmUtZXhwb3J0IGVhY2ggZXhwb3J0ZWQgc3ltYm9sIGRpcmVjdGx5LlxuICAgICAgICAgIGV4cG9ydGVkU3ltYm9scyA9IHRoaXMuZXhwYW5kU3ltYm9sc0Zyb21FeHBvcnRTdGFyKGV4cG9ydERlY2wpO1xuICAgICAgICAgIGNvbnN0IGV4cG9ydFN5bWJvbHNUb0VtaXQgPVxuICAgICAgICAgICAgICBleHBvcnRlZFN5bWJvbHMuZmlsdGVyKHMgPT4gdGhpcy5zaG91bGRFbWl0RXhwb3J0U3ltYm9sKHMuc3ltKSk7XG4gICAgICAgICAgdGhpcy5lbWl0KGAgeyR7ZXhwb3J0U3ltYm9sc1RvRW1pdC5tYXAoZSA9PiB1bmVzY2FwZU5hbWUoZS5uYW1lKSkuam9pbignLCcpfX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZXhwb3J0RGVjbC5leHBvcnRDbGF1c2UpIHtcbiAgICAgICAgICAgIGV4cG9ydGVkU3ltYm9scyA9IHRoaXMuZ2V0TmFtZWRTeW1ib2xzKGV4cG9ydERlY2wuZXhwb3J0Q2xhdXNlLmVsZW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXQoZXhwb3J0RGVjbC5leHBvcnRDbGF1c2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoYCBmcm9tICcke3RoaXMucmVzb2x2ZU1vZHVsZVNwZWNpZmllcihleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllcil9JztgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBleHBvcnQgey4uLn07XG4gICAgICAgICAgdGhpcy5lbWl0KCc7Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRTb3VyY2VNYXBwaW5nKG5vZGUpO1xuICAgICAgICBpZiAoZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmREZWNsYXJlKGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyLCBleHBvcnRlZFN5bWJvbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRlZFN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5lbWl0VHlwZURlZkV4cG9ydHMoZXhwb3J0ZWRTeW1ib2xzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbnRlcmZhY2VEZWNsYXJhdGlvbjpcbiAgICAgICAgdGhpcy5lbWl0SW50ZXJmYWNlKG5vZGUgYXMgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pO1xuICAgICAgICAvLyBFbWl0IHRoZSBUUyBpbnRlcmZhY2UgdmVyYmF0aW0sIHdpdGggbm8gdHNpY2tsZSBwcm9jZXNzaW5nIG9mIHByb3BlcnRpZXMuXG4gICAgICAgIHRoaXMud3JpdGVSYW5nZShub2RlLCBub2RlLmdldEZ1bGxTdGFydCgpLCBub2RlLmdldEVuZCgpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgdmFyRGVjbCA9IG5vZGUgYXMgdHMuVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgLy8gT25seSBlbWl0IGEgdHlwZSBhbm5vdGF0aW9uIHdoZW4gaXQncyBhIHBsYWluIHZhcmlhYmxlIGFuZFxuICAgICAgICAvLyBub3QgYSBiaW5kaW5nIHBhdHRlcm4sIGFzIENsb3N1cmUgZG9lc24ndCg/KSBoYXZlIGEgc3ludGF4XG4gICAgICAgIC8vIGZvciBhbm5vdGF0aW5nIGJpbmRpbmcgcGF0dGVybnMuICBTZWUgaXNzdWUgIzEyOC5cbiAgICAgICAgLy8gRG9uJ3QgZW1pdCB0eXBlIGFubm90YXRpb24gd2hlbiB0aGUgdmFyaWFibGUgc3RhdGVtZW50IGlzIGEgQHBvbHltZXJCZWhhdmlvcixcbiAgICAgICAgLy8gYXMgb3RoZXJ3aXNlIHRoZSBwb2x5bWVyIGNsb3N1cmUgY2hlY2tlciB3aWxsIGZhaWwuXG4gICAgICAgIC8vIFNlZSBiLzY0Mzg5ODA2XG4gICAgICAgIGlmICh0aGlzLnBvbHltZXJCZWhhdmlvclN0YWNrQ291bnQgPT09IDAgJiZcbiAgICAgICAgICAgIHZhckRlY2wubmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB0aGlzLmVtaXRKU0RvY1R5cGUodmFyRGVjbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGNsYXNzTm9kZSA9IG5vZGUgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy52aXNpdENsYXNzRGVjbGFyYXRpb24oY2xhc3NOb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHVibGljS2V5d29yZDpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Qcml2YXRlS2V5d29yZDpcbiAgICAgICAgLy8gVGhlIFwicHVibGljXCIvXCJwcml2YXRlXCIga2V5d29yZHMgYXJlIGVuY291bnRlcmVkIGluIHR3byBwbGFjZXM6XG4gICAgICAgIC8vIDEpIEluIGNsYXNzIGZpZWxkcyAod2hpY2ggZG9uJ3QgYXBwZWFyIGluIHRoZSB0cmFuc2Zvcm1lZCBvdXRwdXQpLlxuICAgICAgICAvLyAyKSBJbiBcInBhcmFtZXRlciBwcm9wZXJ0aWVzXCIsIGUuZy5cbiAgICAgICAgLy8gICAgICBjb25zdHJ1Y3RvcigvKiogQGV4cG9ydCAqLyBwdWJsaWMgZm9vOiBzdHJpbmcpLlxuICAgICAgICAvLyBJbiBjYXNlIDIgaXQncyBpbXBvcnRhbnQgdG8gbm90IGVtaXQgdGhhdCBKU0RvYyBpbiB0aGUgZ2VuZXJhdGVkXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yLCBhcyB0aGlzIGlzIGlsbGVnYWwgZm9yIENsb3N1cmUuICBJdCdzIHNhZmUgdG8ganVzdFxuICAgICAgICAvLyBhbHdheXMgc2tpcCBjb21tZW50cyBwcmVjZWRpbmcgdGhlICdwdWJsaWMnIGtleXdvcmQuXG4gICAgICAgIC8vIFNlZSB0ZXN0X2ZpbGVzL3BhcmFtZXRlcl9wcm9wZXJ0aWVzLnRzLlxuICAgICAgICB0aGlzLndyaXRlTm9kZShub2RlLCAvKiBza2lwQ29tbWVudHMgKi8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNvbnN0cnVjdG9yOlxuICAgICAgICBjb25zdCBjdG9yID0gbm9kZSBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLmVtaXRGdW5jdGlvblR5cGUoW2N0b3JdKTtcbiAgICAgICAgLy8gV3JpdGUgdGhlIFwiY29uc3RydWN0b3IoLi4uKSB7XCIgYml0LCBidXQgaXRlcmF0ZSB0aHJvdWdoIGFueVxuICAgICAgICAvLyBwYXJhbWV0ZXJzIGlmIGdpdmVuIHNvIHRoYXQgd2UgY2FuIGV4YW1pbmUgdGhlbSBtb3JlIGNsb3NlbHkuXG4gICAgICAgIHRoaXMud3JpdGVOb2RlRnJvbShjdG9yLCBjdG9yLmdldFN0YXJ0KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5BcnJvd0Z1bmN0aW9uOlxuICAgICAgICAvLyBJdCdzIGRpZmZpY3VsdCB0byBhbm5vdGF0ZSBhcnJvdyBmdW5jdGlvbnMgZHVlIHRvIGEgYnVnIGluXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgKHNlZSB0c2lja2xlIGlzc3VlIDU3KS4gIEZvciBub3csIGp1c3QgcGFzcyB0aGVtXG4gICAgICAgIC8vIHRocm91Z2ggdW5hbm5vdGF0ZWQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkdldEFjY2Vzc29yOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlNldEFjY2Vzc29yOlxuICAgICAgICBjb25zdCBmbkRlY2wgPSBub2RlIGFzIHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uO1xuICAgICAgICBjb25zdCB0YWdzID0gaGFzRXhwb3J0aW5nRGVjb3JhdG9yKG5vZGUsIHRoaXMudHlwZUNoZWNrZXIpID8gW3t0YWdOYW1lOiAnZXhwb3J0J31dIDogW107XG5cbiAgICAgICAgaWYgKCFmbkRlY2wuYm9keSkge1xuICAgICAgICAgIC8vIFR3byBjYXNlczogYWJzdHJhY3QgbWV0aG9kcyBhbmQgb3ZlcmxvYWRlZCBtZXRob2RzL2Z1bmN0aW9ucy5cbiAgICAgICAgICAvLyBBYnN0cmFjdCBtZXRob2RzIGFyZSBoYW5kbGVkIGluIGVtaXRUeXBlQW5ub3RhdGlvbnNIYW5kbGVyLlxuICAgICAgICAgIC8vIE92ZXJsb2FkcyBhcmUgdW5pb24taXplZCBpbnRvIHRoZSBzaGFyZWQgdHlwZSBpbiBlbWl0RnVuY3Rpb25UeXBlLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdEZ1bmN0aW9uVHlwZShbZm5EZWNsXSwgdGFncyk7XG4gICAgICAgIHRoaXMubmV3VHlwZVRyYW5zbGF0b3IoZm5EZWNsKS5ibGFja2xpc3RUeXBlUGFyYW1ldGVycyhcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBmbkRlY2wudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLndyaXRlTm9kZUZyb20oZm5EZWNsLCBmbkRlY2wuZ2V0U3RhcnQoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBbGlhc0RlY2xhcmF0aW9uOlxuICAgICAgICB0aGlzLndyaXRlTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy52aXNpdFR5cGVBbGlhcyhub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRW51bURlY2xhcmF0aW9uOlxuICAgICAgICB0aGlzLnByb2Nlc3NFbnVtKG5vZGUgYXMgdHMuRW51bURlY2xhcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVGVtcGxhdGVTcGFuOlxuICAgICAgICB0aGlzLnRlbXBsYXRlU3BhblN0YWNrQ291bnQrKztcbiAgICAgICAgdGhpcy53cml0ZU5vZGUobm9kZSk7XG4gICAgICAgIHRoaXMudGVtcGxhdGVTcGFuU3RhY2tDb3VudC0tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQXNzZXJ0aW9uRXhwcmVzc2lvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Bc0V4cHJlc3Npb246XG4gICAgICAgIC8vIEJvdGggb2YgdGhlc2UgY2FzZXMgYXJlIEFzc2VydGlvbkV4cHJlc3Npb25zLlxuICAgICAgICBjb25zdCB0eXBlQXNzZXJ0aW9uID0gbm9kZSBhcyB0cy5Bc3NlcnRpb25FeHByZXNzaW9uO1xuICAgICAgICBpZiAodGhpcy5wb2x5bWVyQmVoYXZpb3JTdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgIC8vIERvbid0IGVtaXQgdHlwZSBjYXN0cyBmb3IgUG9seW1lciBiZWhhdmlvcnMgdGhhdCBhcmUgZGVjbGFyZWRcbiAgICAgICAgICAvLyBieSBjYWxsaW5nIHRoZSBQb2x5bWVyIGZ1bmN0aW9uXG4gICAgICAgICAgLy8gYXMgdGhlIFBvbHltZXIgY2xvc3VyZSBwbHVnaW4gZG9lcyBub3Qgd29yayB3aGVuIGVtaXR0aW5nIHRoZW0uXG4gICAgICAgICAgLy8gU2VlIGIvNjQzODk4MDYuXG4gICAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IG1hdHRlcnMgaW4gdGhlIHRyYW5zZm9ybWVyIHZlcnNpb24gb2YgdHNpY2tsZSxcbiAgICAgICAgICAvLyBhcyB0aGUgbm9uIHRyYW5zZm9ybWVyIHZlcnNpb24gbmV2ZXIgZW1pdHRlZCB0eXBlIGNhc3RzIGR1ZSB0b1xuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvOTg3MyAoc2VlIGJlbG93KS5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB1c2luZyBhIHR5cGUgY2FzdHMgaW4gdGVtcGxhdGUgZXhwcmVzc2lvbnMsXG4gICAgICAgIC8vIGNsb3N1cmUgcmVxdWlyZXMgYW5vdGhlciBwYWlyIG9mIHBhcmVucywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAgICAgICAgLy8gY29tcGxhaW4gd2l0aCBcIk1pc3BsYWNlZCB0eXBlIGFubm90YXRpb24uIFR5cGUgYW5ub3RhdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGhlcmUuXCJcbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGVTcGFuU3RhY2tDb3VudCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJygnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRKU0RvY1R5cGUodHlwZUFzc2VydGlvbik7XG4gICAgICAgIC8vIFdoZW4gVHlwZVNjcmlwdCBlbWl0cyBKUywgaXQgcmVtb3ZlcyBvbmUgbGF5ZXIgb2YgXCJyZWR1bmRhbnRcIlxuICAgICAgICAvLyBwYXJlbnMsIGJ1dCB3ZSBuZWVkIHRoZW0gZm9yIHRoZSBDbG9zdXJlIHR5cGUgYXNzZXJ0aW9uLiAgV29ya1xuICAgICAgICAvLyBhcm91bmQgdGhpcyBieSB1c2luZyB0d28gcGFyZW5zLiAgU2VlIHRlc3RfZmlsZXMvY29lcmNlLiouXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGluIGJvdGgsIHRoZSB0cmFuc2Zvcm1lciBhbmQgbm9uIHRyYW5zZm9ybWVyIHZlcnNpb24uXG4gICAgICAgIC8vIFRPRE86IGluIHRoZSBub24gdHJhbnNmb3JtZXIgdmVyc2lvbiwgdGhlIGNvbW1lbnQgaXMgY3VycmVudGx5IGRyb3BwZWRcbiAgICAgICAgLy8gIGFsbHRlZ2V0aGVyIGZyb20gcHVyZSBhc3NpZ25tZW50cyBkdWUgdG9cbiAgICAgICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvOTg3My5cbiAgICAgICAgdGhpcy5lbWl0KCcoKCcpO1xuICAgICAgICB0aGlzLndyaXRlTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5lbWl0KCcpKScpO1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZVNwYW5TdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk5vbk51bGxFeHByZXNzaW9uOlxuICAgICAgICBjb25zdCBubmV4cHIgPSBub2RlIGFzIHRzLk5vbk51bGxFeHByZXNzaW9uO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm5leHByLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5Vbmlvbikge1xuICAgICAgICAgIGNvbnN0IG5vbk51bGxVbmlvbiA9XG4gICAgICAgICAgICAgICh0eXBlIGFzIHRzLlVuaW9uVHlwZSlcbiAgICAgICAgICAgICAgICAgIC50eXBlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgdCA9PiAodC5mbGFncyAmICh0cy5UeXBlRmxhZ3MuTnVsbCB8IHRzLlR5cGVGbGFncy5VbmRlZmluZWQpKSA9PT0gMCk7XG4gICAgICAgICAgY29uc3QgdHlwZUNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlIGFzIHRzLlVuaW9uVHlwZSk7XG4gICAgICAgICAgdHlwZUNvcHkudHlwZXMgPSBub25OdWxsVW5pb247XG4gICAgICAgICAgdHlwZSA9IHR5cGVDb3B5O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlLlxuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZVNwYW5TdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnKCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdEpTRG9jVHlwZShubmV4cHIsIHVuZGVmaW5lZCwgdHlwZSk7XG4gICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlLlxuICAgICAgICB0aGlzLmVtaXQoJygoJyk7XG4gICAgICAgIHRoaXMud3JpdGVOb2RlKG5uZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy5lbWl0KCcpKScpO1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZVNwYW5TdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5RGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgIGNvbnN0IGRvY1RhZ3MgPSB0aGlzLmdldEpTRG9jKG5vZGUpIHx8IFtdO1xuICAgICAgICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKG5vZGUsIHRoaXMudHlwZUNoZWNrZXIpKSB7XG4gICAgICAgICAgZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnZXhwb3J0J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY1RhZ3MubGVuZ3RoID4gMCAmJiBub2RlLmdldEZpcnN0VG9rZW4oKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgICAgICAgdGhpcy5lbWl0KGpzZG9jLnRvU3RyaW5nKGRvY1RhZ3MpKTtcbiAgICAgICAgICBjb25zdCBpc1BvbHltZXJCZWhhdmlvciA9IGRvY1RhZ3Muc29tZSh0ID0+IHQudGFnTmFtZSA9PT0gJ3BvbHltZXJCZWhhdmlvcicpO1xuICAgICAgICAgIGlmIChpc1BvbHltZXJCZWhhdmlvcikge1xuICAgICAgICAgICAgdGhpcy5wb2x5bWVyQmVoYXZpb3JTdGFja0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3JpdGVOb2RlRnJvbShub2RlLCBub2RlLmdldFN0YXJ0KCkpO1xuICAgICAgICAgIGlmIChpc1BvbHltZXJCZWhhdmlvcikge1xuICAgICAgICAgICAgdGhpcy5wb2x5bWVyQmVoYXZpb3JTdGFja0NvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5QXNzaWdubWVudDpcbiAgICAgICAgY29uc3QgcGEgPSBub2RlIGFzIHRzLlByb3BlcnR5QXNzaWdubWVudDtcbiAgICAgICAgaWYgKGlzUG9seW1lckJlaGF2aW9yUHJvcGVydHlJbkNhbGxFeHByZXNzaW9uKHBhKSkge1xuICAgICAgICAgIHRoaXMucG9seW1lckJlaGF2aW9yU3RhY2tDb3VudCsrO1xuICAgICAgICAgIHRoaXMud3JpdGVOb2RlRnJvbShub2RlLCBub2RlLmdldFN0YXJ0KCkpO1xuICAgICAgICAgIHRoaXMucG9seW1lckJlaGF2aW9yU3RhY2tDb3VudC0tO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FbGVtZW50QWNjZXNzRXhwcmVzc2lvbjpcbiAgICAgICAgLy8gV2FybiBmb3IgcXVvdGVkIGFjY2Vzc2VzIHRvIHByb3BlcnRpZXMgdGhhdCBoYXZlIGEgc3ltYm9sIGRlY2xhcmVkLlxuICAgICAgICAvLyBNaXhpbmcgcXVvdGVkIGFuZCBub24tcXVvdGVkIGFjY2VzcyB0byBhIHN5bWJvbCAoeFsnZm9vJ10gYW5kIHguZm9vKSByaXNrcyBicmVha2luZ1xuICAgICAgICAvLyBDbG9zdXJlIENvbXBpbGVyIHJlbmFtaW5nLiBRdW90ZWQgYWNjZXNzIGlzIG1vcmUgY3VtYmVyc29tZSB0byB3cml0ZSB0aGFuIGRvdHRlZCBhY2Nlc3NcbiAgICAgICAgLy8gdGhvdWdoLCBzbyBjaGFuY2VzIGFyZSB1c2VycyBkaWQgaW50ZW5kIHRvIGF2b2lkIHJlbmFtaW5nLiBUaGUgYmV0dGVyIGZpeCBpcyB0byB1c2VcbiAgICAgICAgLy8gYGRlY2xhcmUgaW50ZXJmYWNlYCB0aG91Z2guXG4gICAgICAgIGNvbnN0IGVhZSA9IG5vZGUgYXMgdHMuRWxlbWVudEFjY2Vzc0V4cHJlc3Npb247XG4gICAgICAgIGlmICghZWFlLmFyZ3VtZW50RXhwcmVzc2lvbiB8fFxuICAgICAgICAgICAgZWFlLmFyZ3VtZW50RXhwcmVzc2lvbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVvdGVkUHJvcFN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihlYWUuYXJndW1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgc3ltYm9sLCBpdCdzIGFjdHVhbGx5IGEgcmVndWxhciBkZWNsYXJlZCBwcm9wZXJ0eS5cbiAgICAgICAgaWYgKCFxdW90ZWRQcm9wU3ltKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uSGFzUXVvdGVzID1cbiAgICAgICAgICAgICFxdW90ZWRQcm9wU3ltLmRlY2xhcmF0aW9ucyB8fCBxdW90ZWRQcm9wU3ltLmRlY2xhcmF0aW9ucy5zb21lKGQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBkZWNsID0gZCBhcyB0cy5OYW1lZERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgICBpZiAoIWRlY2wubmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVjbC5uYW1lLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgZGVjbGFyZWQgd2l0aCBxdW90ZXMsIGl0IHNob3VsZCBhbHNvIGJlIGFjY2Vzc2VkIHdpdGggdGhlbS5cbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uSGFzUXVvdGVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGVhZS5hcmd1bWVudEV4cHJlc3Npb24gYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICAgICAgLy8gUHJvcGVydGllcyBjb250YWluaW5nIG5vbi1KUyBpZGVudGlmaWVyIG5hbWVzIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIHdpdGggcXVvdGVzLlxuICAgICAgICBpZiAoIWlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKHByb3BOYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzeW1OYW1lID0gdGhpcy50eXBlQ2hlY2tlci5zeW1ib2xUb1N0cmluZyhxdW90ZWRQcm9wU3ltKTtcbiAgICAgICAgdGhpcy5kZWJ1Z1dhcm4oXG4gICAgICAgICAgICBlYWUsXG4gICAgICAgICAgICBgRGVjbGFyZWQgcHJvcGVydHkgJHtzeW1OYW1lfSBhY2Nlc3NlZCB3aXRoIHF1b3Rlcy4gYCArXG4gICAgICAgICAgICAgICAgYFRoaXMgY2FuIGxlYWQgdG8gcmVuYW1pbmcgYnVncy4gQSBiZXR0ZXIgZml4IGlzIHRvIHVzZSAnZGVjbGFyZSBpbnRlcmZhY2UnIGAgK1xuICAgICAgICAgICAgICAgIGBvbiB0aGUgZGVjbGFyYXRpb24uYCk7XG4gICAgICAgIC8vIFByZXZpb3VzbHksIHRoZSBjb2RlIGJlbG93IGNoYW5nZWQgdGhlIHF1b3RlZCBpbnRvIGEgbm9uLXF1b3RlZCBhY2Nlc3MuXG4gICAgICAgIC8vIHRoaXMud3JpdGVOb2RlKGVhZS5leHByZXNzaW9uKTtcbiAgICAgICAgLy8gdGhpcy5lbWl0KGAuJHtwcm9wTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbjpcbiAgICAgICAgLy8gQ29udmVydCBkb3R0ZWQgYWNjZXNzZXMgdG8gdHlwZXMgdGhhdCBoYXZlIGFuIGluZGV4IHR5cGUgZGVjbGFyZWQgdG8gcXVvdGVkIGFjY2Vzc2VzLCB0b1xuICAgICAgICAvLyBhdm9pZCBDbG9zdXJlIHJlbmFtaW5nIG9uZSBhY2Nlc3MgYnV0IG5vdCB0aGUgb3RoZXIuXG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBiZWNhdXNlIFRTIGFsbG93cyBkb3R0ZWQgYWNjZXNzIHRvIHN0cmluZyBpbmRleCB0eXBlcy5cbiAgICAgICAgY29uc3QgcGFlID0gbm9kZSBhcyB0cy5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb247XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKHBhZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCF0LmdldFN0cmluZ0luZGV4VHlwZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFR5cGVzIGNhbiBoYXZlIHN0cmluZyBpbmRleCBzaWduYXR1cmVzIGFuZCBkZWNsYXJlZCBwcm9wZXJ0aWVzIChvZiB0aGUgbWF0Y2hpbmcgdHlwZSkuXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgaGF2ZSBhIHN5bWJvbCwgYXMgb3Bwb3NlZCB0byBwdXJlIHN0cmluZyBpbmRleCB0eXBlcy5cbiAgICAgICAgY29uc3QgcHJvcFN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihwYWUubmFtZSk7XG4gICAgICAgIC8vIFRoZSBkZWNpc2lvbiB0byByZXR1cm4gYmVsb3cgaXMgYSBqdWRnZW1lbnQgY2FsbC4gUHJlc3VtYWJseSwgaW4gbW9zdCBzaXR1YXRpb25zLCBkb3R0ZWRcbiAgICAgICAgLy8gYWNjZXNzIHRvIGEgcHJvcGVydHkgaXMgY29ycmVjdCwgYW5kIHNob3VsZCBub3QgYmUgdHVybmVkIGludG8gcXVvdGVkIGFjY2VzcyBldmVuIGlmXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgc3RyaW5nIGluZGV4IG9uIHRoZSB0eXBlLiBIb3dldmVyIGl0IGlzIHBvc3NpYmxlIHRvIGNvbnN0cnVjdCBwcm9ncmFtcyB3aGVyZVxuICAgICAgICAvLyB0aGlzIGlzIGluY29ycmVjdCwgZS5nLiB3aGVyZSB1c2VyIGNvZGUgYXNzaWducyBpbnRvIGEgcHJvcGVydHkgdGhyb3VnaCB0aGUgaW5kZXggYWNjZXNzXG4gICAgICAgIC8vIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICAgIGlmIChwcm9wU3ltKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5kZWJ1Z1dhcm4oXG4gICAgICAgICAgICBwYWUsXG4gICAgICAgICAgICB0aGlzLnR5cGVDaGVja2VyLnR5cGVUb1N0cmluZyh0KSArXG4gICAgICAgICAgICAgICAgYCBoYXMgYSBzdHJpbmcgaW5kZXggdHlwZSBidXQgaXMgYWNjZXNzZWQgdXNpbmcgZG90dGVkIGFjY2Vzcy4gYCArXG4gICAgICAgICAgICAgICAgYFF1b3RpbmcgdGhlIGFjY2Vzcy5gKTtcbiAgICAgICAgdGhpcy53cml0ZU5vZGUocGFlLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ1tcIicpO1xuICAgICAgICB0aGlzLndyaXRlTm9kZShwYWUubmFtZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnXCJdJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkRlY29yYXRvcjpcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXIubWF5YmVQcm9jZXNzRGVjb3JhdG9yKG5vZGUgYXMgdHMuRGVjb3JhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRFbWl0RXhwb3J0U3ltYm9sKHN5bTogdHMuU3ltYm9sKTogYm9vbGVhbiB7XG4gICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSB7XG4gICAgICBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltKTtcbiAgICB9XG4gICAgaWYgKChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkgPT09IDApIHtcbiAgICAgIC8vIE5vdGU6IFdlIGNyZWF0ZSBleHBsaWNpdCByZWV4cG9ydHMgdmlhIGNsb3N1cmUgYXQgYW5vdGhlciBwbGFjZSBpblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQ29uc3RFbnVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTb3VyY2VGaWxlKHNmOiB0cy5Tb3VyY2VGaWxlKSB7XG4gICAgLy8gRW1pdCBsZWFkaW5nIGRldGFjaGVkIGNvbW1lbnRzOiBjb21tZW50cyBzZXBhcmF0ZWQgYnkgYSBcXG5cXG4gZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgLy8gV2hpbGUgaGFuZGxlcnMgYmVsb3cgZ2VuZXJhbGx5IGVtaXQgY29tbWVudHMgcHJlY2VkaW5nIHRoZW0sIG5vdCBhbGwgb2YgdGhlbSBkbyBpbiBhbGxcbiAgICAvLyBzaXR1YXRpb25zIChlLmcuIEpTRG9jIHByZWNlZGluZyBhIGNsYXNzKS5cbiAgICAvLyBUaGlzIGlzIHN5bW1ldHJpYyB3aXRoIGBnZXRKU0RvY2AgYmVsb3cgbm90IHJldHVybmluZyBkZXRhY2hlZCBmaWxlIGxldmVsIGNvbW1lbnRzLlxuICAgIGNvbnN0IGNvbW1lbnRzID0gdHMuZ2V0TGVhZGluZ0NvbW1lbnRSYW5nZXMoc2YudGV4dCwgMCkgfHwgW107XG4gICAgbGV0IHN0YXJ0ID0gc2YuZ2V0RnVsbFN0YXJ0KCk7XG4gICAgZm9yIChsZXQgaSA9IGNvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoc2YudGV4dC5zdWJzdHJpbmcoY29tbWVudHNbaV0uZW5kLCBjb21tZW50c1tpXS5lbmQgKyAyKSA9PT0gJ1xcblxcbicpIHtcbiAgICAgICAgdGhpcy5lbWl0KHNmLnRleHQuc3Vic3RyaW5nKDAsIGNvbW1lbnRzW2ldLmVuZCArIDIpKTtcbiAgICAgICAgc3RhcnQgPSBjb21tZW50c1tpXS5lbmQgKyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cml0ZU5vZGVGcm9tKHNmLCBzdGFydCk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBcImV4cG9ydCAqIGZyb20gLi4uXCIgc3RhdGVtZW50LCBnYXRoZXJzIHRoZSBzeW1ib2wgbmFtZXMgaXQgYWN0dWFsbHlcbiAgICogZXhwb3J0cyB0byBiZSB1c2VkIGluIGEgc3RhdGVtZW50IGxpa2UgXCJleHBvcnQge2ZvbywgYmFyLCBiYXp9IGZyb20gLi4uXCIuXG4gICAqXG4gICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgVFMgdHJhbnNwaWxlcyBcImV4cG9ydCAqXCIgYnkganVzdCBkb2luZyBhIHJ1bnRpbWUgbG9vcFxuICAgKiBvdmVyIHRoZSB0YXJnZXQgbW9kdWxlJ3MgZXhwb3J0cywgd2hpY2ggbWVhbnMgQ2xvc3VyZSB3b24ndCBzZWUgdGhlIGRlY2xhcmF0aW9ucy90eXBlc1xuICAgKiB0aGF0IGFyZSBleHBvcnRlZC5cbiAgICovXG4gIHByaXZhdGUgZXhwYW5kU3ltYm9sc0Zyb21FeHBvcnRTdGFyKGV4cG9ydERlY2w6IHRzLkV4cG9ydERlY2xhcmF0aW9uKTogTmFtZWRTeW1ib2xbXSB7XG4gICAgLy8gWW91IGNhbid0IGhhdmUgYW4gXCJleHBvcnQgKlwiIHdpdGhvdXQgYSBtb2R1bGUgc3BlY2lmaWVyLlxuICAgIGNvbnN0IG1vZHVsZVNwZWNpZmllciA9IGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyITtcblxuICAgIC8vIEdhdGhlciB0aGUgbmFtZXMgb2YgbG9jYWwgZXhwb3J0cywgdG8gYXZvaWQgcmVleHBvcnRpbmcgYW55XG4gICAgLy8gbmFtZXMgdGhhdCBhcmUgYWxyZWFkeSBsb2NhbGx5IGV4cG9ydGVkLlxuICAgIGNvbnN0IG1vZHVsZVN5bWJvbCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbih0aGlzLmZpbGUpO1xuICAgIGNvbnN0IG1vZHVsZUV4cG9ydHMgPSBtb2R1bGVTeW1ib2wgJiYgbW9kdWxlU3ltYm9sLmV4cG9ydHMgfHwgbmV3IE1hcDxzdHJpbmcsIHRzLlN5bWJvbD4oKTtcblxuICAgIC8vIEV4cGFuZCB0aGUgZXhwb3J0IGxpc3QsIHRoZW4gZmlsdGVyIGl0IHRvIHRoZSBzeW1ib2xzIHdlIHdhbnQgdG8gcmVleHBvcnQuXG4gICAgY29uc3QgZXhwb3J0cyA9XG4gICAgICAgIHRoaXMudHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKHRoaXMubXVzdEdldFN5bWJvbEF0TG9jYXRpb24obW9kdWxlU3BlY2lmaWVyKSk7XG4gICAgY29uc3QgcmVleHBvcnRzID0gbmV3IFNldDx0cy5TeW1ib2w+KCk7XG4gICAgZm9yIChjb25zdCBzeW0gb2YgZXhwb3J0cykge1xuICAgICAgY29uc3QgbmFtZSA9IHVuZXNjYXBlTmFtZShzeW0ubmFtZSk7XG4gICAgICBpZiAobW9kdWxlRXhwb3J0cyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBpZiAobW9kdWxlRXhwb3J0cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIG5hbWUgaXMgc2hhZG93ZWQgYnkgYSBsb2NhbCBkZWZpbml0aW9uLCBzdWNoIGFzOlxuICAgICAgICAgIC8vIC0gZXhwb3J0IHZhciBmb28gLi4uXG4gICAgICAgICAgLy8gLSBleHBvcnQge2Zvb30gZnJvbSAuLi5cbiAgICAgICAgICAvLyAtIGV4cG9ydCB7YmFyIGFzIGZvb30gZnJvbSAuLi5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETygjNjM0KTogY2hlY2sgaWYgdGhpcyBpcyBhIHNhZmUgY2FzdC5cbiAgICAgICAgaWYgKG1vZHVsZUV4cG9ydHMuaGFzKG5hbWUgYXMgdHMuX19TdHJpbmcpKSBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmdlbmVyYXRlZEV4cG9ydHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIC8vIEFscmVhZHkgZXhwb3J0ZWQgdmlhIGFuIGVhcmxpZXIgZXhwYW5zaW9uIG9mIGFuIFwiZXhwb3J0ICogZnJvbSAuLi5cIi5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmdlbmVyYXRlZEV4cG9ydHMuYWRkKG5hbWUpO1xuICAgICAgcmVleHBvcnRzLmFkZChzeW0pO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShyZWV4cG9ydHMua2V5cygpKS5tYXAoc3ltID0+IHtcbiAgICAgIHJldHVybiB7bmFtZTogc3ltLm5hbWUsIHN5bX07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYW4gYGV4cG9ydHMuYCBhc3NpZ25tZW50IGZvciBlYWNoIHR5cGUgYWxpYXMgZXhwb3J0ZWQgaW4gdGhlIGdpdmVuIGBleHBvcnRzYC5cbiAgICogVHlwZVNjcmlwdCBieSBpdHNlbGYgZG9lcyBub3QgZXhwb3J0IG5vbi12YWx1ZSBzeW1ib2xzIChlLmcuIGludGVyZmFjZXMsIHR5cGVkZWZzKSwgYXMgaXRcbiAgICogZXhwZWN0cyB0byByZW1vdmUgdGhvc2UgZW50aXJlbHkgZm9yIHJ1bnRpbWUuIEZvciBDbG9zdXJlLCB0eXBlcyBtdXN0IGJlXG4gICAqIGV4cG9ydGVkIGFzIGRvd25zdHJlYW0gY29kZSB3aWxsIGltcG9ydCB0aGUgdHlwZS5cbiAgICpcbiAgICogVGhlIHRzaWNrbGUgcGFzcyB0dXJucyBpbnRlcmZhY2VzIGludG8gdmFsdWVzIGJ5IGdlbmVyYXRpbmcgYSBgZnVuY3Rpb24gTXlJbnRlcmZhY2UoKSB7fWAgZm9yXG4gICAqIHRoZW0sIHNvIGluIHRoZSBzZWNvbmQgY29udmVyc2lvbiBwYXNzLCBUeXBlU2NyaXB0IGRvZXMgZXhwb3J0IGEgdmFsdWUgZm9yIHRoZW0uIEhvd2V2ZXIgZm9yXG4gICAqIHB1cmUgdHlwZWRlZnMsIHRzaWNrbGUgb25seSBnZW5lcmF0ZXMgYSBwcm9wZXJ0eSBhY2Nlc3Mgd2l0aCBhIEpTRG9jIGNvbW1lbnQsIHNvIHRoZXkgbmVlZCB0b1xuICAgKiBiZSBleHBvcnRlZCBleHBsaWNpdGx5IGhlcmUuXG4gICAqL1xuICBwcml2YXRlIGVtaXRUeXBlRGVmRXhwb3J0cyhleHBvcnRzOiBOYW1lZFN5bWJvbFtdKSB7XG4gICAgaWYgKHRoaXMuaG9zdC51bnR5cGVkKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBleHAgb2YgZXhwb3J0cykge1xuICAgICAgaWYgKGV4cC5zeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcylcbiAgICAgICAgZXhwLnN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChleHAuc3ltKTtcbiAgICAgIGNvbnN0IGlzVHlwZUFsaWFzID0gKChleHAuc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZUFsaWFzKSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4cC5zeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkgPT09IDApIHx8XG4gICAgICAgICAgKGV4cC5zeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5JbnRlcmZhY2UpICE9PSAwICYmXG4gICAgICAgICAgICAgIChleHAuc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpID09PSAwO1xuICAgICAgaWYgKCFpc1R5cGVBbGlhcykgY29udGludWU7XG4gICAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLmdldChleHAuc3ltKSB8fCBleHAuc3ltLm5hbWU7XG4gICAgICB0aGlzLmVtaXQoYFxcbi8qKiBAdHlwZWRlZiB7JHt0eXBlTmFtZX19ICovXFxuZXhwb3J0cy4ke2V4cC5uYW1lfTsgLy8gcmUtZXhwb3J0IHR5cGVkZWZgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBmcm9tIGltcGxpY2l0IGBpbXBvcnQge30gZnJvbSAncGtnJ2AgdG8gYGltcG9ydCB7fSBmcm9tICdwa2cvaW5kZXgnLlxuICAgKiBUeXBlU2NyaXB0IHN1cHBvcnRzIHRoZSBzaG9ydGhhbmQsIGJ1dCBub3QgYWxsIEVTNiBtb2R1bGUgbG9hZGVycyBkby5cbiAgICogV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMjU5N1xuICAgKi9cbiAgcHJpdmF0ZSByZXNvbHZlTW9kdWxlU3BlY2lmaWVyKG1vZHVsZVNwZWNpZmllcjogdHMuRXhwcmVzc2lvbik6IHN0cmluZyB7XG4gICAgaWYgKG1vZHVsZVNwZWNpZmllci5raW5kICE9PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIG1vZHVsZVNwZWNpZmllciBraW5kOiAke3RzLlN5bnRheEtpbmRbbW9kdWxlU3BlY2lmaWVyLmtpbmRdfWApO1xuICAgIH1cbiAgICBsZXQgbW9kdWxlSWQgPSAobW9kdWxlU3BlY2lmaWVyIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgaWYgKHRoaXMuaG9zdC5jb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQpIHtcbiAgICAgIGlmICghdGhpcy50c09wdHMgfHwgIXRoaXMudHNIb3N0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvcHRpb24gY29udmVydEluZGV4SW1wb3J0U2hvcnRoYW5kIHJlcXVpcmVzIHRoYXQgYW5ub3RhdGUgYmUgY2FsbGVkIHdpdGggYSBUeXBlU2NyaXB0IGhvc3QgYW5kIG9wdGlvbnMuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHRzLnJlc29sdmVNb2R1bGVOYW1lKG1vZHVsZUlkLCB0aGlzLmZpbGUuZmlsZU5hbWUsIHRoaXMudHNPcHRzLCB0aGlzLnRzSG9zdCk7XG4gICAgICBpZiAocmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkTW9kdWxlID0gbW9kdWxlSWQucmVwbGFjZShleHRlbnNpb24sICcnKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRNb2R1bGUgPSByZXNvbHZlZC5yZXNvbHZlZE1vZHVsZS5yZXNvbHZlZEZpbGVOYW1lLnJlcGxhY2UoZXh0ZW5zaW9uLCAnJyk7XG4gICAgICAgIGlmIChyZXNvbHZlZE1vZHVsZS5pbmRleE9mKCdub2RlX21vZHVsZXMnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIHJlcXVlc3RlZE1vZHVsZS5zdWJzdHIocmVxdWVzdGVkTW9kdWxlLmxhc3RJbmRleE9mKCcvJykpICE9PVxuICAgICAgICAgICAgICAgIHJlc29sdmVkTW9kdWxlLnN1YnN0cihyZXNvbHZlZE1vZHVsZS5sYXN0SW5kZXhPZignLycpKSkge1xuICAgICAgICAgIG1vZHVsZUlkID0gJy4vJyArXG4gICAgICAgICAgICAgIHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKHRoaXMuZmlsZS5maWxlTmFtZSksIHJlc29sdmVkTW9kdWxlKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocGF0aC5zZXAsICcvJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZW1pdCBvZiBhbiBcImltcG9ydCAuLi5cIiBzdGF0ZW1lbnQuXG4gICAqIFdlIG5lZWQgdG8gZG8gYSBiaXQgb2YgcmV3cml0aW5nIHNvIHRoYXQgaW1wb3J0ZWQgdHlwZXMgc2hvdyB1cCB1bmRlciB0aGVcbiAgICogY29ycmVjdCBuYW1lIGluIEpTRG9jLlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGRlY2wgd2FzIGhhbmRsZWQsIGZhbHNlIHRvIGFsbG93IGRlZmF1bHQgcHJvY2Vzc2luZy5cbiAgICovXG4gIHByaXZhdGUgZW1pdEltcG9ydERlY2xhcmF0aW9uKGRlY2w6IHRzLkltcG9ydERlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gICAgdGhpcy53cml0ZUxlYWRpbmdUcml2aWEoZGVjbCk7XG4gICAgdGhpcy5lbWl0KCdpbXBvcnQnKTtcbiAgICBjb25zdCBpbXBvcnRQYXRoID0gdGhpcy5yZXNvbHZlTW9kdWxlU3BlY2lmaWVyKGRlY2wubW9kdWxlU3BlY2lmaWVyKTtcbiAgICBjb25zdCBpbXBvcnRDbGF1c2UgPSBkZWNsLmltcG9ydENsYXVzZTtcbiAgICBpZiAoIWltcG9ydENsYXVzZSkge1xuICAgICAgLy8gaW1wb3J0ICcuL2Zvbyc7XG4gICAgICB0aGlzLmVtaXQoYCcke2ltcG9ydFBhdGh9JztgKTtcbiAgICAgIHRoaXMuYWRkU291cmNlTWFwcGluZyhkZWNsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGltcG9ydENsYXVzZS5uYW1lIHx8XG4gICAgICAgIChpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncyAmJlxuICAgICAgICAgaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3Mua2luZCA9PT0gdHMuU3ludGF4S2luZC5OYW1lZEltcG9ydHMpKSB7XG4gICAgICB0aGlzLnZpc2l0KGltcG9ydENsYXVzZSk7XG4gICAgICB0aGlzLmVtaXQoYCBmcm9tICcke2ltcG9ydFBhdGh9JztgKTtcbiAgICAgIHRoaXMuYWRkU291cmNlTWFwcGluZyhkZWNsKTtcblxuICAgICAgLy8gaW1wb3J0Q2xhdXNlLm5hbWUgaW1wbGllc1xuICAgICAgLy8gICBpbXBvcnQgYSBmcm9tIC4uLjtcbiAgICAgIC8vIG5hbWVkQmluZGluZ3MgYmVpbmcgTmFtZWRJbXBvcnRzIGltcGxpZXNcbiAgICAgIC8vICAgaW1wb3J0IHthIGFzIGJ9IGZyb20gLi4uO1xuICAgICAgLy9cbiAgICAgIC8vIEJvdGggb2YgdGhlc2UgZm9ybXMgY3JlYXRlIGEgbG9jYWwgbmFtZSBcImFcIiwgd2hpY2ggYWZ0ZXIgVHlwZVNjcmlwdCBDb21tb25KUyBjb21waWxhdGlvblxuICAgICAgLy8gd2lsbCBiZWNvbWUgc29tZSByZW5hbWVkIHZhcmlhYmxlIGxpa2UgXCJtb2R1bGVfMS5kZWZhdWx0XCIgb3IgXCJtb2R1bGVfMS5hXCIgKGZvciBkZWZhdWx0IHZzXG4gICAgICAvLyBuYW1lZCBiaW5kaW5ncywgcmVzcGVjdGl2ZWx5KS5cbiAgICAgIC8vIHRzaWNrbGUgcmVmZXJlbmNlcyB0eXBlcyBpbiBKU0RvYy4gQmVjYXVzZSB0aGUgbW9kdWxlIHByZWZpeGVzIGFyZSBub3QgcHJlZGljdGFibGUsIGFuZFxuICAgICAgLy8gYmVjYXVzZSBUeXBlU2NyaXB0IG1pZ2h0IHJlbW92ZSBpbXBvcnRzIGVudGlyZWx5IGlmIHRoZXkgYXJlIG9ubHkgZm9yIHR5cGVzLCB0aGUgY29kZSBiZWxvd1xuICAgICAgLy8gaW5zZXJ0cyBhbiBhcnRpZmljaWFsIGBjb25zdCBwcmVmaXggPSBnb29nLmZvcndhcmREZWNsYXJlYCBjYWxsIGZvciB0aGUgbW9kdWxlLCBhbmQgdGhlblxuICAgICAgLy8gcmVnaXN0ZXJzIGFsbCBzeW1ib2xzIGZyb20gdGhpcyBpbXBvcnQgdG8gYmUgcHJlZml4ZWQuXG4gICAgICBpZiAoIXRoaXMuaG9zdC51bnR5cGVkKSB7XG4gICAgICAgIGxldCBzeW1ib2xzOiBOYW1lZFN5bWJvbFtdID0gW107XG4gICAgICAgIGlmIChpbXBvcnRDbGF1c2UubmFtZSkge1xuICAgICAgICAgIC8vIGltcG9ydCBhIGZyb20gLi4uO1xuICAgICAgICAgIHN5bWJvbHMgPSBbe1xuICAgICAgICAgICAgbmFtZTogZ2V0SWRlbnRpZmllclRleHQoaW1wb3J0Q2xhdXNlLm5hbWUpLFxuICAgICAgICAgICAgc3ltOiB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGltcG9ydENsYXVzZS5uYW1lKSxcbiAgICAgICAgICB9XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbXBvcnQge2EgYXMgYn0gZnJvbSAuLi47XG4gICAgICAgICAgaWYgKCFpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncyB8fFxuICAgICAgICAgICAgICBpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncy5raW5kICE9PSB0cy5TeW50YXhLaW5kLk5hbWVkSW1wb3J0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoZWQnKTsgIC8vIEd1YXJhbnRlZWQgYnkgaWYgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgfVxuICAgICAgICAgIHN5bWJvbHMgPSB0aGlzLmdldE5hbWVkU3ltYm9scyhpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncy5lbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3J3YXJkRGVjbGFyZShkZWNsLm1vZHVsZVNwZWNpZmllciwgc3ltYm9scywgISFpbXBvcnRDbGF1c2UubmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncyAmJlxuICAgICAgICBpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncy5raW5kID09PSB0cy5TeW50YXhLaW5kLk5hbWVzcGFjZUltcG9ydCkge1xuICAgICAgLy8gaW1wb3J0ICogYXMgZm9vIGZyb20gLi4uO1xuICAgICAgdGhpcy52aXNpdChpbXBvcnRDbGF1c2UpO1xuICAgICAgdGhpcy5lbWl0KGAgZnJvbSAnJHtpbXBvcnRQYXRofSc7YCk7XG4gICAgICB0aGlzLmFkZFNvdXJjZU1hcHBpbmcoZGVjbCk7XG5cbiAgICAgIC8vIEludHJvZHVjZSBhIGdvb2cuZm9yd2FyZERlY2xhcmUgZm9yIHRoZSBtb2R1bGUsIHNvIHRoYXQgaWYgVHlwZVNjcmlwdCBkb2VzIG5vdCBlbWl0IHRoZVxuICAgICAgLy8gbW9kdWxlIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgaW4gdHlwZSBwb3NpdGlvbnMsIHRoZSBKU0RvYyBjb21tZW50cyBzdGlsbCByZWZlcmVuY2UgYSB2YWxpZFxuICAgICAgLy8gQ2xvc3VyZSBsZXZlbCBzeW1ib2wuXG4gICAgICBjb25zdCBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oZGVjbC5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgaWYgKCFzeW0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7ICAvLyBtb2R1bGVzIG1pZ2h0IG5vdCBoYXZlIGEgc3ltYm9sIGlmIHRoZXkgYXJlIHVudXNlZC5cbiAgICAgIH1cbiAgICAgIC8vIGZvcndhcmREZWNsYXJlIGFsbCBzeW1ib2xzIHRoYXQgY2FuIGJlIGltcG9ydGVkIGZyb20gdGhlIG1vZHVsZS5cbiAgICAgIGNvbnN0IG5hbWVkU3ltcyA9XG4gICAgICAgICAgdGhpcy50eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUoc3ltKS5tYXAoc3ltID0+ICh7bmFtZTogc3ltLm5hbWUsIHN5bX0pKTtcbiAgICAgIHRoaXMuZm9yd2FyZERlY2xhcmUoZGVjbC5tb2R1bGVTcGVjaWZpZXIsIG5hbWVkU3ltcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXJyb3JVbmltcGxlbWVudGVkS2luZChkZWNsLCAndW5leHBlY3RlZCBraW5kIG9mIGltcG9ydCcpO1xuICAgICAgcmV0dXJuIGZhbHNlOyAgLy8gVXNlIGRlZmF1bHQgcHJvY2Vzc2luZy5cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE5hbWVkU3ltYm9scyhzcGVjaWZpZXJzOiBSZWFkb25seUFycmF5PHRzLkltcG9ydFNwZWNpZmllcnx0cy5FeHBvcnRTcGVjaWZpZXI+KTpcbiAgICAgIE5hbWVkU3ltYm9sW10ge1xuICAgIHJldHVybiBzcGVjaWZpZXJzLm1hcChlID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGUubmFtZSBtaWdodCBiZSByZW5hbWluZyBzeW1ib2wgYXMgaW4gYGV4cG9ydCB7Rm9vIGFzIEJhcn1gLCB3aGVyZSBlLm5hbWUgd291bGQgYmUgJ0JhcidcbiAgICAgICAgLy8gYW5kICE9IHN5bS5uYW1lLiBTdG9yZSBhd2F5IHRoZSBuYW1lIHNvIGZvcndhcmREZWNsYXJlIGJlbG93IGNhbiBlbWl0IHRoZSByaWdodCBuYW1lLlxuICAgICAgICBuYW1lOiBnZXRJZGVudGlmaWVyVGV4dChlLm5hbWUpLFxuICAgICAgICBzeW06IHRoaXMubXVzdEdldFN5bWJvbEF0TG9jYXRpb24oZS5uYW1lKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZvcndhcmREZWNsYXJlQ291bnRlciA9IDA7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgYGdvb2cuZm9yd2FyZERlY2xhcmVgIGFsaWFzIGZvciBlYWNoIHN5bWJvbCBmcm9tIHRoZSBnaXZlbiBsaXN0LlxuICAgKiBAcGFyYW0gc3BlY2lmaWVyIHRoZSBpbXBvcnQgc3BlY2lmaWVyLCBpLmUuIG1vZHVsZSBwYXRoIChcImZyb20gJy4uLidcIikuXG4gICAqL1xuICBwcml2YXRlIGZvcndhcmREZWNsYXJlKFxuICAgICAgc3BlY2lmaWVyOiB0cy5FeHByZXNzaW9uLCBleHBvcnRlZFN5bWJvbHM6IE5hbWVkU3ltYm9sW10sIGlzRGVmYXVsdEltcG9ydCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaG9zdC51bnR5cGVkKSByZXR1cm47XG4gICAgY29uc3QgaW1wb3J0UGF0aCA9IHRoaXMucmVzb2x2ZU1vZHVsZVNwZWNpZmllcihzcGVjaWZpZXIpO1xuICAgIGNvbnN0IG5zSW1wb3J0ID0gZXM1cHJvY2Vzc29yLmV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KGltcG9ydFBhdGgpO1xuICAgIGNvbnN0IGZvcndhcmREZWNsYXJlUHJlZml4ID0gYHRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXyR7Kyt0aGlzLmZvcndhcmREZWNsYXJlQ291bnRlcn1gO1xuICAgIGNvbnN0IG1vZHVsZU5hbWVzcGFjZSA9XG4gICAgICAgIG5zSW1wb3J0ICE9PSBudWxsID8gbnNJbXBvcnQgOiB0aGlzLmhvc3QucGF0aFRvTW9kdWxlTmFtZSh0aGlzLmZpbGUuZmlsZU5hbWUsIGltcG9ydFBhdGgpO1xuICAgIGNvbnN0IG1vZHVsZVN5bWJvbCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzcGVjaWZpZXIpO1xuICAgIC8vIFNjcmlwdHMgZG8gbm90IGhhdmUgYSBzeW1ib2wuIFNjcmlwdHMgY2FuIHN0aWxsIGJlIGltcG9ydGVkLCBlaXRoZXIgYXMgc2lkZSBlZmZlY3QgaW1wb3J0cyBvclxuICAgIC8vIHdpdGggYW4gZW1wdHkgaW1wb3J0IHNldCAoXCJ7fVwiKS4gVHlwZVNjcmlwdCBkb2VzIG5vdCBlbWl0IGEgcnVudGltZSBsb2FkIGZvciBhbiBpbXBvcnQgd2l0aFxuICAgIC8vIGFuIGVtcHR5IGxpc3Qgb2Ygc3ltYm9scywgYnV0IHRoZSBpbXBvcnQgZm9yY2VzIGFueSBnbG9iYWwgZGVjbGFyYXRpb25zIGZyb20gdGhlIGxpYnJhcnkgdG9cbiAgICAvLyBiZSB2aXNpYmxlLCB3aGljaCBpcyB3aGF0IHVzZXJzIHVzZSB0aGlzIGZvci4gTm8gc3ltYm9scyBmcm9tIHRoZSBzY3JpcHQgbmVlZCBmb3J3YXJkXG4gICAgLy8gZGVjbGFyYXRpb24sIHNvIGp1c3QgcmV0dXJuLlxuICAgIGlmICghbW9kdWxlU3ltYm9sKSByZXR1cm47XG4gICAgY29uc3QgZXhwb3J0cyA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKG1vZHVsZVN5bWJvbCk7XG4gICAgLy8gSW4gVHlwZVNjcmlwdCwgaW1wb3J0aW5nIGEgbW9kdWxlIGZvciB1c2UgaW4gYSB0eXBlIGFubm90YXRpb24gZG9lcyBub3QgY2F1c2UgYSBydW50aW1lIGxvYWQuXG4gICAgLy8gSW4gQ2xvc3VyZSBDb21waWxlciwgZ29vZy5yZXF1aXJlJ2luZyBhIG1vZHVsZSBjYXVzZXMgYSBydW50aW1lIGxvYWQsIHNvIGVtaXR0aW5nIHJlcXVpcmVzXG4gICAgLy8gaGVyZSB3b3VsZCBjYXVzZSBhIGNoYW5nZSBpbiBsb2FkIG9yZGVyLCB3aGljaCBpcyBvYnNlcnZhYmxlIChhbmQgY2FuIGxlYWQgdG8gZXJyb3JzKS5cbiAgICAvLyBJbnN0ZWFkLCBnb29nLmZvcndhcmREZWNsYXJlIHR5cGVzLCB3aGljaCBhbGxvd3MgdXNpbmcgdGhlbSBpbiB0eXBlIGFubm90YXRpb25zIHdpdGhvdXRcbiAgICAvLyBjYXVzaW5nIGEgbG9hZC4gU2VlIGJlbG93IGZvciB0aGUgZXhjZXB0aW9uIHRvIHRoZSBydWxlLlxuICAgIHRoaXMuZW1pdChgXFxuY29uc3QgJHtmb3J3YXJkRGVjbGFyZVByZWZpeH0gPSBnb29nLmZvcndhcmREZWNsYXJlKFwiJHttb2R1bGVOYW1lc3BhY2V9XCIpO2ApO1xuICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGV4cG9ydHMuc29tZShlID0+IChlLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpICE9PSAwKTtcbiAgICBpZiAoIWhhc1ZhbHVlcykge1xuICAgICAgLy8gQ2xvc3VyZSBDb21waWxlcidzIHRvb2xjaGFpbiB3aWxsIGRyb3AgZmlsZXMgdGhhdCBhcmUgbmV2ZXIgZ29vZy5yZXF1aXJlJ2QgKmJlZm9yZSogdHlwZVxuICAgICAgLy8gY2hlY2tpbmcgKGUuZy4gd2hlbiB1c2luZyAtLWNsb3N1cmVfZW50cnlfcG9pbnQgb3Igc2ltaWxhciB0b29scykuIFRoaXMgY2F1c2VzIGVycm9yc1xuICAgICAgLy8gY29tcGxhaW5pbmcgYWJvdXQgdmFsdWVzIG5vdCBtYXRjaGluZyAnTm9SZXNvbHZlZFR5cGUnLCBvciBtb2R1bGVzIG5vdCBoYXZpbmcgYSBjZXJ0YWluXG4gICAgICAvLyBtZW1iZXIuXG4gICAgICAvLyBUbyBmaXgsIGV4cGxpY2l0bHkgZ29vZy5yZXF1aXJlKCkgbW9kdWxlcyB0aGF0IG9ubHkgZXhwb3J0IHR5cGVzLiBUaGlzIHNob3VsZCB1c3VhbGx5IG5vdFxuICAgICAgLy8gY2F1c2UgYnJlYWthZ2VzIGR1ZSB0byBsb2FkIG9yZGVyIChhcyBubyBzeW1ib2xzIGFyZSBhY2Nlc3NpYmxlIGZyb20gdGhlIG1vZHVsZSAtIHRob3VnaFxuICAgICAgLy8gY29udHJpdmVkIGNvZGUgY291bGQgb2JzZXJ2ZSBjaGFuZ2VzIGluIHNpZGUgZWZmZWN0cykuXG4gICAgICAvLyBUaGlzIGlzIGEgaGV1cmlzdGljIC0gaWYgdGhlIG1vZHVsZSBleHBvcnRzIHNvbWUgdmFsdWVzLCBidXQgdGhvc2UgYXJlIG5ldmVyIGltcG9ydGVkLFxuICAgICAgLy8gdGhlIGZpbGUgd2lsbCBzdGlsbCBlbmQgdXAgbm90IGJlaW5nIGltcG9ydGVkLiBIb3BlZnVsbHkgbW9kdWxlcyB0aGF0IGV4cG9ydCB2YWx1ZXMgYXJlXG4gICAgICAvLyBpbXBvcnRlZCBmb3IgdGhlaXIgdmFsdWUgaW4gc29tZSBwbGFjZS5cbiAgICAgIHRoaXMuZW1pdChgXFxuZ29vZy5yZXF1aXJlKFwiJHttb2R1bGVOYW1lc3BhY2V9XCIpOyAvLyBmb3JjZSB0eXBlLW9ubHkgbW9kdWxlIHRvIGJlIGxvYWRlZGApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4cCBvZiBleHBvcnRlZFN5bWJvbHMpIHtcbiAgICAgIGlmIChleHAuc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpXG4gICAgICAgIGV4cC5zeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woZXhwLnN5bSk7XG4gICAgICAvLyBnb29nOiBpbXBvcnRzIGRvbid0IGFjdHVhbGx5IHVzZSB0aGUgLmRlZmF1bHQgcHJvcGVydHkgdGhhdCBUUyB0aGlua3MgdGhleSBoYXZlLlxuICAgICAgY29uc3QgcXVhbGlmaWVkTmFtZSA9IG5zSW1wb3J0ICYmIGlzRGVmYXVsdEltcG9ydCA/IGZvcndhcmREZWNsYXJlUHJlZml4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkRGVjbGFyZVByZWZpeCArICcuJyArIGV4cC5zeW0ubmFtZTtcbiAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLnNldChleHAuc3ltLCBxdWFsaWZpZWROYW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZpc2l0Q2xhc3NEZWNsYXJhdGlvbihjbGFzc0RlY2w6IHRzLkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLmFkZFNvdXJjZU1hcHBpbmcoY2xhc3NEZWNsKTtcbiAgICBjb25zdCBvbGREZWNvcmF0b3JDb252ZXJ0ZXIgPSB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXI7XG4gICAgdGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyID1cbiAgICAgICAgbmV3IGRlY29yYXRvci5EZWNvcmF0b3JDbGFzc1Zpc2l0b3IodGhpcy50eXBlQ2hlY2tlciwgdGhpcywgY2xhc3NEZWNsLCB0aGlzLmltcG9ydGVkTmFtZXMpO1xuXG4gICAgY29uc3QgZG9jVGFncyA9IHRoaXMuZ2V0SlNEb2MoY2xhc3NEZWNsKSB8fCBbXTtcbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKGNsYXNzRGVjbCwgdHMuTW9kaWZpZXJGbGFncy5BYnN0cmFjdCkpIHtcbiAgICAgIGRvY1RhZ3MucHVzaCh7dGFnTmFtZTogJ2Fic3RyYWN0J30pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ob3N0LnVudHlwZWQpIHtcbiAgICAgIHRoaXMubWF5YmVBZGRUZW1wbGF0ZUNsYXVzZShkb2NUYWdzLCBjbGFzc0RlY2wpO1xuICAgICAgdGhpcy5tYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhkb2NUYWdzLCBjbGFzc0RlY2wpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgaWYgKGRvY1RhZ3MubGVuZ3RoID4gMCkgdGhpcy5lbWl0KGpzZG9jLnRvU3RyaW5nKGRvY1RhZ3MpKTtcbiAgICBkZWNvcmF0b3IudmlzaXRDbGFzc0NvbnRlbnRJbmNsdWRpbmdEZWNvcmF0b3JzKGNsYXNzRGVjbCwgdGhpcywgdGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyKTtcbiAgICB0aGlzLmVtaXRUeXBlQW5ub3RhdGlvbnNIZWxwZXIoY2xhc3NEZWNsKTtcblxuICAgIHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlciA9IG9sZERlY29yYXRvckNvbnZlcnRlcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEludGVyZmFjZShpZmFjZTogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcbiAgICAvLyBJZiB0aGlzIHN5bWJvbCBpcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgd2UgY2Fubm90IGVtaXQgYm90aCBpbnRvIENsb3N1cmUnc1xuICAgIC8vIHNpbmdsZSBuYW1lc3BhY2UuXG4gICAgY29uc3Qgc3ltID0gdGhpcy5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihpZmFjZS5uYW1lKTtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpIHJldHVybjtcblxuICAgIGNvbnN0IGRvY1RhZ3MgPSB0aGlzLmdldEpTRG9jKGlmYWNlKSB8fCBbXTtcbiAgICBkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdyZWNvcmQnfSk7XG4gICAgaWYgKCF0aGlzLmhvc3QudW50eXBlZCkge1xuICAgICAgdGhpcy5tYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGRvY1RhZ3MsIGlmYWNlKTtcbiAgICAgIHRoaXMubWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMoZG9jVGFncywgaWZhY2UpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgdGhpcy5lbWl0KGpzZG9jLnRvU3RyaW5nKGRvY1RhZ3MpKTtcblxuICAgIGlmIChoYXNNb2RpZmllckZsYWcoaWZhY2UsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSkgdGhpcy5lbWl0KCdleHBvcnQgJyk7XG4gICAgY29uc3QgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGlmYWNlLm5hbWUpO1xuICAgIHRoaXMuZW1pdChgZnVuY3Rpb24gJHtuYW1lfSgpIHt9XFxuYCk7XG5cbiAgICB0aGlzLmVtaXQoYFxcblxcbmZ1bmN0aW9uICR7bmFtZX1fdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcXG5gKTtcbiAgICBjb25zdCBtZW1iZXJOYW1lc3BhY2UgPSBbbmFtZSwgJ3Byb3RvdHlwZSddO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBpZmFjZS5tZW1iZXJzKSB7XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gZWxlbS5xdWVzdGlvblRva2VuICE9IG51bGw7XG4gICAgICB0aGlzLnZpc2l0UHJvcGVydHkobWVtYmVyTmFtZXNwYWNlLCBlbGVtLCBpc09wdGlvbmFsKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KGB9XFxuYCk7XG4gIH1cblxuICAvKipcbiAgICogZW1pdFR5cGVBbm5vdGF0aW9uc0hlbHBlciBwcm9kdWNlcyBhIF90c2lja2xlX3R5cGVBbm5vdGF0aW9uc0hlbHBlcigpIHdoZXJlXG4gICAqIG5vbmUgZXhpc3RlZCBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiBJdCdzIG5lY2Vzc2FyeSBpbiB0aGUgY2FzZSB3aGVyZVxuICAgKiBUeXBlU2NyaXB0IHN5bnRheCBzcGVjaWZpZXMgdGhlcmUgYXJlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvbiB0aGUgY2xhc3MsXG4gICAqIGJlY2F1c2UgdG8gZGVjbGFyZSB0aGVzZSBpbiBDbG9zdXJlIHlvdSBtdXN0IGRlY2xhcmUgdGhlc2UgaW4gYSBtZXRob2RcbiAgICogc29tZXdoZXJlLlxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0VHlwZUFubm90YXRpb25zSGVscGVyKGNsYXNzRGVjbDogdHMuQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgIC8vIEdhdGhlciBwYXJhbWV0ZXIgcHJvcGVydGllcyBmcm9tIHRoZSBjb25zdHJ1Y3RvciwgaWYgaXQgZXhpc3RzLlxuICAgIGNvbnN0IGN0b3JzOiB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uW10gPSBbXTtcbiAgICBsZXQgcGFyYW1Qcm9wczogdHMuUGFyYW1ldGVyRGVjbGFyYXRpb25bXSA9IFtdO1xuICAgIGNvbnN0IG5vblN0YXRpY1Byb3BzOiB0cy5Qcm9wZXJ0eURlY2xhcmF0aW9uW10gPSBbXTtcbiAgICBjb25zdCBzdGF0aWNQcm9wczogdHMuUHJvcGVydHlEZWNsYXJhdGlvbltdID0gW107XG4gICAgY29uc3QgYWJzdHJhY3RNZXRob2RzOiB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbltdID0gW107XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgY2xhc3NEZWNsLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3Rvcikge1xuICAgICAgICBjdG9ycy5wdXNoKG1lbWJlciBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBwcm9wID0gbWVtYmVyIGFzIHRzLlByb3BlcnR5RGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IGlzU3RhdGljID0gaGFzTW9kaWZpZXJGbGFnKHByb3AsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKTtcbiAgICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgICAgc3RhdGljUHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub25TdGF0aWNQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGhhc01vZGlmaWVyRmxhZyhtZW1iZXIsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpICYmXG4gICAgICAgICAgKG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uIHx8XG4gICAgICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLkdldEFjY2Vzc29yIHx8XG4gICAgICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLlNldEFjY2Vzc29yKSkge1xuICAgICAgICBhYnN0cmFjdE1ldGhvZHMucHVzaChcbiAgICAgICAgICAgIG1lbWJlciBhcyB0cy5NZXRob2REZWNsYXJhdGlvbiB8IHRzLkdldEFjY2Vzc29yRGVjbGFyYXRpb24gfCB0cy5TZXRBY2Nlc3NvckRlY2xhcmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3RvciA9IGN0b3JzWzBdO1xuICAgICAgcGFyYW1Qcm9wcyA9IGN0b3IucGFyYW1ldGVycy5maWx0ZXIocCA9PiBoYXNNb2RpZmllckZsYWcocCwgRklFTERfREVDTEFSQVRJT05fTU9ESUZJRVJTKSk7XG4gICAgfVxuXG4gICAgaWYgKG5vblN0YXRpY1Byb3BzLmxlbmd0aCA9PT0gMCAmJiBwYXJhbVByb3BzLmxlbmd0aCA9PT0gMCAmJiBzdGF0aWNQcm9wcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgYWJzdHJhY3RNZXRob2RzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAhKHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlciAmJiB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXIuZm91bmREZWNvcmF0b3JzKCkpKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgbm8gbWVtYmVycyBzbyB3ZSBkb24ndCBuZWVkIHRvIGVtaXQgYW55IHR5cGVcbiAgICAgIC8vIGFubm90YXRpb25zIGhlbHBlci5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNsYXNzRGVjbC5uYW1lKSByZXR1cm47XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZ2V0SWRlbnRpZmllclRleHQoY2xhc3NEZWNsLm5hbWUpO1xuXG4gICAgdGhpcy5lbWl0KGBcXG5cXG5mdW5jdGlvbiAke2NsYXNzTmFtZX1fdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcXG5gKTtcbiAgICBpZiAodGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXIuZW1pdE1ldGFkYXRhVHlwZUFubm90YXRpb25zSGVscGVycygpO1xuICAgIH1cbiAgICBzdGF0aWNQcm9wcy5mb3JFYWNoKHAgPT4gdGhpcy52aXNpdFByb3BlcnR5KFtjbGFzc05hbWVdLCBwKSk7XG4gICAgY29uc3QgbWVtYmVyTmFtZXNwYWNlID0gW2NsYXNzTmFtZSwgJ3Byb3RvdHlwZSddO1xuICAgIG5vblN0YXRpY1Byb3BzLmZvckVhY2goKHApID0+IHRoaXMudmlzaXRQcm9wZXJ0eShtZW1iZXJOYW1lc3BhY2UsIHApKTtcbiAgICBwYXJhbVByb3BzLmZvckVhY2goKHApID0+IHRoaXMudmlzaXRQcm9wZXJ0eShtZW1iZXJOYW1lc3BhY2UsIHApKTtcblxuICAgIGZvciAoY29uc3QgZm5EZWNsIG9mIGFic3RyYWN0TWV0aG9kcykge1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMucHJvcGVydHlOYW1lKGZuRGVjbCk7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhpcy5lcnJvcihmbkRlY2wsICdhbm9ueW1vdXMgYWJzdHJhY3QgZnVuY3Rpb24nKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWdzID0gaGFzRXhwb3J0aW5nRGVjb3JhdG9yKGZuRGVjbCwgdGhpcy50eXBlQ2hlY2tlcikgPyBbe3RhZ05hbWU6ICdleHBvcnQnfV0gOiBbXTtcbiAgICAgIGNvbnN0IHBhcmFtTmFtZXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUoW2ZuRGVjbF0sIHRhZ3MpO1xuICAgICAgLy8gbWVtYmVyTmFtZXNwYWNlIGJlY2F1c2UgYWJzdHJhY3QgbWV0aG9kcyBjYW5ub3QgYmUgc3RhdGljIGluIFR5cGVTY3JpcHQuXG4gICAgICB0aGlzLmVtaXQoYCR7bWVtYmVyTmFtZXNwYWNlLmpvaW4oJy4nKX0uJHtuYW1lfSA9IGZ1bmN0aW9uKCR7cGFyYW1OYW1lcy5qb2luKCcsICcpfSkge307XFxuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KGB9XFxuYCk7XG4gIH1cblxuICBwcml2YXRlIHByb3BlcnR5TmFtZShwcm9wOiB0cy5OYW1lZERlY2xhcmF0aW9uKTogc3RyaW5nfG51bGwge1xuICAgIGlmICghcHJvcC5uYW1lKSByZXR1cm4gbnVsbDtcblxuICAgIHN3aXRjaCAocHJvcC5uYW1lLmtpbmQpIHtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgICByZXR1cm4gZ2V0SWRlbnRpZmllclRleHQocHJvcC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgIC8vIEUuZy4gaW50ZXJmYWNlIEZvbyB7ICdiYXInOiBudW1iZXI7IH1cbiAgICAgICAgLy8gSWYgJ2JhcicgaXMgYSBuYW1lIHRoYXQgaXMgbm90IHZhbGlkIGluIENsb3N1cmUgdGhlbiB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvLlxuICAgICAgICBjb25zdCB0ZXh0ID0gKHByb3AubmFtZSBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgICBpZiAoIWlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKHRleHQpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbmFsIElmIHRydWUsIHByb3BlcnR5IGlzIG9wdGlvbmFsIChlLmcuIHdyaXR0ZW4gXCJmb28/OiBzdHJpbmdcIikuXG4gICAqL1xuICBwcml2YXRlIHZpc2l0UHJvcGVydHkobmFtZXNwYWNlOiBzdHJpbmdbXSwgcHJvcDogdHMuRGVjbGFyYXRpb24sIG9wdGlvbmFsID0gZmFsc2UpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLmVtaXQoYC8qIFRPRE86IGhhbmRsZSBzdHJhbmdlIG1lbWJlcjpcXG4ke3RoaXMuZXNjYXBlRm9yQ29tbWVudChwcm9wLmdldFRleHQoKSl9XFxuKi9cXG5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShwcm9wKTtcbiAgICAvLyBXaGVuIGEgcHJvcGVydHkgaXMgb3B0aW9uYWwsIGUuZy5cbiAgICAvLyAgIGZvbz86IHN0cmluZztcbiAgICAvLyBUaGVuIHRoZSBUeXBlU2NyaXB0IHR5cGUgb2YgdGhlIHByb3BlcnR5IGlzIHN0cmluZ3x1bmRlZmluZWQsIHRoZVxuICAgIC8vIHR5cGVUb0Nsb3N1cmUgdHJhbnNsYXRpb24gaGFuZGxlcyBpdCBjb3JyZWN0bHksIGFuZCBzdHJpbmd8dW5kZWZpbmVkIGlzXG4gICAgLy8gaG93IHlvdSB3cml0ZSBhbiBvcHRpb25hbCBwcm9wZXJ0eSBpbiBDbG9zdXJlLlxuICAgIC8vXG4gICAgLy8gQnV0IGluIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYW4gb3B0aW9uYWwgcHJvcGVydHkgd2l0aCB0eXBlIGFueTpcbiAgICAvLyAgIGZvbz86IGFueTtcbiAgICAvLyBUaGUgVHlwZVNjcmlwdCB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBpcyBqdXN0IFwiYW55XCIgKGJlY2F1c2UgYW55IGluY2x1ZGVzXG4gICAgLy8gdW5kZWZpbmVkIGFzIHdlbGwpIHNvIG91ciBkZWZhdWx0IHRyYW5zbGF0aW9uIG9mIHRoZSB0eXBlIGlzIGp1c3QgXCI/XCIuXG4gICAgLy8gVG8gbWFyayB0aGUgcHJvcGVydHkgYXMgb3B0aW9uYWwgaW4gQ2xvc3VyZSBpdCBtdXN0IGhhdmUgXCJ8dW5kZWZpbmVkXCIsXG4gICAgLy8gc28gdGhlIENsb3N1cmUgdHlwZSBtdXN0IGJlID98dW5kZWZpbmVkLlxuICAgIGlmIChvcHRpb25hbCAmJiB0eXBlID09PSAnPycpIHR5cGUgKz0gJ3x1bmRlZmluZWQnO1xuXG4gICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0SlNEb2MocHJvcCkgfHwgW107XG4gICAgdGFncy5wdXNoKHt0YWdOYW1lOiAndHlwZScsIHR5cGV9KTtcbiAgICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKHByb3AsIHRoaXMudHlwZUNoZWNrZXIpKSB7XG4gICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gICAgfVxuICAgIC8vIEF2b2lkIHByaW50aW5nIGFubm90YXRpb25zIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggQHR5cGVcbiAgICAvLyBUaGlzIGF2b2lkcyBDbG9zdXJlJ3MgZXJyb3IgXCJ0eXBlIGFubm90YXRpb24gaW5jb21wYXRpYmxlIHdpdGggb3RoZXIgYW5ub3RhdGlvbnNcIlxuICAgIHRoaXMuZW1pdChqc2RvYy50b1N0cmluZyh0YWdzLCBuZXcgU2V0KFsncGFyYW0nLCAncmV0dXJuJ10pKSk7XG4gICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZV0pO1xuICAgIHRoaXMuZW1pdChgJHtuYW1lc3BhY2Uuam9pbignLicpfTtcXG5gKTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRUeXBlQWxpYXMobm9kZTogdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24pIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcblxuICAgIC8vIElmIHRoZSB0eXBlIGlzIGFsc28gZGVmaW5lZCBhcyBhIHZhbHVlLCBza2lwIGVtaXR0aW5nIGl0LiBDbG9zdXJlIGNvbGxhcHNlcyB0eXBlICYgdmFsdWVcbiAgICAvLyBuYW1lc3BhY2VzLCB0aGUgdHdvIGVtaXRzIHdvdWxkIGNvbmZsaWN0IGlmIHRzaWNrbGUgZW1pdHRlZCBib3RoLlxuICAgIGNvbnN0IHN5bSA9IHRoaXMubXVzdEdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5uYW1lKTtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpIHJldHVybjtcblxuICAgIC8vIFdyaXRlIGEgQ2xvc3VyZSB0eXBlZGVmLCB3aGljaCBpbnZvbHZlcyBhbiB1bnVzZWQgXCJ2YXJcIiBkZWNsYXJhdGlvbi5cbiAgICAvLyBOb3RlOiBpbiB0aGUgY2FzZSBvZiBhbiBleHBvcnQsIHdlIGNhbm5vdCBlbWl0IGEgbGl0ZXJhbCBcInZhclwiIGJlY2F1c2VcbiAgICAvLyBUeXBlU2NyaXB0IGRyb3BzIGV4cG9ydHMgdGhhdCBhcmUgbmV2ZXIgYXNzaWduZWQgdG8gKGFuZCBDbG9zdXJlXG4gICAgLy8gcmVxdWlyZXMgdXMgdG8gbm90IGFzc2lnbiB0byB0eXBlZGVmIGV4cG9ydHMpLiAgSW5zdGVhZCwgZW1pdCB0aGVcbiAgICAvLyBcImV4cG9ydHMuZm9vO1wiIGxpbmUgZGlyZWN0bHkgaW4gdGhhdCBjYXNlLlxuICAgIHRoaXMubmV3VHlwZVRyYW5zbGF0b3Iobm9kZSkuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnMoXG4gICAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBub2RlLnR5cGVQYXJhbWV0ZXJzKTtcblxuICAgIGNvbnN0IHR5cGVTdHIgPSB0aGlzLnR5cGVUb0Nsb3N1cmUobm9kZSwgdW5kZWZpbmVkLCB0cnVlIC8qIHJlc29sdmVBbGlhcyAqLyk7XG4gICAgdGhpcy5lbWl0KGBcXG4vKiogQHR5cGVkZWYgeyR7dHlwZVN0cn19ICovXFxuYCk7XG4gICAgaWYgKGhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXhwb3J0cy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCd2YXIgJyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChgJHtub2RlLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRFbnVtVHlwZSBjb21wdXRlcyB0aGUgQ2xvc3VyZSB0eXBlIG9mIGFuIGVudW0sIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBtZW1iZXJzXG4gICAqIGFuZCBnYXRoZXJpbmcgdGhlaXIgdHlwZXMuXG4gICAqL1xuICBwcml2YXRlIGdldEVudW1UeXBlKGVudW1EZWNsOiB0cy5FbnVtRGVjbGFyYXRpb24pOiAnbnVtYmVyfHN0cmluZyd8J251bWJlcid8J3N0cmluZyd8Jz8nIHtcbiAgICBsZXQgaGFzTnVtYmVyID0gZmFsc2U7XG4gICAgbGV0IGhhc1N0cmluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGVudW1EZWNsLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obWVtYmVyLmluaXRpYWxpemVyKTtcbiAgICAgICAgLy8gTm90ZTogY2hlY2tpbmcgYWdhaW5zdCAnTnVtYmVyTGlrZScgaW5zdGVhZCBvZiBqdXN0ICdOdW1iZXInIG1lYW5zIHRoaXMgY29kZVxuICAgICAgICAvLyBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gICBNRU1CRVIgPSAzLCAgLy8gVHlwZUZsYWdzLk51bWJlckxpdGVyYWxcbiAgICAgICAgLy8gYW5kXG4gICAgICAgIC8vICAgTUVNQkVSID0gc29tZUZ1bmN0aW9uKCksICAvLyBUeXBlRmxhZ3MuTnVtYmVyXG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLk51bWJlckxpa2UpIHtcbiAgICAgICAgICBoYXNOdW1iZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuU3RyaW5nTGlrZSkge1xuICAgICAgICAgIGhhc1N0cmluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRW51bSBjb250YWlucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIHN0cmluZyBvciBhIG51bWJlcjsgYmFpbC5cbiAgICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZW1iZXJzIHdpdGhvdXQgaW5pdGlhbGl6ZXJzIGRlZmF1bHQgdG8gbnVtZXJpYy5cbiAgICAgICAgaGFzTnVtYmVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc051bWJlciAmJiBoYXNTdHJpbmcpIHtcbiAgICAgIHJldHVybiAnPyc7ICAvLyBDbG9zdXJlJ3MgbmV3IHR5cGUgaW5mZXJlbmNlIGRvZXNuJ3Qgc3VwcG9ydCBlbnVtcyBvZiB1bmlvbnMuXG4gICAgfSBlbHNlIGlmIChoYXNOdW1iZXIpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKGhhc1N0cmluZykge1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQZXJoYXBzIGFuIGVtcHR5IGVudW0/XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW4gRW51bURlY2xhcmF0aW9uIGludG8gYSBDbG9zdXJlIHR5cGUuIEFsd2F5cyBlbWl0cyBhIENsb3N1cmUgdHlwZSwgZXZlbiBpbiB1bnR5cGVkXG4gICAqIG1vZGUsIGFzIHRoYXQgc2hvdWxkIGJlIGhhcm1sZXNzIChpdCBvbmx5IGV2ZXIgdXNlcyB0aGUgbnVtYmVyIHR5cGUpLlxuICAgKi9cbiAgcHJpdmF0ZSBwcm9jZXNzRW51bShub2RlOiB0cy5FbnVtRGVjbGFyYXRpb24pIHtcbiAgICAvLyBFbWl0IHRoZSBlbnVtIGRlY2xhcmF0aW9uLCB3aGljaCBsb29rcyBsaWtlOlxuICAgIC8vICAgLyoqIEBlbnVtIHtudW1iZXJ9ICovXG4gICAgLy8gICBjb25zdCBGb28gPSB7QkFSOiAwLCBCQVo6IDEsIC4uLn07XG4gICAgLy8gICBleHBvcnQge0Zvb307ICAvLyBldmVuIGlmIG9yaWdpbmFsbHkgZXhwb3J0ZWQgb24gb25lIGxpbmUuXG4gICAgLy8gVGhpcyBkZWNsYXJlcyBhbiBlbnVtIHR5cGUgZm9yIENsb3N1cmUgQ29tcGlsZXIgKGFuZCBDbG9zdXJlIEpTIHVzZXJzIG9mIHRoaXMgVFMgY29kZSkuXG4gICAgLy8gU3BsaXR0aW5nIHRoZSBlbnVtIGludG8gZGVjbGFyYXRpb24gYW5kIGV4cG9ydCBpcyByZXF1aXJlZCBzbyB0aGF0IGxvY2FsIHJlZmVyZW5jZXMgdG8gdGhlXG4gICAgLy8gdHlwZSByZXNvbHZlIChcIkB0eXBlIHtGb299XCIpLlxuICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZS5nZXRUZXh0KCk7XG5cbiAgICBjb25zdCBlbnVtVHlwZSA9IHRoaXMuZ2V0RW51bVR5cGUobm9kZSk7XG4gICAgdGhpcy5lbWl0KGAvKiogQGVudW0geyR7ZW51bVR5cGV9fSAqL1xcbmApO1xuICAgIHRoaXMuZW1pdChgY29uc3QgJHtuYW1lfTogRG9udFR5cGVDaGVja01lID0ge2ApO1xuICAgIC8vIEVtaXQgZW51bSB2YWx1ZXMgKCdCQVI6IDAsJykuXG4gICAgbGV0IGVudW1JbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2Ygbm9kZS5tZW1iZXJzKSB7XG4gICAgICBjb25zdCBtZW1iZXJOYW1lID0gbWVtYmVyLm5hbWUuZ2V0VGV4dCgpO1xuICAgICAgLy8gRW1pdCBhbnkgY29tbWVudHMgYW5kIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiB0aGUgZW51bSB2YWx1ZSBkZWZpbml0aW9uLlxuICAgICAgdGhpcy53cml0ZUxlYWRpbmdUcml2aWEobWVtYmVyKTtcbiAgICAgIHRoaXMuZW1pdChgJHttZW1iZXJOYW1lfTogYCk7XG5cbiAgICAgIGlmIChtZW1iZXIuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgY29uc3QgZW51bUNvbnN0VmFsdWUgPSB0aGlzLnR5cGVDaGVja2VyLmdldENvbnN0YW50VmFsdWUobWVtYmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnVtQ29uc3RWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlbnVtSW5kZXggPSBlbnVtQ29uc3RWYWx1ZSArIDE7XG4gICAgICAgICAgdGhpcy5lbWl0KGVudW1Db25zdFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vbi1udW1lcmljIGVudW0gdmFsdWUgKHN0cmluZyBvciBhbiBleHByZXNzaW9uKS5cbiAgICAgICAgICAvLyBFbWl0IHRoaXMgaW5pdGlhbGl6ZXIgZXhwcmVzc2lvbiBhcy1pcy5cbiAgICAgICAgICAvLyBOb3RlOiBpZiB0aGUgbWVtYmVyJ3MgaW5pdGlhbGl6ZXIgZXhwcmVzc2lvbiByZWZlcnMgdG8gYW5vdGhlclxuICAgICAgICAgIC8vIHZhbHVlIHdpdGhpbiB0aGUgZW51bSAoZS5nLiBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgIC8vICAgZW51bSBGb28ge1xuICAgICAgICAgIC8vICAgICBGaWVsZDEsXG4gICAgICAgICAgLy8gICAgIEZpZWxkMiA9IEZpZWxkMSArIHNvbWV0aGluZygpLFxuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vIFRoZW4gd2hlbiB3ZSBlbWl0IHRoZSBpbml0aWFsaXplciB3ZSBwcm9kdWNlIGludmFsaWQgY29kZSBiZWNhdXNlXG4gICAgICAgICAgLy8gb24gdGhlIENsb3N1cmUgc2lkZSB0aGUgcmVmZXJlbmNlIHRvIEZpZWxkMSBoYXMgdG8gYmUgbmFtZXNwYWNlZCxcbiAgICAgICAgICAvLyBlLmcuIHdyaXR0ZW4gXCJGb28uRmllbGQxICsgc29tZXRoaW5nKClcIi5cbiAgICAgICAgICAvLyBIb3BlZnVsbHkgdGhpcyBkb2Vzbid0IGNvbWUgdXAgb2Z0ZW4gLS0gaWYgdGhlIGVudW0gaW5zdGVhZCBoYXNcbiAgICAgICAgICAvLyBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgIC8vICAgICBGaWVsZDIgPSBGaWVsZDEgKyAzLFxuICAgICAgICAgIC8vIHRoZW4gaXQncyBzdGlsbCBhIGNvbnN0YW50IGV4cHJlc3Npb24gYW5kIHdlIGlubGluZSB0aGUgY29uc3RhbnRcbiAgICAgICAgICAvLyB2YWx1ZSBpbiB0aGUgYWJvdmUgYnJhbmNoIG9mIHRoaXMgXCJpZlwiIHN0YXRlbWVudC5cbiAgICAgICAgICB0aGlzLnZpc2l0KG1lbWJlci5pbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChlbnVtSW5kZXgudG9TdHJpbmcoKSk7XG4gICAgICAgIGVudW1JbmRleCsrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCcsJyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnfTtcXG4nKTtcblxuICAgIGNvbnN0IGlzRXhwb3J0ZWQgPSBoYXNNb2RpZmllckZsYWcobm9kZSwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpO1xuICAgIGlmIChpc0V4cG9ydGVkKSB0aGlzLmVtaXQoYGV4cG9ydCB7JHtuYW1lfX07XFxuYCk7XG5cbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKG5vZGUsIHRzLk1vZGlmaWVyRmxhZ3MuQ29uc3QpKSB7XG4gICAgICAvLyBCeSBUeXBlU2NyaXB0IHNlbWFudGljcywgY29uc3QgZW51bXMgZGlzYXBwZWFyIGFmdGVyIFRTIGNvbXBpbGF0aW9uLlxuICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnZW5lcmF0ZSB0aGUgcnVudGltZSB2YWx1ZSBhYm92ZSB0byBtYWtlIENsb3N1cmUgQ29tcGlsZXIncyB0eXBlIHN5c3RlbVxuICAgICAgLy8gaGFwcHkgYW5kIGFsbG93IHJlZmVyaW5nIHRvIGVudW1zIGZyb20gSlMgY29kZSwgYnV0IHdlIHNob3VsZCBhdCBsZWFzdCBub3QgZW1pdCBzdHJpbmdcbiAgICAgIC8vIHZhbHVlIG1hcHBpbmdzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEVtaXQgdGhlIHJldmVyc2UgbWFwcGluZyBvZiBmb29bZm9vLkJBUl0gPSAnQkFSJzsgbGluZXMgZm9yIG51bWJlciBlbnVtcy5cbiAgICBpZiAoZW51bVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBub2RlLm1lbWJlcnMpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IG1lbWJlci5uYW1lLmdldFRleHQoKTtcbiAgICAgICAgdGhpcy5lbWl0KGAke25hbWV9WyR7bmFtZX0uJHttZW1iZXJOYW1lfV0gPSBcIiR7bWVtYmVyTmFtZX1cIjtcXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEV4dGVybnNXcml0ZXIgZ2VuZXJhdGVzIENsb3N1cmUgZXh0ZXJucyBmcm9tIFR5cGVTY3JpcHQgc291cmNlLiAqL1xuY2xhc3MgRXh0ZXJuc1dyaXRlciBleHRlbmRzIENsb3N1cmVSZXdyaXRlciB7XG4gIHByb2Nlc3MoKToge291dHB1dDogc3RyaW5nLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdfSB7XG4gICAgdGhpcy5maW5kRXh0ZXJuUm9vdHMoKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy52aXNpdChub2RlKSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0KCk7XG4gIH1cblxuICBuZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0OiB0cy5Ob2RlKSB7XG4gICAgY29uc3QgdHQgPSBzdXBlci5uZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0KTtcbiAgICB0dC5pc0ZvckV4dGVybnMgPSB0cnVlO1xuICAgIHJldHVybiB0dDtcbiAgfVxuXG4gIHByaXZhdGUgZmluZEV4dGVyblJvb3RzKCk6IHRzLk5vZGVbXSB7XG4gICAgaWYgKGlzRHRzRmlsZU5hbWUodGhpcy5maWxlLmZpbGVOYW1lKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLmZpbGVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlLnN0YXRlbWVudHMuZmlsdGVyKHN0bXQgPT4gaGFzTW9kaWZpZXJGbGFnKHN0bXQsIHRzLk1vZGlmaWVyRmxhZ3MuQW1iaWVudCkpO1xuICB9XG5cbiAgLyoqIHZpc2l0IGlzIHRoZSBtYWluIGVudHJ5IHBvaW50LiAgSXQgZ2VuZXJhdGVzIGV4dGVybnMgZnJvbSBhIHRzLk5vZGUuICovXG4gIHB1YmxpYyB2aXNpdChub2RlOiB0cy5Ob2RlLCBuYW1lc3BhY2U6IHN0cmluZ1tdID0gW10pIHtcbiAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlNvdXJjZUZpbGU6XG4gICAgICAgIGNvbnN0IHNvdXJjZUZpbGUgPSBub2RlIGFzIHRzLlNvdXJjZUZpbGU7XG4gICAgICAgIGZvciAoY29uc3Qgc3RtdCBvZiBzb3VyY2VGaWxlLnN0YXRlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0KHN0bXQsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTW9kdWxlRGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGRlY2wgPSBub2RlIGFzIHRzLk1vZHVsZURlY2xhcmF0aW9uO1xuICAgICAgICBzd2l0Y2ggKGRlY2wubmFtZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBuYW1lc3BhY2UgZm9vIHtcIlxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBnbG9iYWwgeyAuLi4gfVwiLiAgUmVzZXQgdG8gdGhlIG91dGVyIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZpcnN0RGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKG5hbWUsIG5hbWVzcGFjZSwgJ3t9Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNsLmJvZHkpIHRoaXMudmlzaXQoZGVjbC5ib2R5LCBuYW1lc3BhY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBtb2R1bGUgJ2Zvbycge1wiIChub3RlIHRoZSBxdW90ZXMpLlxuICAgICAgICAgICAgLy8gV2Ugc3RpbGwgd2FudCB0byBlbWl0IGV4dGVybnMgZm9yIHRoaXMgbW9kdWxlLCBidXRcbiAgICAgICAgICAgIC8vIENsb3N1cmUgZG9lc24ndCByZWFsbHkgcHJvdmlkZSBhIG1lY2hhbmlzbSBmb3JcbiAgICAgICAgICAgIC8vIG1vZHVsZS1zY29wZWQgZXh0ZXJucy4gIEZvciBub3csIGlnbm9yZSB0aGUgZW5jbG9zaW5nXG4gICAgICAgICAgICAvLyBuYW1lc3BhY2UgKGJlY2F1c2UgdGhpcyBpcyBkZWNsYXJpbmcgYSB0b3AtbGV2ZWwgbW9kdWxlKVxuICAgICAgICAgICAgLy8gYW5kIGVtaXQgaW50byBhIGZha2UgbmFtZXNwYWNlLlxuXG4gICAgICAgICAgICAvLyBEZWNsYXJlIHRoZSB0b3AtbGV2ZWwgXCJ0c2lja2xlX2RlY2xhcmVfbW9kdWxlXCIuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGUoJ3RzaWNrbGVfZGVjbGFyZV9tb2R1bGUnLCBbXSwgJ3t9Jyk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBbJ3RzaWNrbGVfZGVjbGFyZV9tb2R1bGUnXTtcblxuICAgICAgICAgICAgLy8gRGVjbGFyZSB0aGUgaW5uZXIgXCJ0c2lja2xlX2RlY2xhcmVfbW9kdWxlLmZvb1wiLCBpZiBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZGVjbGFyZWQgYWxyZWFkeSBlbHNld2hlcmUuXG4gICAgICAgICAgICBsZXQgaW1wb3J0TmFtZSA9IChkZWNsLm5hbWUgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChgLy8gRGVyaXZlZCBmcm9tOiBkZWNsYXJlIG1vZHVsZSBcIiR7aW1wb3J0TmFtZX1cIlxcbmApO1xuICAgICAgICAgICAgLy8gV2UgYWxzbyBkb24ndCBjYXJlIGFib3V0IHRoZSBhY3R1YWwgbmFtZSBvZiB0aGUgbW9kdWxlIChcImZvb1wiXG4gICAgICAgICAgICAvLyBpbiB0aGUgYWJvdmUgZXhhbXBsZSksIGV4Y2VwdCB0aGF0IHdlIHdhbnQgaXQgdG8gbm90IGNvbmZsaWN0LlxuICAgICAgICAgICAgaW1wb3J0TmFtZSA9IGltcG9ydE5hbWUucmVwbGFjZSgvXy8sICdfXycpLnJlcGxhY2UoL1teQS1aYS16XS9nLCAnXycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaXJzdERlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKGltcG9ydE5hbWUsIG5hbWVzcGFjZSwgJ3t9Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY2xhcmUgdGhlIGNvbnRlbnRzIGluc2lkZSB0aGUgXCJ0c2lja2xlX2RlY2xhcmVfbW9kdWxlLmZvb1wiLlxuICAgICAgICAgICAgaWYgKGRlY2wuYm9keSkgdGhpcy52aXNpdChkZWNsLmJvZHksIG5hbWVzcGFjZS5jb25jYXQoaW1wb3J0TmFtZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuZXJyb3JVbmltcGxlbWVudGVkS2luZChkZWNsLm5hbWUsICdleHRlcm5zIGdlbmVyYXRpb24gb2YgbmFtZXNwYWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTW9kdWxlQmxvY2s6XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZSBhcyB0cy5Nb2R1bGVCbG9jaztcbiAgICAgICAgZm9yIChjb25zdCBzdG10IG9mIGJsb2NrLnN0YXRlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0KHN0bXQsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW1wb3J0RXF1YWxzRGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGltcG9ydEVxdWFscyA9IG5vZGUgYXMgdHMuSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGltcG9ydEVxdWFscy5uYW1lKTtcbiAgICAgICAgaWYgKGxvY2FsTmFtZSA9PT0gJ25nJykge1xuICAgICAgICAgIHRoaXMuZW1pdChgXFxuLyogU2tpcHBpbmcgcHJvYmxlbWF0aWMgaW1wb3J0IG5nID0gLi4uOyAqL1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBvcnRFcXVhbHMubW9kdWxlUmVmZXJlbmNlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoYFxcbi8qIFRPRE86IGltcG9ydCAke2xvY2FsTmFtZX0gPSByZXF1aXJlKC4uLikgKi9cXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxbiA9IGdldEVudGl0eU5hbWVUZXh0KGltcG9ydEVxdWFscy5tb2R1bGVSZWZlcmVuY2UpO1xuICAgICAgICAvLyBAY29uc3Qgc28gdGhhdCBDbG9zdXJlIENvbXBpbGVyIHVuZGVyc3RhbmRzIHRoaXMgaXMgYW4gYWxpYXMuXG4gICAgICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID09PSAwKSB0aGlzLmVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgdGhpcy53cml0ZUV4dGVybnNWYXJpYWJsZShsb2NhbE5hbWUsIG5hbWVzcGFjZSwgcW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uOlxuICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc1R5cGUobm9kZSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiB8IHRzLkNsYXNzRGVjbGFyYXRpb24sIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGZuRGVjbCA9IG5vZGUgYXMgdHMuRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZuRGVjbC5uYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKGZuRGVjbCwgJ2Fub255bW91cyBmdW5jdGlvbiBpbiBleHRlcm5zJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2F0aGVyIHVwIGFsbCBvdmVybG9hZHMgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgY29uc3Qgc3ltID0gdGhpcy5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihuYW1lKTtcbiAgICAgICAgY29uc3QgZGVjbHMgPSBzeW0uZGVjbGFyYXRpb25zIS5maWx0ZXIoZCA9PiBkLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbikgYXNcbiAgICAgICAgICAgIHRzLkZ1bmN0aW9uRGVjbGFyYXRpb25bXTtcbiAgICAgICAgLy8gT25seSBlbWl0IHRoZSBmaXJzdCBkZWNsYXJhdGlvbiBvZiBlYWNoIG92ZXJsb2FkZWQgZnVuY3Rpb24uXG4gICAgICAgIGlmIChmbkRlY2wgIT09IGRlY2xzWzBdKSBicmVhaztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5lbWl0RnVuY3Rpb25UeXBlKGRlY2xzKTtcbiAgICAgICAgdGhpcy53cml0ZUV4dGVybnNGdW5jdGlvbihuYW1lLCBwYXJhbXMsIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50OlxuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgKG5vZGUgYXMgdHMuVmFyaWFibGVTdGF0ZW1lbnQpLmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlRGVjbChkZWNsLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkVudW1EZWNsYXJhdGlvbjpcbiAgICAgICAgdGhpcy53cml0ZUV4dGVybnNFbnVtKG5vZGUgYXMgdHMuRW51bURlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbjpcbiAgICAgICAgdGhpcy53cml0ZUV4dGVybnNUeXBlQWxpYXMobm9kZSBhcyB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVtaXQoYFxcbi8qIFRPRE86ICR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfSBpbiAke25hbWVzcGFjZS5qb2luKCcuJyl9ICovXFxuYCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBpc0ZpcnN0RGVjbGFyYXRpb24gcmV0dXJucyB0cnVlIGlmIGRlY2wgaXMgdGhlIGZpcnN0IGRlY2xhcmF0aW9uXG4gICAqIG9mIGl0cyBzeW1ib2wuICBFLmcuIGltYWdpbmVcbiAgICogICBpbnRlcmZhY2UgRm9vIHsgeDogbnVtYmVyOyB9XG4gICAqICAgaW50ZXJmYWNlIEZvbyB7IHk6IG51bWJlcjsgfVxuICAgKiB3ZSBvbmx5IHdhbnQgdG8gZW1pdCB0aGUgXCJAcmVjb3JkXCIgZm9yIEZvbyBvbiB0aGUgZmlyc3Qgb25lLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0ZpcnN0RGVjbGFyYXRpb24oZGVjbDogdHMuRGVjbGFyYXRpb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgICBpZiAoIWRlY2wubmFtZSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qgc3ltID0gdGhpcy5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihkZWNsLm5hbWUpO1xuICAgIGlmICghc3ltLmRlY2xhcmF0aW9ucyB8fCBzeW0uZGVjbGFyYXRpb25zLmxlbmd0aCA8IDIpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBkZWNsID09PSBzeW0uZGVjbGFyYXRpb25zWzBdO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUV4dGVybnNUeXBlKGRlY2w6IHRzLkludGVyZmFjZURlY2xhcmF0aW9ufHRzLkNsYXNzRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogc3RyaW5nW10pIHtcbiAgICBjb25zdCBuYW1lID0gZGVjbC5uYW1lO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhpcy5lcnJvcihkZWNsLCAnYW5vbnltb3VzIHR5cGUgaW4gZXh0ZXJucycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IG5hbWVzcGFjZS5jb25jYXQoW25hbWUuZ2V0VGV4dCgpXSkuam9pbignLicpO1xuICAgIGlmIChjbG9zdXJlRXh0ZXJuc0JsYWNrbGlzdC5pbmRleE9mKHR5cGVOYW1lKSA+PSAwKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5pc0ZpcnN0RGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgIGxldCBwYXJhbU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgY29uc3QganNkb2NUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgbGV0IHdyaXRlSnNEb2MgPSB0cnVlO1xuICAgICAgdGhpcy5tYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhqc2RvY1RhZ3MsIGRlY2wpO1xuICAgICAgaWYgKGRlY2wua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIGpzZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnY29uc3RydWN0b3InfSk7XG4gICAgICAgIGpzZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnc3RydWN0J30pO1xuICAgICAgICBjb25zdCBjdG9ycyA9IChkZWNsIGFzIHRzLkNsYXNzRGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5tZW1iZXJzLmZpbHRlcigobSkgPT4gbS5raW5kID09PSB0cy5TeW50YXhLaW5kLkNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKGN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgIHdyaXRlSnNEb2MgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBmaXJzdEN0b3I6IHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24gPSBjdG9yc1swXSBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uO1xuICAgICAgICAgIGNvbnN0IGN0b3JUYWdzID0gW3t0YWdOYW1lOiAnY29uc3RydWN0b3InfSwge3RhZ05hbWU6ICdzdHJ1Y3QnfV07XG4gICAgICAgICAgaWYgKGN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBhcmFtTmFtZXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUoY3RvcnMgYXMgdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbltdLCBjdG9yVGFncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtTmFtZXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUoW2ZpcnN0Q3Rvcl0sIGN0b3JUYWdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAncmVjb3JkJ30pO1xuICAgICAgICBqc2RvY1RhZ3MucHVzaCh7dGFnTmFtZTogJ3N0cnVjdCd9KTtcbiAgICAgIH1cbiAgICAgIGlmICh3cml0ZUpzRG9jKSB0aGlzLmVtaXQoanNkb2MudG9TdHJpbmcoanNkb2NUYWdzKSk7XG4gICAgICB0aGlzLndyaXRlRXh0ZXJuc0Z1bmN0aW9uKG5hbWUsIHBhcmFtTmFtZXMsIG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBldmVyeXRoaW5nIGV4Y2VwdCAoTWV0aG9kU2lnbmF0dXJlfE1ldGhvZERlY2xhcmF0aW9ufENvbnN0cnVjdG9yKVxuICAgIGNvbnN0IG1ldGhvZHMgPSBuZXcgTWFwPHN0cmluZywgdHMuTWV0aG9kRGVjbGFyYXRpb25bXT4oKTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWNsLm1lbWJlcnMpIHtcbiAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5U2lnbmF0dXJlOlxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjb25zdCBwcm9wID0gbWVtYmVyIGFzIHRzLlByb3BlcnR5U2lnbmF0dXJlO1xuICAgICAgICAgIGlmIChwcm9wLm5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRKU0RvY1R5cGUocHJvcCk7XG4gICAgICAgICAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKHByb3AsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKSkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoYFxcbiR7dHlwZU5hbWV9LiR7cHJvcC5uYW1lLmdldFRleHQoKX07XFxuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoYFxcbiR7dHlwZU5hbWV9LnByb3RvdHlwZS4ke3Byb3AubmFtZS5nZXRUZXh0KCl9O1xcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE86IEZvciBub3cgcHJvcGVydHkgbmFtZXMgb3RoZXIgdGhhbiBJZGVudGlmaWVycyBhcmUgbm90IGhhbmRsZWQ7IGUuZy5cbiAgICAgICAgICAvLyAgICBpbnRlcmZhY2UgRm9vIHsgXCIxMjNiYXJcIjogbnVtYmVyIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZFNpZ25hdHVyZTpcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uOlxuICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IG1lbWJlciBhcyB0cy5NZXRob2REZWNsYXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBpc1N0YXRpYyA9IGhhc01vZGlmaWVyRmxhZyhtZXRob2QsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKTtcbiAgICAgICAgICBjb25zdCBtZXRob2RTaWduYXR1cmUgPSBgJHttZXRob2QubmFtZS5nZXRUZXh0KCl9JCQkJHtpc1N0YXRpYyA/ICdzdGF0aWMnIDogJ2luc3RhbmNlJ31gO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZHMuaGFzKG1ldGhvZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIG1ldGhvZHMuZ2V0KG1ldGhvZFNpZ25hdHVyZSkhLnB1c2gobWV0aG9kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kcy5zZXQobWV0aG9kU2lnbmF0dXJlLCBbbWV0aG9kXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgICAgY29udGludWU7ICAvLyBIYW5kbGVkIGFib3ZlLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIE1lbWJlcnMgY2FuIGluY2x1ZGUgdGhpbmdzIGxpa2UgaW5kZXggc2lnbmF0dXJlcywgZm9yIGUuZy5cbiAgICAgICAgICAvLyAgIGludGVyZmFjZSBGb28geyBba2V5OiBzdHJpbmddOiBudW1iZXI7IH1cbiAgICAgICAgICAvLyBGb3Igbm93LCBqdXN0IHNraXAgaXQuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIG1lbWJlciB3YXNuJ3QgaGFuZGxlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudC5cbiAgICAgIGxldCBtZW1iZXJOYW1lID0gbmFtZXNwYWNlO1xuICAgICAgaWYgKG1lbWJlci5uYW1lKSB7XG4gICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLmNvbmNhdChbbWVtYmVyLm5hbWUuZ2V0VGV4dCgpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoYFxcbi8qIFRPRE86ICR7dHMuU3ludGF4S2luZFttZW1iZXIua2luZF19OiAke21lbWJlck5hbWUuam9pbignLicpfSAqL1xcbmApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBtZXRob2QgZGVjbGFyYXRpb25zL3NpZ25hdHVyZXMgc2VwYXJhdGVseSwgc2luY2Ugd2UgbmVlZCB0byBkZWFsIHdpdGggb3ZlcmxvYWRzLlxuICAgIGZvciAoY29uc3QgbWV0aG9kVmFyaWFudHMgb2YgQXJyYXkuZnJvbShtZXRob2RzLnZhbHVlcygpKSkge1xuICAgICAgY29uc3QgZmlyc3RNZXRob2RWYXJpYW50ID0gbWV0aG9kVmFyaWFudHNbMF07XG4gICAgICBsZXQgcGFyYW1ldGVyTmFtZXM6IHN0cmluZ1tdO1xuICAgICAgaWYgKG1ldGhvZFZhcmlhbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFyYW1ldGVyTmFtZXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUobWV0aG9kVmFyaWFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1ldGVyTmFtZXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUoW2ZpcnN0TWV0aG9kVmFyaWFudF0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0aG9kTmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZS5nZXRUZXh0KCldKTtcbiAgICAgIC8vIElmIHRoZSBtZXRob2QgaXMgc3RhdGljLCBkb24ndCBhZGQgdGhlIHByb3RvdHlwZS5cbiAgICAgIGlmICghaGFzTW9kaWZpZXJGbGFnKGZpcnN0TWV0aG9kVmFyaWFudCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzcGFjZS5wdXNoKCdwcm90b3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud3JpdGVFeHRlcm5zRnVuY3Rpb24oZmlyc3RNZXRob2RWYXJpYW50Lm5hbWUsIHBhcmFtZXRlck5hbWVzLCBtZXRob2ROYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVFeHRlcm5zVmFyaWFibGVEZWNsKGRlY2w6IHRzLlZhcmlhYmxlRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogc3RyaW5nW10pIHtcbiAgICBpZiAoZGVjbC5uYW1lLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgY29uc3QgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgIGlmIChjbG9zdXJlRXh0ZXJuc0JsYWNrbGlzdC5pbmRleE9mKG5hbWUpID49IDApIHJldHVybjtcbiAgICAgIHRoaXMuZW1pdEpTRG9jVHlwZShkZWNsKTtcbiAgICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXJyb3JVbmltcGxlbWVudGVkS2luZChkZWNsLm5hbWUsICdleHRlcm5zIGZvciB2YXJpYWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVFeHRlcm5zVmFyaWFibGUobmFtZTogc3RyaW5nLCBuYW1lc3BhY2U6IHN0cmluZ1tdLCB2YWx1ZT86IHN0cmluZykge1xuICAgIGNvbnN0IHF1YWxpZmllZE5hbWUgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lXSkuam9pbignLicpO1xuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID09PSAwKSB0aGlzLmVtaXQoYHZhciBgKTtcbiAgICB0aGlzLmVtaXQocXVhbGlmaWVkTmFtZSk7XG4gICAgaWYgKHZhbHVlKSB0aGlzLmVtaXQoYCA9ICR7dmFsdWV9YCk7XG4gICAgdGhpcy5lbWl0KCc7XFxuJyk7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlRXh0ZXJuc0Z1bmN0aW9uKG5hbWU6IHRzLk5vZGUsIHBhcmFtczogc3RyaW5nW10sIG5hbWVzcGFjZTogc3RyaW5nW10pIHtcbiAgICBjb25zdCBwYXJhbXNTdHIgPSBwYXJhbXMuam9pbignLCAnKTtcbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBmcW4gPSBuYW1lc3BhY2Uuam9pbignLicpO1xuICAgICAgaWYgKG5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgIGZxbiArPSAnLic7ICAvLyBjb21wdXRlZCBuYW1lcyBpbmNsdWRlIFsgXSBpbiB0aGVpciBnZXRUZXh0KCkgcmVwcmVzZW50YXRpb24uXG4gICAgICB9XG4gICAgICBmcW4gKz0gbmFtZS5nZXRUZXh0KCk7XG4gICAgICB0aGlzLmVtaXQoYCR7ZnFufSA9IGZ1bmN0aW9uKCR7cGFyYW1zU3RyfSkge307XFxuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuYW1lLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLmVycm9yKG5hbWUsICdOb24tbmFtZXNwYWNlZCBjb21wdXRlZCBuYW1lIGluIGV4dGVybnMnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChgZnVuY3Rpb24gJHtuYW1lLmdldFRleHQoKX0oJHtwYXJhbXNTdHJ9KSB7fVxcbmApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVFeHRlcm5zRW51bShkZWNsOiB0cy5FbnVtRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogc3RyaW5nW10pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lKTtcbiAgICB0aGlzLmVtaXQoJ1xcbi8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKG5hbWUsIG5hbWVzcGFjZSwgJ3t9Jyk7XG4gICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZV0pO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlY2wubWVtYmVycykge1xuICAgICAgbGV0IG1lbWJlck5hbWU6IHN0cmluZ3x1bmRlZmluZWQ7XG4gICAgICBzd2l0Y2ggKG1lbWJlci5uYW1lLmtpbmQpIHtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICAgICAgbWVtYmVyTmFtZSA9IGdldElkZW50aWZpZXJUZXh0KG1lbWJlci5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gKG1lbWJlci5uYW1lIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgICAgICAgaWYgKGlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKHRleHQpKSBtZW1iZXJOYW1lID0gdGV4dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghbWVtYmVyTmFtZSkge1xuICAgICAgICB0aGlzLmVtaXQoYFxcbi8qIFRPRE86ICR7dHMuU3ludGF4S2luZFttZW1iZXIubmFtZS5raW5kXX06ICR7bWVtYmVyLm5hbWUuZ2V0VGV4dCgpfSAqL1xcbmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnLyoqIEBjb25zdCB7bnVtYmVyfSAqL1xcbicpO1xuICAgICAgdGhpcy53cml0ZUV4dGVybnNWYXJpYWJsZShtZW1iZXJOYW1lLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVFeHRlcm5zVHlwZUFsaWFzKGRlY2w6IHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgdHlwZVN0ciA9IHRoaXMudHlwZVRvQ2xvc3VyZShkZWNsLCB1bmRlZmluZWQsIHRydWUgLyogcmVzb2x2ZUFsaWFzICovKTtcbiAgICB0aGlzLmVtaXQoYFxcbi8qKiBAdHlwZWRlZiB7JHt0eXBlU3RyfX0gKi9cXG5gKTtcbiAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSksIG5hbWVzcGFjZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQb2x5bWVyQmVoYXZpb3JQcm9wZXJ0eUluQ2FsbEV4cHJlc3Npb24ocGE6IHRzLlByb3BlcnR5QXNzaWdubWVudCk6IGJvb2xlYW4ge1xuICBjb25zdCBwYXJlbnRQYXJlbnQgPSBwYS5wYXJlbnQgJiYgcGEucGFyZW50LnBhcmVudDtcbiAgaWYgKHBhLm5hbWUua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyIHx8XG4gICAgICAocGEubmFtZSBhcyB0cy5JZGVudGlmaWVyKS50ZXh0ICE9PSAnYmVoYXZpb3JzJyB8fCAhcGEucGFyZW50IHx8ICFwYS5wYXJlbnQucGFyZW50IHx8XG4gICAgICBwYS5wYXJlbnQucGFyZW50LmtpbmQgIT09IHRzLlN5bnRheEtpbmQuQ2FsbEV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBleHByID0gKHBhcmVudFBhcmVudCBhcyB0cy5DYWxsRXhwcmVzc2lvbikuZXhwcmVzc2lvbjtcbiAgcmV0dXJuIGV4cHIua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyICYmIChleHByIGFzIHRzLklkZW50aWZpZXIpLnRleHQgPT09ICdQb2x5bWVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFubm90YXRlKFxuICAgIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgZmlsZTogdHMuU291cmNlRmlsZSwgaG9zdDogQW5ub3RhdG9ySG9zdCxcbiAgICB0c0hvc3Q/OiB0cy5Nb2R1bGVSZXNvbHV0aW9uSG9zdCwgdHNPcHRzPzogdHMuQ29tcGlsZXJPcHRpb25zLFxuICAgIHNvdXJjZU1hcHBlcj86IFNvdXJjZU1hcHBlcik6IHtvdXRwdXQ6IHN0cmluZywgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXX0ge1xuICByZXR1cm4gbmV3IEFubm90YXRvcih0eXBlQ2hlY2tlciwgZmlsZSwgaG9zdCwgdHNIb3N0LCB0c09wdHMsIHNvdXJjZU1hcHBlcikuYW5ub3RhdGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlRXh0ZXJucyh0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGZpbGU6IHRzLlNvdXJjZUZpbGUsIGhvc3Q6IEFubm90YXRvckhvc3QpOlxuICAgIHtvdXRwdXQ6IHN0cmluZywgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXX0ge1xuICByZXR1cm4gbmV3IEV4dGVybnNXcml0ZXIodHlwZUNoZWNrZXIsIGZpbGUsIGhvc3QpLnByb2Nlc3MoKTtcbn1cblxuLyoqIENvbmNhdGVuYXRlIGFsbCBnZW5lcmF0ZWQgZXh0ZXJucyBkZWZpbml0aW9ucyB0b2dldGhlciBpbnRvIGEgc3RyaW5nLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlbmVyYXRlZEV4dGVybnMoZXh0ZXJuczoge1tmaWxlTmFtZTogc3RyaW5nXTogc3RyaW5nfSk6IHN0cmluZyB7XG4gIGxldCBhbGxFeHRlcm5zID0gRVhURVJOU19IRUFERVI7XG4gIGZvciAoY29uc3QgZmlsZU5hbWUgb2YgT2JqZWN0LmtleXMoZXh0ZXJucykpIHtcbiAgICBhbGxFeHRlcm5zICs9IGAvLyBleHRlcm5zIGZyb20gJHtmaWxlTmFtZX06XFxuYDtcbiAgICBhbGxFeHRlcm5zICs9IGV4dGVybnNbZmlsZU5hbWVdO1xuICB9XG4gIHJldHVybiBhbGxFeHRlcm5zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRzaWNrbGVIb3N0IGV4dGVuZHMgZXM1cHJvY2Vzc29yLkVzNVByb2Nlc3Nvckhvc3QsIEFubm90YXRvckhvc3Qge1xuICAvKipcbiAgICogV2hldGhlciB0byBkb3dubGV2ZWwgZGVjb3JhdG9yc1xuICAgKi9cbiAgdHJhbnNmb3JtRGVjb3JhdG9ycz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGNvbnZlcnMgdHlwZXMgdG8gY2xvc3VyZVxuICAgKi9cbiAgdHJhbnNmb3JtVHlwZXNUb0Nsb3N1cmU/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBhZGQgYWxpYXNlcyB0byB0aGUgLmQudHMgZmlsZXMgdG8gYWRkIHRoZSBleHBvcnRzIHRvIHRoZVxuICAgKiDgsqBf4LKgLmNsdXR6IG5hbWVzcGFjZS5cbiAgICovXG4gIGFkZER0c0NsdXR6QWxpYXNlcz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0c2lja2xlIGFuZCBkZWNvcmF0b3IgZG93bmxldmVsIHByb2Nlc3Npbmcgd2lsbCBiZSBza2lwcGVkIGZvclxuICAgKiB0aGF0IGZpbGUuXG4gICAqL1xuICBzaG91bGRTa2lwVHNpY2tsZVByb2Nlc3NpbmcoZmlsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUc2lja2xlIHRyZWF0cyB3YXJuaW5ncyBhcyBlcnJvcnMsIGlmIHRydWUsIGlnbm9yZSB3YXJuaW5ncy4gIFRoaXMgbWlnaHQgYmVcbiAgICogdXNlZnVsIGZvciBlLmcuIHRoaXJkIHBhcnR5IGNvZGUuXG4gICAqL1xuICBzaG91bGRJZ25vcmVXYXJuaW5nc0ZvclBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUVtaXRSZXN1bHRzKGVtaXRSZXN1bHRzOiBFbWl0UmVzdWx0W10pOiBFbWl0UmVzdWx0IHtcbiAgY29uc3QgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuICBsZXQgZW1pdFNraXBwZWQgPSB0cnVlO1xuICBjb25zdCBlbWl0dGVkRmlsZXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGV4dGVybnM6IHtbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgY29uc3QgbW9kdWxlc01hbmlmZXN0ID0gbmV3IE1vZHVsZXNNYW5pZmVzdCgpO1xuICBmb3IgKGNvbnN0IGVyIG9mIGVtaXRSZXN1bHRzKSB7XG4gICAgZGlhZ25vc3RpY3MucHVzaCguLi5lci5kaWFnbm9zdGljcyk7XG4gICAgZW1pdFNraXBwZWQgPSBlbWl0U2tpcHBlZCB8fCBlci5lbWl0U2tpcHBlZDtcbiAgICBlbWl0dGVkRmlsZXMucHVzaCguLi5lci5lbWl0dGVkRmlsZXMpO1xuICAgIE9iamVjdC5hc3NpZ24oZXh0ZXJucywgZXIuZXh0ZXJucyk7XG4gICAgbW9kdWxlc01hbmlmZXN0LmFkZE1hbmlmZXN0KGVyLm1vZHVsZXNNYW5pZmVzdCk7XG4gIH1cbiAgcmV0dXJuIHtkaWFnbm9zdGljcywgZW1pdFNraXBwZWQsIGVtaXR0ZWRGaWxlcywgZXh0ZXJucywgbW9kdWxlc01hbmlmZXN0fTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbWl0UmVzdWx0IGV4dGVuZHMgdHMuRW1pdFJlc3VsdCB7XG4gIC8vIFRoZSBtYW5pZmVzdCBvZiBKUyBtb2R1bGVzIG91dHB1dCBieSB0aGUgY29tcGlsZXIuXG4gIG1vZHVsZXNNYW5pZmVzdDogTW9kdWxlc01hbmlmZXN0O1xuICAvKiogZXh0ZXJucy5qcyBmaWxlcyBwcm9kdWNlZCBieSB0c2lja2xlLCBpZiBhbnkuICovXG4gIGV4dGVybnM6IHtbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZ307XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1pdFRyYW5zZm9ybWVycyB7XG4gIGJlZm9yZVRzaWNrbGU/OiBBcnJheTx0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4+O1xuICBiZWZvcmVUcz86IEFycmF5PHRzLlRyYW5zZm9ybWVyRmFjdG9yeTx0cy5Tb3VyY2VGaWxlPj47XG4gIGFmdGVyVHM/OiBBcnJheTx0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1pdFdpdGhUc2lja2xlKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGhvc3Q6IFRzaWNrbGVIb3N0LCB0c0hvc3Q6IHRzLkNvbXBpbGVySG9zdCwgdHNPcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsXG4gICAgdGFyZ2V0U291cmNlRmlsZT86IHRzLlNvdXJjZUZpbGUsIHdyaXRlRmlsZT86IHRzLldyaXRlRmlsZUNhbGxiYWNrLFxuICAgIGNhbmNlbGxhdGlvblRva2VuPzogdHMuQ2FuY2VsbGF0aW9uVG9rZW4sIGVtaXRPbmx5RHRzRmlsZXM/OiBib29sZWFuLFxuICAgIGN1c3RvbVRyYW5zZm9ybWVyczogRW1pdFRyYW5zZm9ybWVycyA9IHt9KTogRW1pdFJlc3VsdCB7XG4gIGxldCB0c2lja2xlRGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuICBjb25zdCB0eXBlQ2hlY2tlciA9IHByb2dyYW0uZ2V0VHlwZUNoZWNrZXIoKTtcbiAgY29uc3QgdHNpY2tsZVNvdXJjZVRyYW5zZm9ybWVyczogQXJyYXk8dHMuVHJhbnNmb3JtZXJGYWN0b3J5PHRzLlNvdXJjZUZpbGU+PiA9IFtdO1xuICBpZiAoaG9zdC50cmFuc2Zvcm1UeXBlc1RvQ2xvc3VyZSkge1xuICAgIC8vIE5vdGU6IHRzaWNrbGUuYW5ub3RhdGUgY2FuIGFsc28gbG93ZXIgZGVjb3JhdG9ycyBpbiB0aGUgc2FtZSBydW4uXG4gICAgdHNpY2tsZVNvdXJjZVRyYW5zZm9ybWVycy5wdXNoKGNyZWF0ZVRyYW5zZm9ybWVyRnJvbVNvdXJjZU1hcCgoc291cmNlRmlsZSwgc291cmNlTWFwcGVyKSA9PiB7XG4gICAgICBjb25zdCB7b3V0cHV0LCBkaWFnbm9zdGljc30gPVxuICAgICAgICAgIGFubm90YXRlKHR5cGVDaGVja2VyLCBzb3VyY2VGaWxlLCBob3N0LCB0c0hvc3QsIHRzT3B0aW9ucywgc291cmNlTWFwcGVyKTtcbiAgICAgIHRzaWNrbGVEaWFnbm9zdGljcy5wdXNoKC4uLmRpYWdub3N0aWNzKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICAgIC8vIE9ubHkgYWRkIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY29tbWVudHMgd2hlbiBhbHNvIGFkZGluZyB0eXBlIGFubm90YXRpb25zLlxuICAgIHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1GaWxlb3ZlcnZpZXdDb21tZW50KTtcbiAgICB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzLnB1c2goXG4gICAgICAgIGNsYXNzRGVjb3JhdG9yRG93bmxldmVsVHJhbnNmb3JtZXIodHlwZUNoZWNrZXIsIHRzaWNrbGVEaWFnbm9zdGljcykpO1xuICB9IGVsc2UgaWYgKGhvc3QudHJhbnNmb3JtRGVjb3JhdG9ycykge1xuICAgIHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnMucHVzaChjcmVhdGVUcmFuc2Zvcm1lckZyb21Tb3VyY2VNYXAoKHNvdXJjZUZpbGUsIHNvdXJjZU1hcHBlcikgPT4ge1xuICAgICAgY29uc3Qge291dHB1dCwgZGlhZ25vc3RpY3N9ID1cbiAgICAgICAgICBkZWNvcmF0b3IuY29udmVydERlY29yYXRvcnModHlwZUNoZWNrZXIsIHNvdXJjZUZpbGUsIHNvdXJjZU1hcHBlcik7XG4gICAgICB0c2lja2xlRGlhZ25vc3RpY3MucHVzaCguLi5kaWFnbm9zdGljcyk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgICB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzLnB1c2goXG4gICAgICAgIGNsYXNzRGVjb3JhdG9yRG93bmxldmVsVHJhbnNmb3JtZXIodHlwZUNoZWNrZXIsIHRzaWNrbGVEaWFnbm9zdGljcykpO1xuICB9XG4gIC8vIC8vIEZvciBkZWJ1Z2dpbmc6IHRyYW5zZm9ybWVyIHRoYXQganVzdCBlbWl0cyB0aGUgc2FtZSB0ZXh0LlxuICAvLyBiZWZvcmVUc1RyYW5zZm9ybWVycy5wdXNoKGNyZWF0ZVRyYW5zZm9ybWVyKGhvc3QsIHR5cGVDaGVja2VyLCAoc291cmNlRmlsZSwgc291cmNlTWFwcGVyKSA9PiB7XG4gIC8vICAgc291cmNlTWFwcGVyLmFkZE1hcHBpbmcoc291cmNlRmlsZSwge3Bvc2l0aW9uOiAwLCBsaW5lOiAwLCBjb2x1bW46IDB9LCB7cG9zaXRpb246IDAsIGxpbmU6IDAsXG4gIC8vICAgY29sdW1uOiAwfSwgc291cmNlRmlsZS50ZXh0Lmxlbmd0aCk7IHJldHVybiBzb3VyY2VGaWxlLnRleHQ7XG4gIC8vIH0pKTtcbiAgY29uc3QgdHNpY2tsZVRyYW5zZm9ybWVycyA9IGNyZWF0ZUN1c3RvbVRyYW5zZm9ybWVycyh7YmVmb3JlOiB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzfSk7XG4gIGNvbnN0IHRzVHJhbnNmb3JtZXJzOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMgPSB7XG4gICAgYmVmb3JlOiBbXG4gICAgICAuLi4oY3VzdG9tVHJhbnNmb3JtZXJzLmJlZm9yZVRzaWNrbGUgfHwgW10pLFxuICAgICAgLi4uKHRzaWNrbGVUcmFuc2Zvcm1lcnMuYmVmb3JlIHx8IFtdKS5tYXAodGYgPT4gc2tpcFRyYW5zZm9ybUZvclNvdXJjZUZpbGVJZk5lZWRlZChob3N0LCB0ZikpLFxuICAgICAgLi4uKGN1c3RvbVRyYW5zZm9ybWVycy5iZWZvcmVUcyB8fCBbXSksXG4gICAgXSxcbiAgICBhZnRlcjogW1xuICAgICAgLi4uKGN1c3RvbVRyYW5zZm9ybWVycy5hZnRlclRzIHx8IFtdKSxcbiAgICAgIC4uLih0c2lja2xlVHJhbnNmb3JtZXJzLmFmdGVyIHx8IFtdKS5tYXAodGYgPT4gc2tpcFRyYW5zZm9ybUZvclNvdXJjZUZpbGVJZk5lZWRlZChob3N0LCB0ZikpXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IHdyaXRlRmlsZURlbGVnYXRlID0gd3JpdGVGaWxlIHx8IHRzSG9zdC53cml0ZUZpbGUuYmluZCh0c0hvc3QpO1xuICBjb25zdCBtb2R1bGVzTWFuaWZlc3QgPSBuZXcgTW9kdWxlc01hbmlmZXN0KCk7XG4gIGNvbnN0IHdyaXRlRmlsZUltcGwgPVxuICAgICAgKGZpbGVOYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgd3JpdGVCeXRlT3JkZXJNYXJrOiBib29sZWFuLFxuICAgICAgIG9uRXJyb3I/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLCBzb3VyY2VGaWxlcz86IHRzLlNvdXJjZUZpbGVbXSkgPT4ge1xuICAgICAgICBpZiAocGF0aC5leHRuYW1lKGZpbGVOYW1lKSAhPT0gJy5tYXAnKSB7XG4gICAgICAgICAgaWYgKHRzT3B0aW9ucy5pbmxpbmVTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb21iaW5lSW5saW5lU291cmNlTWFwcyhwcm9ncmFtLCBmaWxlTmFtZSwgY29udGVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSByZW1vdmVJbmxpbmVTb3VyY2VNYXAoY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRlbnQgPSBlczVwcm9jZXNzb3IuY29udmVydENvbW1vbkpzVG9Hb29nTW9kdWxlSWZOZWVkZWQoXG4gICAgICAgICAgICAgIGhvc3QsIG1vZHVsZXNNYW5pZmVzdCwgZmlsZU5hbWUsIGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBjb21iaW5lU291cmNlTWFwcyhwcm9ncmFtLCBmaWxlTmFtZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3QuYWRkRHRzQ2x1dHpBbGlhc2VzICYmIGlzRHRzRmlsZU5hbWUoZmlsZU5hbWUpICYmIHNvdXJjZUZpbGVzKSB7XG4gICAgICAgICAgY29udGVudCA9IGFkZENsdXR6QWxpYXNlcyhmaWxlTmFtZSwgY29udGVudCwgc291cmNlRmlsZXMsIHR5cGVDaGVja2VyLCBob3N0KTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZUZpbGVEZWxlZ2F0ZShmaWxlTmFtZSwgY29udGVudCwgd3JpdGVCeXRlT3JkZXJNYXJrLCBvbkVycm9yLCBzb3VyY2VGaWxlcyk7XG4gICAgICB9O1xuXG4gIGNvbnN0IHtkaWFnbm9zdGljczogdHNEaWFnbm9zdGljcywgZW1pdFNraXBwZWQsIGVtaXR0ZWRGaWxlc30gPSBwcm9ncmFtLmVtaXQoXG4gICAgICB0YXJnZXRTb3VyY2VGaWxlLCB3cml0ZUZpbGVJbXBsLCBjYW5jZWxsYXRpb25Ub2tlbiwgZW1pdE9ubHlEdHNGaWxlcywgdHNUcmFuc2Zvcm1lcnMpO1xuXG4gIGNvbnN0IGV4dGVybnM6IHtbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgaWYgKGhvc3QudHJhbnNmb3JtVHlwZXNUb0Nsb3N1cmUpIHtcbiAgICBjb25zdCBzb3VyY2VGaWxlcyA9IHRhcmdldFNvdXJjZUZpbGUgPyBbdGFyZ2V0U291cmNlRmlsZV0gOiBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCk7XG4gICAgc291cmNlRmlsZXMuZm9yRWFjaChzZiA9PiB7XG4gICAgICBpZiAoaXNEdHNGaWxlTmFtZShzZi5maWxlTmFtZSkgJiYgaG9zdC5zaG91bGRTa2lwVHNpY2tsZVByb2Nlc3Npbmcoc2YuZmlsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtvdXRwdXQsIGRpYWdub3N0aWNzfSA9IHdyaXRlRXh0ZXJucyh0eXBlQ2hlY2tlciwgc2YsIGhvc3QpO1xuICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICBleHRlcm5zW3NmLmZpbGVOYW1lXSA9IG91dHB1dDtcbiAgICAgIH1cbiAgICAgIGlmIChkaWFnbm9zdGljcykge1xuICAgICAgICB0c2lja2xlRGlhZ25vc3RpY3MucHVzaCguLi5kaWFnbm9zdGljcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gQWxsIGRpYWdub3N0aWNzIChpbmNsdWRpbmcgd2FybmluZ3MpIGFyZSB0cmVhdGVkIGFzIGVycm9ycy5cbiAgLy8gSWYgdGhlIGhvc3QgZGVjaWRlcyB0byBpZ25vcmUgd2FybmluZ3MsIGp1c3QgZGlzY2FyZCB0aGVtLlxuICAvLyBXYXJuaW5ncyBpbmNsdWRlIHN0dWZmIGxpa2UgXCJkb24ndCB1c2UgQHR5cGUgaW4geW91ciBqc2RvY1wiOyB0c2lja2xlXG4gIC8vIHdhcm5zIGFuZCB0aGVuIGZpeGVzIHVwIHRoZSBjb2RlIHRvIGJlIENsb3N1cmUtY29tcGF0aWJsZSBhbnl3YXkuXG4gIHRzaWNrbGVEaWFnbm9zdGljcyA9IHRzaWNrbGVEaWFnbm9zdGljcy5maWx0ZXIoXG4gICAgICBkID0+IGQuY2F0ZWdvcnkgPT09IHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvciB8fFxuICAgICAgICAgICFob3N0LnNob3VsZElnbm9yZVdhcm5pbmdzRm9yUGF0aChkLmZpbGUhLmZpbGVOYW1lKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtb2R1bGVzTWFuaWZlc3QsXG4gICAgZW1pdFNraXBwZWQsXG4gICAgZW1pdHRlZEZpbGVzOiBlbWl0dGVkRmlsZXMgfHwgW10sXG4gICAgZGlhZ25vc3RpY3M6IFsuLi50c0RpYWdub3N0aWNzLCAuLi50c2lja2xlRGlhZ25vc3RpY3NdLFxuICAgIGV4dGVybnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkQ2x1dHpBbGlhc2VzKFxuICAgIGZpbGVOYW1lOiBzdHJpbmcsIGR0c0ZpbGVDb250ZW50OiBzdHJpbmcsIHNvdXJjZUZpbGVzOiB0cy5Tb3VyY2VGaWxlW10sXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBob3N0OiBUc2lja2xlSG9zdCk6IHN0cmluZyB7XG4gIGNvbnN0IHJlZXhwb3J0czogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBzZiBvZiBzb3VyY2VGaWxlcykge1xuICAgIGNvbnN0IG1vZHVsZVN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oc2YpO1xuICAgIGNvbnN0IG1vZHVsZUV4cG9ydHMgPSBtb2R1bGVTeW1ib2wgJiYgdHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKG1vZHVsZVN5bWJvbCk7XG5cbiAgICBpZiAoIW1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIHJldHVybiBkdHNGaWxlQ29udGVudDtcbiAgICB9XG5cbiAgICAvLyBwYXRoVG9Nb2R1bGVOYW1lIGV4cGVjdHMgdGhlIGZpbGUgbmFtZSB0byBlbmQgaW4gLmpzXG4gICAgY29uc3QganNGaWxlTmFtZSA9IGZpbGVOYW1lLnJlcGxhY2UoJy5kLnRzJywgJy5qcycpO1xuICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBob3N0LnBhdGhUb01vZHVsZU5hbWUoJycsIGpzRmlsZU5hbWUpO1xuICAgIGNvbnN0IGNsdXR6TW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUucmVwbGFjZSgvXFwuL2csICckJyk7XG5cbiAgICAvLyBtb2R1bGVFeHBvcnRzIGlzIGEgdHMuTWFwPHRzLlN5bWJvbD4gd2hpY2ggaXMgYW4gZXM2IE1hcCwgYnV0IGhhcyBhXG4gICAgLy8gZGlmZmVyZW50IHR5cGUgZm9yIG5vIHJlYXNvblxuICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIC8vIFdhbnQgdG8gYWxpYXMgdGhlIHN5bWJvbCB0byBtYXRjaCB3aGF0IGNsdXR6IHdvdWxkIHByb2R1Y2UsIHNvIGNsdXR6IC5kLnRzJ3NcbiAgICAgIC8vIGNhbiByZWZlcmVuY2Ugc3ltYm9scyBmcm9tIHR5cGVzY3JpcHQgLmQudHMncy4gU2VlIGV4YW1wbGVzIGF0OlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvY2x1dHovdHJlZS9tYXN0ZXIvc3JjL3Rlc3QvamF2YS9jb20vZ29vZ2xlL2phdmFzY3JpcHQvY2x1dHpcbiAgICAgIGNvbnN0IGNsdXR6U3ltYm9sTmFtZSA9ICdtb2R1bGUkY29udGVudHMkJyArIGNsdXR6TW9kdWxlTmFtZSArICdfJyArIHN5bWJvbC5uYW1lO1xuXG4gICAgICBjb25zdCB7cGFyYW1zLCBwYXJhbXNXaXRoQ29udHJhaW50fSA9IGdldEdlbmVyaWNUeXBlUGFyYW1ldGVycyhzeW1ib2wpO1xuXG4gICAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQ2xhc3MpIHtcbiAgICAgICAgLy8gY2xhc3NlcyBuZWVkIHNwZWNpYWwgY2FyZSB0byBtYXRjaCBjbHV0eiwgd2hpY2ggc2VwZXJhdGVzIGNsYXNzIHR5cGVzIGludG8gYVxuICAgICAgICAvLyB0eXBlIGZvciB0aGUgc3RhdGljIHByb3BlcnRpZXMgYW5kIGEgdHlwZSBmb3IgdGhlIGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICAgICAgcmVleHBvcnRzLnB1c2goYHR5cGUgJHtjbHV0elN5bWJvbE5hbWV9JHtwYXJhbXNXaXRoQ29udHJhaW50fSA9ICR7c3ltYm9sLm5hbWV9JHtwYXJhbXN9O2ApO1xuICAgICAgICByZWV4cG9ydHMucHVzaChgY29uc3QgJHtjbHV0elN5bWJvbE5hbWV9OiB0eXBlb2YgJHtzeW1ib2wubmFtZX07YCk7XG4gICAgICAgIHJlZXhwb3J0cy5wdXNoKFxuICAgICAgICAgICAgYHR5cGUgJHtjbHV0elN5bWJvbE5hbWV9X0luc3RhbmNlJHtwYXJhbXNXaXRoQ29udHJhaW50fSA9ICR7c3ltYm9sLm5hbWV9JHtwYXJhbXN9O2ApO1xuICAgICAgICByZWV4cG9ydHMucHVzaChgY29uc3QgJHtjbHV0elN5bWJvbE5hbWV9X0luc3RhbmNlOiB0eXBlb2YgJHtzeW1ib2wubmFtZX07YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZSkge1xuICAgICAgICByZWV4cG9ydHMucHVzaChgdHlwZSAke2NsdXR6U3ltYm9sTmFtZX0ke3BhcmFtc1dpdGhDb250cmFpbnR9ID0gJHtzeW1ib2wubmFtZX0ke3BhcmFtc307YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpIHtcbiAgICAgICAgcmVleHBvcnRzLnB1c2goYGNvbnN0ICR7Y2x1dHpTeW1ib2xOYW1lfTogdHlwZW9mICR7c3ltYm9sLm5hbWV9O2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZWV4cG9ydHMubGVuZ3RoKSB7XG4gICAgZHRzRmlsZUNvbnRlbnQgKz0gJ2RlY2xhcmUgZ2xvYmFsIHtcXG4nO1xuICAgIGR0c0ZpbGVDb250ZW50ICs9IGBcXHRuYW1lc3BhY2Ug4LKgX+CyoC5jbHV0eiB7XFxuYDtcbiAgICBmb3IgKGNvbnN0IHJlZXhwb3J0IG9mIHJlZXhwb3J0cykge1xuICAgICAgZHRzRmlsZUNvbnRlbnQgKz0gYFxcdFxcdCR7cmVleHBvcnR9XFxuYDtcbiAgICB9XG4gICAgZHRzRmlsZUNvbnRlbnQgKz0gJ1xcdH1cXG59XFxuJztcbiAgfVxuXG4gIHJldHVybiBkdHNGaWxlQ29udGVudDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIDIgc3RyaW5ncyBzcGVjaWZ5aW5nIHRoZSBnZW5lcmljIHR5cGUgYXJndW1lbnRzIGZvciB0aGUgc3ltYm9sLiAgVGhlIGNvbnN0cmFpbmVkIHBhcmFtc1xuICogaW5jbHVkZSBhbnkgYFQgZXh0ZW5kcyBmb29gIGFyZ3VtZW50cywgdGhlIHJlZ3VsYXIgcGFyYW1zIGFyZSBqdXN0IGEgbGlzdCBvZiB0aGUgdHlwZSBzeW1ib2xzLFxuICogc2luY2Ugd2UgbmVlZCB0aGUgY29uc3RyYWludHMgb24gdGhlIExIUyBvZiB0aGUgYWxpYXMgZGVjbGFyYXRpb24sIGJ1dCBjYW4ndCBoYXZlIHRoZW0gb24gdGhlXG4gKiBSSFMuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyaWNUeXBlUGFyYW1ldGVycyhzeW1ib2w6IHRzLlN5bWJvbCk6XG4gICAge3BhcmFtczogc3RyaW5nLCBwYXJhbXNXaXRoQ29udHJhaW50OiBzdHJpbmd9IHtcbiAgaWYgKCFzeW1ib2wuZGVjbGFyYXRpb25zKSB7XG4gICAgcmV0dXJuIHtwYXJhbXM6ICcnLCBwYXJhbXNXaXRoQ29udHJhaW50OiAnJ307XG4gIH1cblxuICAvLyBBbGwgZGVjbGFyYXRpb25zIGhhdmUgdG8gaGF2ZSBtYXRjaGluZyBnZW5lcmljIHR5cGVzLCBzbyB3ZSdyZSBzYWZlIGp1c3QgbG9va2luZyBhdFxuICAvLyB0aGUgZmlyc3Qgb25lLlxuICBpZiAoIXN5bWJvbC5kZWNsYXJhdGlvbnNbMF0pIHtcbiAgICByZXR1cm4ge3BhcmFtczogJycsIHBhcmFtc1dpdGhDb250cmFpbnQ6ICcnfTtcbiAgfVxuXG4gIGNvbnN0IGRlY2xhcmF0aW9uID0gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcblxuICBpZiAoW1xuICAgICAgICB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb24sIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3JLZXl3b3JkLFxuICAgICAgICB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24sIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgICAgIHRzLlN5bnRheEtpbmQuVHlwZUFsaWFzRGVjbGFyYXRpb25cbiAgICAgIF0uaW5kZXhPZihkZWNsYXJhdGlvbi5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4ge3BhcmFtczogJycsIHBhcmFtc1dpdGhDb250cmFpbnQ6ICcnfTtcbiAgfVxuXG4gIGNvbnN0IGRlY2xhcmF0aW9uV2l0aFR5cGVQYXJhbWV0ZXJzOiB0cy5EZWNsYXJhdGlvbldpdGhUeXBlUGFyYW1ldGVycyA9XG4gICAgICBkZWNsYXJhdGlvbiBhcyB0cy5EZWNsYXJhdGlvbldpdGhUeXBlUGFyYW1ldGVycztcblxuICBpZiAoIWRlY2xhcmF0aW9uV2l0aFR5cGVQYXJhbWV0ZXJzLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHtwYXJhbXM6ICcnLCBwYXJhbXNXaXRoQ29udHJhaW50OiAnJ307XG4gIH1cblxuICBjb25zdCBwYXJhbUxpc3Q6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGNvbnN0cmFpbmVkUGFyYW1MaXN0OiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcmFtIG9mIGRlY2xhcmF0aW9uV2l0aFR5cGVQYXJhbWV0ZXJzLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgbGV0IGNvbnN0cmFpbmVkUGFyYW0gPSBwYXJhbS5uYW1lLmdldFRleHQoKTtcbiAgICBpZiAocGFyYW0uY29uc3RyYWludCkge1xuICAgICAgY29uc3RyYWluZWRQYXJhbSArPSBgIGV4dGVuZHMgJHtwYXJhbS5jb25zdHJhaW50LmdldFRleHQoKX1gO1xuICAgIH1cbiAgICBpZiAocGFyYW0uZGVmYXVsdCkge1xuICAgICAgY29uc3RyYWluZWRQYXJhbSArPSBgID0gJHtwYXJhbS5kZWZhdWx0LmdldFRleHQoKX1gO1xuICAgIH1cbiAgICBjb25zdHJhaW5lZFBhcmFtTGlzdC5wdXNoKGNvbnN0cmFpbmVkUGFyYW0pO1xuICAgIHBhcmFtTGlzdC5wdXNoKHBhcmFtLm5hbWUuZ2V0VGV4dCgpKTtcbiAgfVxuXG4gIGNvbnN0IHBhcmFtcyA9IGA8JHtwYXJhbUxpc3Quam9pbignLCcpfT5gO1xuICBjb25zdCBwYXJhbXNXaXRoQ29udHJhaW50ID0gYDwke2NvbnN0cmFpbmVkUGFyYW1MaXN0LmpvaW4oJywnKX0+YDtcblxuICByZXR1cm4ge3BhcmFtcywgcGFyYW1zV2l0aENvbnRyYWludH07XG59XG5cbmZ1bmN0aW9uIHNraXBUcmFuc2Zvcm1Gb3JTb3VyY2VGaWxlSWZOZWVkZWQoXG4gICAgaG9zdDogVHNpY2tsZUhvc3QsXG4gICAgZGVsZWdhdGVGYWN0b3J5OiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4pOiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGRlbGVnYXRlID0gZGVsZWdhdGVGYWN0b3J5KGNvbnRleHQpO1xuICAgIHJldHVybiAoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkgPT4ge1xuICAgICAgaWYgKGhvc3Quc2hvdWxkU2tpcFRzaWNrbGVQcm9jZXNzaW5nKHNvdXJjZUZpbGUuZmlsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VGaWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGVnYXRlKHNvdXJjZUZpbGUpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVJbmxpbmVTb3VyY2VNYXBzKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGZpbGVQYXRoOiBzdHJpbmcsIGNvbXBpbGVkSnNXaXRoSW5saW5lU291cmNlTWFwOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoaXNEdHNGaWxlTmFtZShmaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gY29tcGlsZWRKc1dpdGhJbmxpbmVTb3VyY2VNYXA7XG4gIH1cbiAgY29uc3Qgc291cmNlTWFwSnNvbiA9IGV4dHJhY3RJbmxpbmVTb3VyY2VNYXAoY29tcGlsZWRKc1dpdGhJbmxpbmVTb3VyY2VNYXApO1xuICBjb21waWxlZEpzV2l0aElubGluZVNvdXJjZU1hcCA9IHJlbW92ZUlubGluZVNvdXJjZU1hcChjb21waWxlZEpzV2l0aElubGluZVNvdXJjZU1hcCk7XG4gIGNvbnN0IGNvbXBvc2VkU291cmNlTWFwID0gY29tYmluZVNvdXJjZU1hcHMocHJvZ3JhbSwgZmlsZVBhdGgsIHNvdXJjZU1hcEpzb24pO1xuICByZXR1cm4gc2V0SW5saW5lU291cmNlTWFwKGNvbXBpbGVkSnNXaXRoSW5saW5lU291cmNlTWFwLCBjb21wb3NlZFNvdXJjZU1hcCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVTb3VyY2VNYXBzKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGZpbGVQYXRoOiBzdHJpbmcsIHRzY1NvdXJjZU1hcFRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHRzY1NvdXJjZU1hcCA9IHBhcnNlU291cmNlTWFwKHRzY1NvdXJjZU1hcFRleHQpO1xuICBpZiAodHNjU291cmNlTWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgLy8gc3RyaXAgaW5jb21pbmcgc291cmNlbWFwcyBmcm9tIHRoZSBzb3VyY2VzIGluIHRoZSBzb3VyY2VtYXBcbiAgICAvLyB0byByZWR1Y2UgdGhlIHNpemUgb2YgdGhlIHNvdXJjZW1hcC5cbiAgICB0c2NTb3VyY2VNYXAuc291cmNlc0NvbnRlbnQgPSB0c2NTb3VyY2VNYXAuc291cmNlc0NvbnRlbnQubWFwKGNvbnRlbnQgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5zSW5saW5lU291cmNlTWFwKGNvbnRlbnQpKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZW1vdmVJbmxpbmVTb3VyY2VNYXAoY29udGVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmaWxlRGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgbGV0IHRzY1NvdXJjZU1hcEdlbmVyYXRvcjogU291cmNlTWFwR2VuZXJhdG9yfHVuZGVmaW5lZDtcbiAgZm9yIChjb25zdCBzb3VyY2VGaWxlTmFtZSBvZiB0c2NTb3VyY2VNYXAuc291cmNlcykge1xuICAgIGNvbnN0IHNvdXJjZUZpbGUgPSBwcm9ncmFtLmdldFNvdXJjZUZpbGUocGF0aC5yZXNvbHZlKGZpbGVEaXIsIHNvdXJjZUZpbGVOYW1lKSk7XG4gICAgaWYgKCFzb3VyY2VGaWxlIHx8ICFjb250YWluc0lubGluZVNvdXJjZU1hcChzb3VyY2VGaWxlLnRleHQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcHJlZXhpc3RpbmdTb3VyY2VNYXBUZXh0ID0gZXh0cmFjdElubGluZVNvdXJjZU1hcChzb3VyY2VGaWxlLnRleHQpO1xuICAgIGlmICghdHNjU291cmNlTWFwR2VuZXJhdG9yKSB7XG4gICAgICB0c2NTb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChuZXcgU291cmNlTWFwQ29uc3VtZXIodHNjU291cmNlTWFwKSk7XG4gICAgfVxuICAgIHRzY1NvdXJjZU1hcEdlbmVyYXRvci5hcHBseVNvdXJjZU1hcChcbiAgICAgICAgbmV3IFNvdXJjZU1hcENvbnN1bWVyKHBhcnNlU291cmNlTWFwKHByZWV4aXN0aW5nU291cmNlTWFwVGV4dCwgc291cmNlRmlsZU5hbWUpKSk7XG4gIH1cbiAgcmV0dXJuIHRzY1NvdXJjZU1hcEdlbmVyYXRvciA/IHRzY1NvdXJjZU1hcEdlbmVyYXRvci50b1N0cmluZygpIDogdHNjU291cmNlTWFwVGV4dDtcbn1cbiJdfQ==